---- [ LUCIFER VARIABLE API ] ----
	bot = getBot()
	Proxy_Manager = getProxyManager()
---- [ END LUCIFER VARIABLE API ] ----


---- [ GKS VARIABLE ] ----
--Folder and file variable
	logFolder = "GKSlog"
	proxyFile = logFolder .. "/proxyLog"
---- [ END GKS VARIABLE ] ----


---- [ PROXY SETTINGS ] ----
--Add proxy
	Add_Proxy = Proxy_Settings.Add_Proxy:upper()
	Proxy_List = Proxy_Settings.Proxy_List
----------------------------------
--Preferences
	Proxy_Limit = tonumber(Proxy_Settings.Proxy_Limit)
	Bypass_Logon = Proxy_Settings.Bypass_Logon:upper()
	
	Change_Proxy = Proxy_Settings.Change_Proxy:upper()
	Change_Proxy_List = Proxy_Settings.Change_Proxy_List
---- [ END PROXY SETTINGS ] ----


---- [ NEW CHANGE PROXY TABLE ] ----
New_Change_Proxy_List = {}
for i = 1, tonumber(Proxy_Limit) do
	for _, changeProxyList in ipairs(Change_Proxy_List) do
		table.insert(New_Change_Proxy_List, changeProxyList)
		sleep(100)
	end
end
---- [ END NEW CHANGE PROXY TABLE ] ----


---- [ BOT SETTINGS ] ----
--Preferences
	Use_Start_Script_Cooldown_Per_Bot = Bot_Settings.Use_Start_Script_Cooldown_Per_Bot:upper()
	Start_Script_Cooldown_Per_Bot = tonumber(Bot_Settings.Start_Script_Cooldown_Per_Bot)
	Auto_Addbot = Bot_Settings.Auto_Addbot:upper()
---- [ END BOT SETTINGS ] ----


---- [ MAKING GKS LOG FOLDER ] ----
function createLogFolder()
	os.execute("mkdir " .. logFolder)
end
---- [ END MAKING GKS LOG FOLDER ] ----


---- [ ADD PROXY ] ----
function proxyLog()
	local filename = string.format("%s.txt", proxyFile)
	local newFile = io.open(filename, "w")
	for _, writeProxy in pairs(Proxy_List) do
		newFile:write(writeProxy .. " \n")
		sleep(100)
	end
	newFile:close()
end

function bypassLogon(botIndex)
	if Bypass_Logon == "YES" then
		botIndex.bypass_logon = true
	elseif Bypass_Logon == "NO" then
		botIndex.bypass_logon = false
	end
end

function addProxyMain()
	Proxy_Manager.localize = true
	Proxy_Manager.spread = false
	Proxy_Manager:setLimit(Proxy_Limit)
	
	if Add_Proxy == "NO" then 
		return 
	elseif Add_Proxy == "YES" then
		proxyLog()
		
		for _, getProxy in pairs(Proxy_List) do
			Proxy_Manager:addProxy(getProxy)
			sleep(100)
		end
	end
end
---- [ END ADD PROXY ] ----


---- [ RUNNING ] ----
createLogFolder()
addProxyMain()

if Auto_Addbot == "YES" then
	local remainingBots = Bot_Settings.Total_Bot_Used - #getBots()
	if remainingBots > 0 then
		for index = 1, remainingBots do
			indexString = tostring(index)
			addBot(indexString, indexString)
			sleep(100)
		end
		
		while #getBots() < Bot_Settings.Total_Bot_Used do
			sleep(1000)
		end
	end
end

indexRunningScript = {}
indexUnrunningScript = {}
for i, bots in ipairs(getBots()) do
	if bots:isRunningScript() then
		table.insert(indexRunningScript, i)
	else
		bots.reconnect_interval = 1000
		table.insert(indexUnrunningScript, i)
	end
end
---- [ END RUNNING ] ----

ScriptHelping1 = [[
---- [ PROXY SETTINGS ] ----
--Add proxy
	Proxy_List = { "]] .. table.concat(Proxy_Settings.Proxy_List, '", "') .. [[" }
----------------------------------
--Change proxy
	Change_Proxy = "]] .. Proxy_Settings.Change_Proxy:upper() .. [["
	Change_Proxy_List = { "]] .. table.concat(New_Change_Proxy_List, '", "') .. [[" }

--Change proxy options:
--Change proxy on proxy playtime
	Change_Proxy_On_Proxy_Playtime = "]] .. Proxy_Settings.Change_Proxy_On_Proxy_Playtime:upper() .. [["
	Proxy_Playtime = ]] .. tonumber(Proxy_Settings.Proxy_Playtime) .. [[
		Proxy_Playtime_Milliseconds = Proxy_Playtime * 60 * 1000
----------------------------------
--Preferences
	Proxy_Limit = ]] .. tonumber(Proxy_Settings.Proxy_Limit) .. [[
	Proxy_Type = "]] .. Proxy_Settings.Proxy_Type:upper() .. [["
	Bypass_Logon = "]] .. Proxy_Settings.Bypass_Logon:upper() .. [["
---- [ END PROXY SETTINGS ] ----


---- [ BOT SETTINGS ] ----
--Add bot
	Use_External_Bot_List = "]] .. Bot_Settings.Use_External_Bot_List:upper() .. [["
	External_Bot_List_Path = "]] .. Bot_Settings.External_Bot_List_Path .. [["
	Bot_List = { "]] .. table.concat(Bot_Settings.Bot_List, '", "') .. [[" }
----------------------------------
--Change bot
	Change_Bot = "]] .. Bot_Settings.Change_Bot:upper() .. [["
	Change_Bot_Cooldown = ]] .. tonumber(Bot_Settings.Change_Bot_Cooldown) .. [[	
		Change_Bot_Cooldown_Milliseconds = Change_Bot_Cooldown * 60 * 1000
	
--Change bot options:
--Change bot on max level
	Change_Bot_On_Max_Level = "]] .. Bot_Settings.Change_Bot_On_Max_Level:upper() .. [["
	Min_Level = ]] .. tonumber(Bot_Settings.Min_Level) .. [[
	Max_Level = ]] .. tonumber(Bot_Settings.Max_Level) .. [[

--Change bot on bot playtime
	Change_Bot_On_Bot_Playtime = "]] .. Bot_Settings.Change_Bot_On_Bot_Playtime:upper() .. [["
	Bot_Playtime = ]] .. tonumber(Bot_Settings.Bot_Playtime) .. [[
		Bot_Playtime_Milliseconds = Bot_Playtime * 60 * 1000
----------------------------------
--Ban wave estimated setting
	Ban_Wave_Estimated = "]] .. Bot_Settings.Ban_Wave_Estimated:upper() .. [["
	Ban_Wave_Estimated_Cooldown = ]] .. tonumber(Bot_Settings.Ban_Wave_Estimated_Cooldown) .. [[
		Ban_Wave_Estimated_Cooldown_Milliseconds = Ban_Wave_Estimated_Cooldown * 60 * 1000
	
--Ban wave etimated options:
--Based on estimated time
	Ban_Wave_Estimated_With_Time = "]] .. Bot_Settings.Ban_Wave_Estimated_With_Time:upper() .. [["
	Growtopia_Time_Difference = ]] .. tonumber(Bot_Settings.Growtopia_Time_Difference) .. [[
	Ban_Wave_Estimated_Time = { "]] .. table.concat(Bot_Settings.Ban_Wave_Estimated_Time, '", "') .. [[" }
----------------------------------
--Preferences
	Take_Pickaxe = "]] .. Bot_Settings.Take_Pickaxe:upper() .. [["
	Pickaxe_World = "]] .. Bot_Settings.Pickaxe_World:upper() .. [["
		Pickaxe_World, Pickaxe_Door_ID = Pickaxe_World:match("([^:|]+)[:|]([^:|]+)")
		if Pickaxe_Door_ID == "-" then
			Pickaxe_Door_ID = ""
		end
	Pickaxe_ID = ]] .. tonumber(Bot_Settings.Pickaxe_ID) .. [[
	
	AAP_Verification = "]] .. Bot_Settings.AAP_Verification:upper() .. [["
	AAP_Verification_Cooldown = ]] .. tonumber(Bot_Settings.AAP_Verification_Cooldown) .. [[
	Auto_Buy_Rare_Clothes_Pack = "]] .. Bot_Settings.Auto_Buy_Rare_Clothes_Pack:upper() .. [["
	
	Move_Speed_1 = ]] .. tonumber(Bot_Settings.Move_Speed_1) .. [[
	Move_Speed_2 = ]] .. tonumber(Bot_Settings.Move_Speed_2) .. [[
	Move_Range = ]] .. tonumber(Bot_Settings.Move_Range) .. [[
	Show_Punch_Animation = "]] .. Bot_Settings.Show_Punch_Animation:upper() .. [["
	Show_Move_Animation = "]] .. Bot_Settings.Show_Move_Animation:upper() .. [["
	Remove_Bot = "]] .. Bot_Settings.Remove_Bot:upper() .. [["
---- [ END BOT SETTINGS ] ----


---- [ ROTATION SETTINGS ] ----
--Rotation setting
	Use_External_Rotation_World_List = "]] .. Rotation_Settings.Use_External_Rotation_World_List:upper() .. [["
	External_Rotation_World_List_Path = "]] .. Rotation_Settings.External_Rotation_World_List_Path .. [["
	Rotation_World_List = { "]] .. table.concat(Rotation_Settings.Rotation_World_List, '", "') .. [[" }
	Spread_Rotation_World_List = "]] .. Rotation_Settings.Spread_Rotation_World_List:upper() .. [["
	Start_Rotation_World_List = ]] .. tonumber(Rotation_Settings.Start_Rotation_World_List) .. [[
	
	Save_Seed_World_List = { "]] .. table.concat(Rotation_Settings.Save_Seed_World_List, '", "') .. [[" }
	Save_Pack_World_List = { "]] .. table.concat(Rotation_Settings.Save_Pack_World_List, '", "') .. [[" }
	
	Use_Looping = "]] .. Rotation_Settings.Use_Looping:upper() .. [["
	Auto_Plant = "]] .. Rotation_Settings.Auto_Plant:upper() .. [["
	Ignore_Gems = "]] .. Rotation_Settings.Ignore_Gems:upper() .. [["
----------------------------------
--PNB setting
	X_Break = ]] .. tonumber(Rotation_Settings.X_Break) .. [[
	Y_Break = ]] .. tonumber(Rotation_Settings.Y_Break) .. [[
	PNB_Range = ]] .. tonumber(Rotation_Settings.PNB_Range) .. [[
		if Spread_Rotation_World_List == "NO" and PNB_Range % 2 > 0 then
			PNB_Range_Helping = PNB_Range + 1
		else
			PNB_Range_Helping = PNB_Range
		end
	Auto_Retrieve = "]] .. Rotation_Settings.Auto_Retrieve:upper() .. [["
	Break_Other_World = "]] .. Rotation_Settings.Break_Other_World:upper() .. [["
	
--Break other world options:
--Break other world in the custom world
	Use_Custom_World_For_Break = "]] .. Rotation_Settings.Use_Custom_World_For_Break:upper() .. [["
	Custom_World_For_Break_List = { "]] .. table.concat(Rotation_Settings.Custom_World_For_Break_List, '", "') .. [[" }
	
--Break other world in random world (Bot automatically create new world)
	Use_Random_World_For_Break = "]] .. Rotation_Settings.Use_Random_World_For_Break:upper() .. [["
	Buy_Signal_Jammer = "]] .. Rotation_Settings.Buy_Signal_Jammer:upper() .. [["
	
--Break other world in the tutorial world (World name must contain the bot name)
	Use_Tutorial_World_For_Break = "]] .. Rotation_Settings.Use_Tutorial_World_For_Break:upper() .. [["
		tutorialWorld = "nil"
----------------------------------
--Auto buy setting
	Auto_Buy_Pack = "]] .. Rotation_Settings.Auto_Buy_Pack:upper() .. [["
	Pack_To_Buy_List = { "]] .. table.concat(Rotation_Settings.Pack_To_Buy_List, '", "') .. [[" }
	Max_Buy_Pack = ]] .. tonumber(Rotation_Settings.Max_Buy_Pack) .. [[
	Max_Pack_To_Drop = ]] .. tonumber(Rotation_Settings.Max_Pack_To_Drop) .. [[
		if Max_Pack_To_Drop == 0 then
			Max_Pack_To_Drop = 1
		elseif Max_Pack_To_Drop > 170 then
			Max_Pack_To_Drop = 170
		end
----------------------------------
--Auto consume setting [NOTE: To retrieve food item from world storage use the Equipment_World_List feature]
	Auto_Consume = "]] .. Rotation_Settings.Auto_Consume:upper() .. [["
	Consume_ID = { ]] .. table.concat(Rotation_Settings.Consume_ID, ', ') .. [[ }

--Auto consume options:
--Consume at specific level only
	Only_Consume_At_Specific_Level = "]] .. Rotation_Settings.Only_Consume_At_Specific_Level:upper() .. [["

--Consume until minimum level only
	Only_Consume_Until_Minimum_Level = "]] .. Rotation_Settings.Only_Consume_Until_Minimum_Level:upper() .. [["
----------------------------------
--Leveling setting
	Leveling_Status = "]] .. Rotation_Settings.Leveling_Status:upper() .. [["
	
--Leveling options:
--Leveling with auto cooking [NOTE: To drop food that has finished cooking use the Drop_Item_Whitelist feature]
	Set_Food = ]] .. tonumber(Rotation_Settings.Set_Food) .. [[
		if Set_Food == 1 then
			Ingredients_ID = { 3472, 4602, 4588, 962 }
		end
	Cook_World_List = { "]] .. table.concat(Rotation_Settings.Cook_World_List, '", "') .. [[" }

--Auto cooking options:
--Cooking at specific level only
	Only_Cook_At_Specific_Level = "]] .. Rotation_Settings.Only_Cook_At_Specific_Level:upper() .. [["

--Cooking until minimum level only
	Only_Cook_Until_Minimum_Level = "]] .. Rotation_Settings.Only_Cook_Until_Minimum_Level:upper() .. [["
----------------------------------
--Preferences
	Equipment_World_List = { "]] .. table.concat(Rotation_Settings.Equipment_World_List, '", "') .. [[" }
		
	Specified_Level = { ]] .. table.concat(Rotation_Settings.Specified_Level, ', ') .. [[ }
		TotalSpecifiedLevelList = #Specified_Level
		
	Auto_Fossil = "]] .. Rotation_Settings.Auto_Fossil:upper() .. [["
		fossilEquipment = { 3932, 3934, 4132 }
		fossilFinishEquipment = { 3932, 3934, 4132, 4134 }
	
	Auto_Kill_Ghost = "]] .. Rotation_Settings.Auto_Kill_Ghost:upper() .. [["
	Auto_Kill_Ghost_Only = "]] .. Rotation_Settings.Auto_Kill_Ghost_Only:upper() .. [["
		ghostEquipment = { 6086, 3714 }
		
	Anti_Fire = "]] .. Rotation_Settings.Anti_Fire:upper() .. [["
		fireID = 14580
		fireEquipment = { 3066 }
		
	Anti_Toxic = "]] .. Rotation_Settings.Anti_Toxic:upper() .. [["
	
	Wearing_Specific_Item = "]] .. Rotation_Settings.Wearing_Specific_Item:upper() .. [["
	Wearing_Specific_Item_ID = { ]] .. table.concat(Rotation_Settings.Wearing_Specific_Item_ID, ', ') .. [[ }
	Max_Specific_Item_To_Retrieve = ]] .. tonumber(Rotation_Settings.Max_Specific_Item_To_Retrieve) .. [[

	Auto_Take_Floating_Block = "]] .. Rotation_Settings.Auto_Take_Floating_Block:upper() .. [["
---- [ END ROTATION SETTINGS ] ----
]]

ScriptHelping2 = [[
---- [ ADVANCED SETTINGS ] ----
--Webhook setting
	Use_Webhook = "]] .. Advanced_Settings.Use_Webhook:upper() .. [["
	Edit_Webhook_Message = "]] .. Advanced_Settings.Edit_Webhook_Message:upper() .. [["
	Webhook_Link_Bot_Information = { "]] .. table.concat(Advanced_Settings.Webhook_Link_Bot_Information, '", "') .. [[" }
	Webhook_Link_Dropped_Item = { "]] .. table.concat(Advanced_Settings.Webhook_Link_Dropped_Item, '", "') .. [[" }
	Webhook_Link_Reconnect = { "]] .. table.concat(Advanced_Settings.Webhook_Link_Reconnect, '", "') .. [[" }

	Use_Webhook_For_All_Bot_Information = "]] .. Advanced_Settings.Use_Webhook_For_All_Bot_Information:upper() .. [["
	Edit_Webhook_Message_For_All_Bot_Information = "]] .. Advanced_Settings.Edit_Webhook_Message_For_All_Bot_Information:upper() .. [["
	Webhook_Link_All_Bot_Information = "]] .. Advanced_Settings.Webhook_Link_All_Bot_Information .. [["
		Webhook_Link_All_Bot_Information, Message_ID_All_Bot_Information = Webhook_Link_All_Bot_Information:match("([^|]+)[|]([^|]+)")
		Message_ID_All_Bot_Information = tonumber(Message_ID_All_Bot_Information)
	All_Bot_Information_Cooldown = ]] .. tonumber(Advanced_Settings.All_Bot_Information_Cooldown) .. [[
		All_Bot_Information_Cooldown_Milliseconds = All_Bot_Information_Cooldown * 1000
----------------------------------
--Delay (milliseconds)
	Harvest_Delay = ]] .. tonumber(Advanced_Settings.Harvest_Delay) .. [[
	Plant_Delay = ]] .. tonumber(Advanced_Settings.Plant_Delay) .. [[
	Hit_Delay = ]] .. tonumber(Advanced_Settings.Hit_Delay) .. [[
	Place_Delay = ]] .. tonumber(Advanced_Settings.Place_Delay) .. [[
	Drop_Delay = ]] .. tonumber(Advanced_Settings.Drop_Delay) .. [[
	Auto_Buy_Delay = ]] .. tonumber(Advanced_Settings.Auto_Buy_Delay) .. [[
	Wear_Delay = ]] .. tonumber(Advanced_Settings.Wear_Delay) .. [[
	Join_World_Delay = ]] .. tonumber(Advanced_Settings.Join_World_Delay) .. [[
	Hard_Warp_Join_World_Delay = ]] .. tonumber(Advanced_Settings.Hard_Warp_Join_World_Delay) .. [[
	Reconnect_Delay = ]] .. tonumber(Advanced_Settings.Reconnect_Delay) .. [[
		Reconnect_Delay_Cooldown_Seconds = Reconnect_Delay / 1000
	
--Delay (Minutes)
	Maintenance_Cooldown = ]] .. tonumber(Advanced_Settings.Maintenance_Cooldown) .. [[
		Maintenance_Cooldown_Milliseconds = Maintenance_Cooldown * 60 * 1000
	Mod_Entered_Cooldown = ]] .. tonumber(Advanced_Settings.Mod_Entered_Cooldown) .. [[
		Mod_Entered_Cooldown_Milliseconds = Mod_Entered_Cooldown * 60 * 1000
----------------------------------
--Preferences
	Platform_Used = "]] .. Advanced_Settings.Platform_Used:upper() .. [["
	Max_Block_To_Retrieve = ]] .. tonumber(Advanced_Settings.Max_Block_To_Retrieve) .. [[
	Max_Seed_To_Drop = ]] .. tonumber(Advanced_Settings.Max_Seed_To_Drop) .. [[
	
	Auto_Hidden_World = "]] .. Advanced_Settings.Auto_Hidden_World:upper() .. [["
	Hidden_World_List = { "]] .. table.concat(Advanced_Settings.Hidden_World_List, '", "') .. [[" }
	
	Random_Chat_Status = "]] .. Advanced_Settings.Random_Chat_Status:upper() .. [["
	Random_Chat_List = { "]] .. table.concat(Advanced_Settings.Random_Chat_List, '", "') .. [[" }
	Chat_Cooldown = ]] .. tonumber(Advanced_Settings.Chat_Cooldown) .. [[
	
	Drop_Item_Whitelist = "]] .. Advanced_Settings.Drop_Item_Whitelist:upper() .. [["
	Whitelist_World_List = { "]] .. table.concat(Advanced_Settings.Whitelist_World_List, '", "') .. [[" }
	Max_Item_Whitelist_To_Drop = ]] .. tonumber(Advanced_Settings.Max_Item_Whitelist_To_Drop) .. [[
	Item_Whitelist_ID = { ]] .. table.concat(Advanced_Settings.Item_Whitelist_ID, ', ') .. [[ }
	
	Auto_Trash = "]] .. Advanced_Settings.Auto_Trash:upper() .. [["
	Trash_Item_ID = { ]] .. table.concat(Advanced_Settings.Trash_Item_ID, ', ') .. [[ }
	
	Stop_Script = "]] .. Advanced_Settings.Stop_Script:upper() .. [["
	High_Ping = ]] .. tonumber(Advanced_Settings.High_Ping) .. [[
	Max_Connect_Count = ]] .. tonumber(Advanced_Settings.Max_Connect_Count) .. [[
		maxReconnectCount = Max_Connect_Count
	Max_Reconnect_Cooldown = ]] .. tonumber(Advanced_Settings.Max_Reconnect_Cooldown) .. [[
		Max_Reconnect_Cooldown_Milliseconds = Max_Reconnect_Cooldown * 60 * 1000
	GMT_Time_Zone = ]] .. tonumber(Advanced_Settings.GMT_Time_Zone) .. [[
---- [ END ADVANCED SETTINGS ] ----
]]

Script = [[
--Don't delete or change the script function below!
---- [ LUCIFER VARIABLE API ] ----
	bot = getBot()
	world = bot:getWorld()
	inventory = bot:getInventory()
	bot.auto_reconnect = false
	bot.reconnect_interval = 15
	bot.collect_path_check = true
	bot.collect_range = 4
	bot.object_collect_delay = 50
	bot.collect_interval = 100
---- [ END LUCIFER VARIABLE API ] ----


---- [ GKS VARIABLE ] ----
--Dropped variable
	dropPackCount = ""
	dropPackCountTable = {}
	dropSeedCount = 0
	dropBlockCount = 0
	dropEquipmentCount = "\n 0"
--------------------------
--Bot number & proxy number variable
	local botStartNumber = 1
	local proxyStartNumber = 1
--------------------------
--Harvest, plant, take gems root, findpath seed, findpath block & findpath animation variable
	tileHarvestPlantX = 1
	tileHarvestPlantY = 23
	
	findpathSeedX = 1
	findpathSeedY = 23
	
	findpathBlockX = 1
	findpathBlockY = 23
	
	actionRotationAndFindpathAnimation = false
--------------------------
--Last Hidden World, default world name, bot x, bot y variable
	lastHiddenWorld = "WORLD3"
	defaultWorldName = "HELLOGKS"
	defaultBotX = 61
	defaultBotY = 23
--------------------------
--Break other world variable
	breakOtherWorldX = 1
	breakOtherWorldY = 23
	cachedWorldBreak = nil
	notWorldBanned = true
--------------------------
--Gaia and UT variable
	wrenchGaiaX = nil
	wrenchGaiaY = nil
	
	wrenchUnstableX = nil
	wrenchUnstableY = nil
--------------------------
--Reconnect variable
	connectCount = 0
	autoRecon = true
--------------------------
--Number of trees harvested
	job = 0
--------------------------
--Next world status and all bots status	
	nextWorldStatus = true
	dropPackStatus = false
	dropWhitelistStatus = false
	dropSeedBlockStatus = false
	dropPickaxeStatus = false
	takingPickaxeStatus = false
--------------------------
--Webhook variable
	scriptName = "Rotation Script"
	scriptCredit = "**Grow King Scripts**"
	reportCenterLink = "https://discord.gg/XvjAqQ8ZuG"
	reportCenter = ":warning: **|** Report illegal resale and distribution of script/login code to <@1034725351873576990> for a free 300 GKS Balance. For more information [click here!](<" .. reportCenterLink .. ">)"
	webhookTitle = scriptName .. " \nScript By " .. scriptCredit
	webhookAvatar = "https://media.discordapp.net/attachments/1151744897687224320/1160427676654391428/GKS_Logo.jpg?ex=65349f7d&is=65222a7d&hm=b11ee741e5b45e61d96257712224c5ad4c5c44e4e42fde4e441c529a646a708c&=&width=427&height=427"
	webhookImage = "https://media.discordapp.net/attachments/1151744897687224320/1160427676381741106/GKS_Footer.jpg?ex=65349f7d&is=65222a7d&hm=3e4925cc5fb2ba188bf8c6c4ae7cc58aeca7ca1507011b923c8500e1aa70eb8b&="
--------------------------
--Folder and file variable
	logFolder = "GKSlog"
	newGuestFile = logFolder .. "/newGuestLog"
	removeBotFile = logFolder .. "/growidLog"
	randomBreakOtherWorldFile = logFolder .. "/randomBreakOtherWorldLog"
	configFile = logFolder .. "/config"
--------------------------
--Time variable
	proxyTime = os.time()
	botTime = os.time()
---- [ END GKS VARIABLE ] ----


---- [ REMOVE INDEX BOT ] ---
function removeBotIndex(remove_bot_status, error_message)
	if remove_bot_status == "YES" then
		bot:stopScript()
		removeBot(bot.name)
		sleep(1000)
	elseif remove_bot_status == "NO" then
		bot:getLog():append(error_message)
		sleep(100)
		if Stop_Script == "YES" then
			error(error_message)
			sleep(1000)
		else
			sleep(1000)
			if statusConnectFunction == "ADDBOTFIRST" then
				addBotFirst()
			elseif statusConnectFunction == "CONNECTBOT" then
				connectBot()
			end
		end
	end
end
---- [ END REMOVE INDEX BOT ] ---


---- [ EXTERNAL FILE ] ---
function externalBotList()
	if Use_External_Bot_List == "YES" then
		Bot_List = {}
		local filename = External_Bot_List_Path
		local file = io.open(filename, "r")
		
		if file then
			for line in file:lines() do
				table.insert(Bot_List, line)
			end
			
			file:close()
		else
			removeBotIndex("NO", "External bot list path not found.")
		end
	end
end

function externalRotationWorld()
	if Use_External_Rotation_World_List == "YES" then
		Rotation_World_List = {}
		local filename = External_Rotation_World_List_Path
		local file = io.open(filename, "r")
		
		if file then
			for line in file:lines() do
				table.insert(Rotation_World_List, line)
			end
			
			file:close()
		else
			removeBotIndex("NO", "External rotation list path not found.")
		end
	end
end

function runExternalFile()
	externalBotList()
	externalRotationWorld()
end

runExternalFile()
---- [ END EXTERNAL FILE ] ----



---- [ SPLIT TABLE (CONFIG INDEX) ] ----
function splitTable(tables, numGroups)
	local result = {}
	local groupSize = math.ceil(#tables / numGroups)
	for i = 1, numGroups do
		local startIdx = (i - 1) * groupSize + 1
		local endIdx = math.min(i * groupSize, #tables)
		local group = {}
		for j = startIdx, endIdx do
			table.insert(group, tables[j])
		end
		table.insert(result, group)
	end
	return result
end

function splitTableWithLimit(botIndex, tables, limit)
	local startIndex = (botIndex - 1) * limit + 1
	local endIndex = math.min(startIndex + limit - 1, #tables)
	local splitTableWithLimit = {}
	for i = startIndex, endIndex do
		local tableIndex = tables[i]
		table.insert(splitTableWithLimit, tableIndex)
	end

	return splitTableWithLimit
end

function splitTableLooping(tables)
	local result = {}
	local tableCount = #tables
	if runningIndex == true then
		for checkRunningIndex, bot in ipairs(getBots()) do
			indexBot = checkRunningIndex - isRunningIndex
			local indexTable = (indexBot - 1) % tableCount + 1
			result[bot.name] = tables[indexTable]
		end
	elseif runningIndex == false then
		for indexBot, bot in ipairs(getBots()) do
			local indexTable = (indexBot - 1) % tableCount + 1
			result[bot.name] = tables[indexTable]
		end
	end
	return result
end

function splitTableLimit(botIndex, tables, limit)
	local index = math.floor((botIndex - 1) / limit) + 1
	return tables[index]
end

function setBotPositions(index, posX, posY, rangeposY)
	for i = 1, #getBots() do
		if i >= index then
			return posX, posY
		else
			if Spread_Rotation_World_List == "NO" then
				if indexRunningScript[1] ~= nil then
					for indexRunning = 1, #getBots() - #indexRunningScript do
						if index == indexRunning then
							posY = posY + rangeposY
							break
						end
					end
				else
					posY = posY + rangeposY
				end
			end
		end
	end
	
	return posX, posY
end

indexRunningScript = { ]] .. table.concat(indexRunningScript, ', ') .. [[ }
if indexRunningScript[1] ~= nil then
	indexUnrunningScript = indexRunningScript[#indexRunningScript] + 1
end
runningIndex = false
bots = {}
for checkRunningIndex, bot in pairs(getBots()) do
	if indexRunningScript[#indexRunningScript] == checkRunningIndex then
		runningIndex = true
		isRunningIndex = checkRunningIndex
		break
	end
end

if runningIndex == true then
	for indexBot, bot in ipairs(getBots()) do
		local index = indexBot - isRunningIndex
		local isUnrunningIndex = #getBots() - isRunningIndex
		local assignedProxyList = splitTableLimit(index, Proxy_List, Proxy_Limit)
		local assignedChangeProxyList = splitTableWithLimit(index, Change_Proxy_List, Proxy_Limit)
		local assignedBotList = splitTable(Bot_List, isUnrunningIndex)[index]
		if Spread_Rotation_World_List == "NO" then
			assignedRotationList = Rotation_World_List
		else
			assignedRotationList = splitTable(Rotation_World_List, isUnrunningIndex)[index]
		end
		local assignedX_Break, assignedY_Break = setBotPositions(index, X_Break, Y_Break, PNB_Range_Helping)
		local assignedCustomWorldForBreakList = splitTable(Custom_World_For_Break_List, isUnrunningIndex)[index]
		local assignedPackToBuyList = splitTableLooping(Pack_To_Buy_List)
		local assignedCookWorldList = splitTableWithLimit(index, Cook_World_List, 1)
		local assignedWebhookLinkBotInformation = splitTableLooping(Webhook_Link_Bot_Information)
		local assignedWebhookLinkDroppedItem = splitTableLooping(Webhook_Link_Dropped_Item)
		local assignedWebhookLinkReconnect = splitTableLooping(Webhook_Link_Reconnect)
		
		bots[bot.name] = {
			Proxy_List = assignedProxyList,
			Change_Proxy_List = assignedChangeProxyList,
			Bot_List = assignedBotList,
			Rotation_World_List = assignedRotationList,
			X_Break = assignedX_Break, 
			Y_Break = assignedY_Break,
			Custom_World_For_Break_List = assignedCustomWorldForBreakList,
			Pack_To_Buy_List = assignedPackToBuyList[bot.name],
			Cook_World_List = assignedCookWorldList,
			Webhook_Link_Bot_Information = assignedWebhookLinkBotInformation[bot.name],
			Webhook_Link_Dropped_Item = assignedWebhookLinkDroppedItem[bot.name],
			Webhook_Link_Reconnect = assignedWebhookLinkReconnect[bot.name]
		}
	end
elseif runningIndex == false then
	for indexBot, bot in ipairs(getBots()) do 
		local index = indexBot
		local isUnrunningIndex = #getBots()
		local assignedProxyList = splitTableLimit(index, Proxy_List, Proxy_Limit)
		local assignedChangeProxyList = splitTableWithLimit(index, Change_Proxy_List, Proxy_Limit)
		local assignedBotList = splitTable(Bot_List, isUnrunningIndex)[index]
		if Spread_Rotation_World_List == "NO" then
			assignedRotationList = Rotation_World_List
		else
			assignedRotationList = splitTable(Rotation_World_List, isUnrunningIndex)[index]
		end
		local assignedX_Break, assignedY_Break = setBotPositions(index, X_Break, Y_Break, PNB_Range_Helping)
		local assignedCustomWorldForBreakList = splitTable(Custom_World_For_Break_List, isUnrunningIndex)[index]
		local assignedPackToBuyList = splitTableLooping(Pack_To_Buy_List)
		local assignedCookWorldList = splitTableWithLimit(index, Cook_World_List, 1)
		local assignedWebhookLinkBotInformation = splitTableLooping(Webhook_Link_Bot_Information)
		local assignedWebhookLinkDroppedItem = splitTableLooping(Webhook_Link_Dropped_Item)
		local assignedWebhookLinkReconnect = splitTableLooping(Webhook_Link_Reconnect)
		
		bots[bot.name] = {
			Proxy_List = assignedProxyList,
			Change_Proxy_List = assignedChangeProxyList,
			Bot_List = assignedBotList,
			Rotation_World_List = assignedRotationList,
			X_Break = assignedX_Break, 
			Y_Break = assignedY_Break,
			Custom_World_For_Break_List = assignedCustomWorldForBreakList,
			Pack_To_Buy_List = assignedPackToBuyList[bot.name],
			Cook_World_List = assignedCookWorldList,
			Webhook_Link_Bot_Information = assignedWebhookLinkBotInformation[bot.name],
			Webhook_Link_Dropped_Item = assignedWebhookLinkDroppedItem[bot.name],
			Webhook_Link_Reconnect = assignedWebhookLinkReconnect[bot.name]
		}
	end
end
---- [ END SPLIT TABLE (CONFIG INDEX) ] ----


---- [ DEFINITION OF CONFIG INDEX ] ----
--Change proxy
	Proxy_List = bots[bot.name].Proxy_List
		Proxy_List = { Proxy_List }
	Change_Proxy_List = bots[bot.name].Change_Proxy_List
		if Proxy_List[1] ~= "" then
			for i = #Proxy_List, 1, -1 do
				table.insert(Change_Proxy_List, 1, Proxy_List[i])
			end
		end
		totalChangeProxyList = #Change_Proxy_List
----------------------------------
--Change bot
	Bot_List = bots[bot.name].Bot_List
	for i, botlist in pairs(Bot_List) do
		bot:getLog():append(botlist)
		sleep(100)
	end
----------------------------------
--Rotation setting
	Rotation_World_List = bots[bot.name].Rotation_World_List
	if Spread_Rotation_World_List == "NO" then
		X_Break = bots[bot.name].X_Break
		Y_Break = bots[bot.name].Y_Break
		if Y_Break < 0 or Y_Break > 53 then
			removeBotIndex("NO", "Y break is " .. Y_Break .. ". This indicates that the bot has no area for PNB!")
		end
	end
	Custom_World_For_Break_List = bots[bot.name].Custom_World_For_Break_List
	if Auto_Buy_Pack == "YES" then
		Pack_To_Buy_List = bots[bot.name].Pack_To_Buy_List
	end
----------------------------------
--Auto cook setting
	if Leveling_Status == "COOK" then
		Cook_World_List = bots[bot.name].Cook_World_List
	end
----------------------------------
--Webhook setting
	Webhook_Link_Bot_Information = bots[bot.name].Webhook_Link_Bot_Information
	Webhook_Link_Dropped_Item = bots[bot.name].Webhook_Link_Dropped_Item
	Webhook_Link_Reconnect =  bots[bot.name].Webhook_Link_Reconnect
---- [ END DEFINITION OF CONFIG INDEX ] ----


---- [ EXTRACT TABLE ] ----
function extractBotList()
	Bot_List_Result = {}
	for _, element in ipairs(Bot_List) do
		local parts = {}
		for part in string.gmatch(element, "[^|]+") do
			table.insert(parts, part)
		end
	
		table.insert(Bot_List_Result, {parts[1], parts[2]})
	end
	
	totalBotList = #Bot_List_Result
	if totalBotList == 0 then
		removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a bot list.")
	end
end

function extractRotationWorldList()
	Rotation_World_List_Result = {}
	for _, element in ipairs(Rotation_World_List) do
		local parts = {}
	
		for part in string.gmatch(element, "[^:|]+") do
			table.insert(parts, part)
		end
	
		table.insert(Rotation_World_List_Result, {parts[1], parts[2], parts[3]})
	end
	
	totalRotationWorldList = #Rotation_World_List_Result
	if totalRotationWorldList == 0 then
		removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a rotation world list.")
	end
	
	if Start_Rotation_World_List > totalRotationWorldList then
		Start_Rotation_World_List = 1
	end	
	Rotation_World = Rotation_World_List_Result[Start_Rotation_World_List][1]:upper()
	Rotation_Door_ID = Rotation_World_List_Result[Start_Rotation_World_List][2]:upper()
		if Rotation_Door_ID == "-" then
			Rotation_Door_ID = ""
		end
	Block_ID = tonumber(Rotation_World_List_Result[Start_Rotation_World_List][3])
	Seed_ID = Block_ID + 1
	Mature_Roots_ID = Block_ID + 4
end

function extractSaveSeedWorldList()
	Save_Seed_World_List_Result = {}
	for _, element in ipairs(Save_Seed_World_List) do
		local parts = {}
	
		for part in string.gmatch(element, "[^:|]+") do
			table.insert(parts, part)
		end
	
		table.insert(Save_Seed_World_List_Result, {parts[1], parts[2], parts[3]})
	end
	
	totalSaveSeedWorldList = #Save_Seed_World_List_Result
	if totalSaveSeedWorldList == 0 then
		removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a save seed world list.")
	end
	Save_Seed_World = Save_Seed_World_List_Result[1][1]:upper()
	Save_Seed_Door_ID = Save_Seed_World_List_Result[1][2]:upper()
	if Save_Seed_Door_ID == "-" then
		Save_Seed_Door_ID = ""
	end
	Drop_Seed_Marker = tonumber(Save_Seed_World_List_Result[1][3])
end

function extractSavePackWorldList()
	Save_Pack_World_List_Result = {}
	for _, element in ipairs(Save_Pack_World_List) do
		local parts = {}
	
		for part in string.gmatch(element, "[^:|]+") do
			table.insert(parts, part)
		end
	
		table.insert(Save_Pack_World_List_Result, {parts[1], parts[2], parts[3]})
	end
	
	totalSavePackWorldList = #Save_Pack_World_List_Result
	if totalSavePackWorldList == 0 then
		removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a save pack world list.")
	end
	Save_Pack_World = Save_Pack_World_List_Result[1][1]:upper()
	Save_Pack_Door_ID = Save_Pack_World_List_Result[1][2]:upper()
	if Save_Pack_Door_ID == "-" then
		Save_Pack_Door_ID = ""
	end
	Drop_Pack_Marker = tonumber(Save_Pack_World_List_Result[1][3])
end

function extractEquipmentWorldList()
	Equipment_World_List_Result = {}
	for _, element in ipairs(Save_Pack_World_List) do
		local parts = {}
	
		for part in string.gmatch(element, "[^:|]+") do
			table.insert(parts, part)
		end
	
		table.insert(Equipment_World_List_Result, {parts[1], parts[2], parts[3]})
	end
	
	totalEquipmentWorldList = #Equipment_World_List_Result
	if totalEquipmentWorldList == 0 then
		removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a equipment world list.")
	end
	Equipment_World = Equipment_World_List_Result[1][1]:upper()
	Equipment_Door_ID = Equipment_World_List_Result[1][2]:upper()
	if Equipment_Door_ID == "-" then
		Equipment_Door_ID = ""
	end
	Drop_Equipment_Marker = tonumber(Equipment_World_List_Result[1][3])
end

function extractWhitelistWorldList()
	Whitelist_World_List_Result = {}
	for _, element in ipairs(Save_Pack_World_List) do
		local parts = {}
	
		for part in string.gmatch(element, "[^:|]+") do
			table.insert(parts, part)
		end
	
		table.insert(Whitelist_World_List_Result, {parts[1], parts[2], parts[3]})
	end
	
	totalWhitelistWorldList = #Whitelist_World_List_Result
	if totalWhitelistWorldList == 0 then
		removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a whitelist world list.")
	end
	Whitelist_World = Whitelist_World_List_Result[1][1]:upper()
	Whitelist_Door_ID = Whitelist_World_List_Result[1][2]:upper()
	if Whitelist_Door_ID == "-" then
		Whitelist_Door_ID = ""
	end
	Drop_Whitelist_Marker = tonumber(Whitelist_World_List_Result[1][3])
end

function extractCookWorld()
	if Leveling_Status == "COOK" then
		Cook_World_List_Result = {}
		for _, element in ipairs(Cook_World_List) do
			local parts = {}
		
			for part in string.gmatch(element, "[^:|]+") do
				table.insert(parts, part)
			end
		
			table.insert(Cook_World_List_Result, {parts[1], parts[2], parts[3], parts[4]})
		end
		
		totalCookWorldList = #Cook_World_List_Result
		if totalCookWorldList == 0 then
			removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a cook world list.")
		end
		Cook_World = Cook_World_List_Result[1][1]:upper()
		Cook_Door_ID = Cook_World_List_Result[1][2]:upper()
		if Cook_Door_ID == "-" then
			Cook_Door_ID = ""
		end
		X_Cook = tonumber(Cook_World_List_Result[1][3])
		Y_Cook = tonumber(Cook_World_List_Result[1][4])
	else
		Cook_World = ""
		Cook_Door_ID = ""
		X_Cook = 0
		Y_Cook = 0
	end
end

function extractCustomWorldForBreakList()
	if Use_Custom_World_For_Break == "YES" then
		Custom_World_For_Break_List_Result = {}
		for _, element in ipairs(Custom_World_For_Break_List) do
			local parts = {}
		
			for part in string.gmatch(element, "[^:|]+") do
				table.insert(parts, part)
			end
		
			table.insert(Custom_World_For_Break_List_Result, {parts[1], parts[2]})
		end
		
		totalCustomWorldForBreakList = #Custom_World_For_Break_List_Result
		if totalCustomWorldForBreakList == 0 then
			removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a custom world for break list.")
		end
		Custom_World_Break_Other_World = Custom_World_For_Break_List_Result[1][1]:upper()
		Custom_World_Break_Other_World_Door_ID = Custom_World_For_Break_List_Result[1][2]:upper()
			if Custom_World_Break_Other_World_Door_ID == "-" then
				Custom_World_Break_Other_World_Door_ID = ""
			end
	else
		Custom_World_Break_Other_World = ""
		Custom_World_Break_Other_World_Door_ID = ""
	end
end

function extractPackToBuy()
	if Auto_Buy_Pack == "YES" then
		Pack_To_Buy_List_Result = {}
		for part in string.gmatch(Pack_To_Buy_List, "[^:|]+") do
			table.insert(Pack_To_Buy_List_Result, part)
		end
		
		totalPackToBuy = #Pack_To_Buy_List_Result
		if totalPackToBuy == 0 then
			removeBotIndex("NO", "Index bot " .. bot.index .. " does not have a pack to buy list.")
		end
		Pack_Name_To_Buy = Pack_To_Buy_List_Result[1]
		Pack_Price = tonumber(Pack_To_Buy_List_Result[2])
		Pack_ID = {}
		for packID in Pack_To_Buy_List_Result[3]:gmatch("%d+") do
			table.insert(Pack_ID, tonumber(packID))
		end
	else
		Pack_Name_To_Buy = ""
		Pack_Price = 999999999999
		Pack_ID = { 0 }
	end
end

function extractWebhookBot()
	if Use_Webhook == "YES" then
		Webhook_Bot_Information_Result = {}
		for part in string.gmatch(Webhook_Link_Bot_Information, "[^|]+") do
			table.insert(Webhook_Bot_Information_Result, part)
		end

		Webhook_Link_Bot_Information = Webhook_Bot_Information_Result[1]
		Message_ID_Bot_Information = tonumber(Webhook_Bot_Information_Result[2])
	else
		Webhook_Link_Bot_Information = ""
		Message_ID_Bot_Information = ""
	end
end

function extractWebhookDropped()
	if Use_Webhook == "YES" then
		Webhook_Dropped_Item_Result = {}
		for part in string.gmatch(Webhook_Link_Dropped_Item, "[^|]+") do
			table.insert(Webhook_Dropped_Item_Result, part)
		end

		Webhook_Link_Dropped_Item = Webhook_Dropped_Item_Result[1]
		Message_ID_Dropped_Item = tonumber(Webhook_Dropped_Item_Result[2])
	else
		Webhook_Link_Dropped_Item = ""
		Message_ID_Dropped_Item = ""
	end
end

function extractWebhookReconnect()
	if Use_Webhook == "YES" then
		Webhook_Reconnect_Result = {}
		for part in string.gmatch(Webhook_Link_Reconnect, "[^|]+") do
			table.insert(Webhook_Reconnect_Result, part)
		end

		Webhook_Link_Reconnect = Webhook_Reconnect_Result[1]
		Message_ID_Reconnect = tonumber(Webhook_Reconnect_Result[2])
	else
		Webhook_Link_Reconnect = ""
		Message_ID_Reconnect = ""
	end
end

function runExtractTable()
	extractBotList()
	extractRotationWorldList()
	extractSaveSeedWorldList()
	extractSavePackWorldList()
	extractEquipmentWorldList()
	extractWhitelistWorldList()
	extractCookWorld()
	extractCustomWorldForBreakList()
	extractPackToBuy()
	extractWebhookBot()
	extractWebhookDropped()
	extractWebhookReconnect()
end

runExtractTable()
---- [ END EXTRACT TABLE ] ----


---- [ GET ITEM NAME ] ----
function getItemName(itemID)
	return getInfo(itemID).name
end
---- [ END GET ITEM NAME ] ----


---- [ TIME HELPER ] ----
--Time variable
	menit = 0
	detik = 0
	tahminibitisdakika = 0
	tahminibitissaat = 0
	sonsaaat = 0
	sondakika = 0
	checkYear = (os.date "%Y")
	checkDay = (os.date "%d")
	checkMonth = (os.date "%m")
	checkHour = (os.date "%H")
	checkMinute = (os.date "%M")
	checkSecond = (os.date "%S")
	checkYear_2 = (os.date "%Y")
	checkDay_2 = (os.date "%d")
	checkMonth_2 = (os.date "%m")
	checkHour_2 = (os.date "%H")
	checkMinute_2 = (os.date "%M")
	checkSecond_2 = (os.date "%S")
	kalanzamansaniye6 = 0
---- [ END TIME HELPER ] ----


---- [ GET TIME ] ----
function timeStart()
	jobScan()
	checkYear = (os.date "%Y")
	checkDay = (os.date "%d")
	checkMonth = (os.date "%m")
	checkHour = (os.date "%H")
	checkMinute = (os.date "%M")
	checkSecond = (os.date "%S")
	anadakika = readyTreeScan() * 0.06
	dakikayabolme = anadakika / 60
	saat = math.floor(dakikayabolme)
	dakika = (dakikayabolme - saat) * 60
	tahminibitisdakika = saat
	tahminibitissaat = math.floor(dakika + 4)
end

function timeEnd()
	checkYear_1 = (os.date "%Y")
	checkDay_1 = (os.date "%d")
	checkMonth_1 = (os.date "%m")
	checkHour_1 = (os.date "%H")
	checkMinute_1 = (os.date "%M")
	checkSecond_1 = (os.date "%S")
	ilkzaman = os.time {year = checkYear, month = checkMonth, day = checkDay, hour = checkHour, min = checkMinute, sec = checkSecond}
	sonzaman = os.time {year = checkYear_1, month = checkMonth_1, day = checkDay_1, hour = checkHour_1, min = checkMinute_1, sec = checkSecond_1}
	kalanzamansaniye = sonzaman - ilkzaman
	adimadimtarih = (kalanzamansaniye / 60) / 60
	sonsaaat = math.floor(adimadimtarih)
	sondakika = math.floor((adimadimtarih - sonsaaat) * 60)
end

function timeR()
	checkYear_2 = (os.date "%Y")
	checkDay_2 = (os.date "%d")
	checkMonth_2 = (os.date "%m")
	checkHour_2 = (os.date "%H")
	checkMinute_2 = (os.date "%M")
	checkSecond_2 = (os.date "%S")
end

function timeRS()
	checkYear_3 = (os.date "%Y")
	checkDay_3 = (os.date "%d")
	checkMonth_3 = (os.date "%m")
	checkHour_3 = (os.date "%H")
	checkMinute_3 = (os.date "%M")
	checkSecond_3 = (os.date "%S")
	ilkzaman = os.time {year = checkYear_2, month = checkMonth_2, day = checkDay_2, hour = checkHour_2, min = checkMinute_2, sec = checkSecond_2}
	sonzaman = os.time {year = checkYear_3, month = checkMonth_3, day = checkDay_3, hour = checkHour_3, min = checkMinute_3, sec = checkSecond_3}
	kalanzamansaniye6 = sonzaman - ilkzaman
	adimadimtarih = (kalanzamansaniye6 / 3600)
	jam = math.floor(adimadimtarih)
	menit = math.floor((adimadimtarih - jam) * 60)
	detik = math.floor((kalanzamansaniye6 - jam * 3600 - menit * 60))
end

function secondON(seconds)
	local seconds = tonumber(seconds)
	
	if seconds <= 0 then
		return "00:00:00";
	else
		hours = string.format("%02.f", math.floor(seconds / 3600));
		mins = string.format("%02.f", math.floor(seconds / 60 - (hours * 60)));
		secs = string.format("%02.f", math.floor(seconds - hours * 3600 - mins * 60));
		return hours .. ":" .. mins .. ":" .. secs
	end
end

function secondR(seconds)
	local seconds = tonumber(seconds)
	
	if seconds <= 0 then
		return "00:00";
	else
		hours = string.format("%02.f", math.floor(seconds / 3600));
		mins = string.format("%02.f", math.floor(seconds / 60 - (hours * 60)));
		secs = string.format("%02.f", math.floor(seconds - hours * 3600 - mins * 60));
		return mins .. ":" .. secs
	end
end

function convertMillisecondsToHours(ms)
    local totalSeconds = math.floor(ms / 1000)

    hours = string.format("%02.f", math.floor(totalSeconds / 3600))
    mins = string.format("%02.f", math.floor((totalSeconds / 60) % 60))
    secs = string.format("%02.f", math.floor(totalSeconds % 60))
    return hours .. ":" .. mins .. ":" .. secs
end
---- [ END GET TIME ] ----


---- [ CHANGE PROXY ] ----
function proxyPlayTime()
	local proxyTimeShow = os.time() - proxyTime
	
	if Change_Proxy == "YES" and Change_Proxy_On_Proxy_Playtime == "YES" then
		if secondON(proxyTimeShow) <= convertMillisecondsToHours(Proxy_Playtime_Milliseconds) then
			return
		else
			totalChangeProxyList = #Change_Proxy_List
			if totalChangeProxyList > 1 then
				autoRecon = false
				bot:disconnect()
				sleep(100)
				webhookShareInfoAllBot()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** The proxy playtime has exceeded the limit."
				)
				if Change_Proxy == "YES" then
					local proxyMatch = bot:getProxy().ip .. ":" .. bot:getProxy().port .. ":" .. bot:getProxy().username .. ":" .. bot:getProxy().password
					if proxyMatch == Change_Proxy_List[proxyStartNumber] then
						table.remove(Change_Proxy_List, proxyStartNumber)
						totalChangeProxyList = #Change_Proxy_List
						proxyStartNumber = proxyStartNumber - 1
					end
					changeProxyList()
				elseif Change_Proxy == "NO" then
					noStopScript = false
					removeBotIndex(Remove_Bot, "Failed to change the proxy because the feature was disabled.")
				end
			elseif totalChangeProxyList == 1 then
				Change_Proxy_On_Proxy_Playtime = "NO"
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Change proxy on proxy playtime is disabled, because the number of proxy on the change proxy list is " .. totalChangeProxyList .. "."
				)
			end
		end
	elseif Change_Proxy == "NO" and Change_Proxy_On_Proxy_Playtime == "NO" then
		return
	end
end

function changeProxyList()
	if totalChangeProxyList == 0 and noStopScript == true then
		autoRecon = false
		noStopScript = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"<a:toa:997296837352505415> **|** Your proxy total in the proxy list is " .. totalChangeProxyList .. ", so the script at this index will stop running."
		)
		removeBotIndex(Remove_Bot, "Your proxy total in the proxy list is " .. totalChangeProxyList .. ", so the script at this index will stop running.")
	end
	
	if noStopScript == true then
		proxyStartNumber = proxyStartNumber + 1
		if proxyStartNumber > totalChangeProxyList then
			proxyStartNumber = 1
		end
		
		bot:updateProxy(Change_Proxy_List[proxyStartNumber])
		sleep(100)
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"<a:toa:997296837352505415> **|**  Your proxy was updated successfully."
		)
		connectAfterChangeProxy()
	end
end

function connectAfterChangeProxy()
	if bot.status ~= BotStatus.online then
		maxReconnect()
		webhookShareInfoBot(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
		)
		bot:connect()
		--addEvent(Event.variantlist, tutorialQuestEvent)
		--listenEvents(Reconnect_Delay_Cooldown_Seconds)
		sleep(Reconnect_Delay)
	end
	
	while bot.status ~= BotStatus.online and noStopScript == true do
		maxReconnect()
		webhookShareInfoBot(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
		)
		bot:connect()
		--addEvent(Event.variantlist, tutorialQuestEvent)
		--listenEvents(Reconnect_Delay_Cooldown_Seconds)
		sleep(Reconnect_Delay)
	end
	connectCount = 0
	changingSubserver()
	
	proxyTime = os.time()
	proxyTimeShow = os.time() - proxyTime
	timeR()
	timeRS()
	
	main()
end
---- [ END CHANGE PROXY ] ----


---- [ WEBHOOK TIME ] ----
function webhookDate()
	local Time_Difference_Webhook = GMT_Time_Zone * 3600
	local Current_Time_GMT = os.time(os.date("!*t"))
	local Current_Time_Webhook = Current_Time_GMT + Time_Difference_Webhook
	return os.date("%A, %B %d, %Y | %H:%M", Current_Time_Webhook)
end
---- [ END WEBHOOK TIME ] ----


---- [ STATUS ] ----
function activeAndNonActiveStatus()
	if bot.status == BotStatus.online then
		return "Online"
	else
		return "Offline"
	end
end

function statusBotDescription()
	if bot.status == BotStatus.online and string.find(world.name:upper(), bot.name:upper()) and bot.level < 2 then
		return "Skip Tutorial"
	elseif bot.status == BotStatus.offline then
		return "Offline"
	elseif bot.status == BotStatus.online then
		return "Online"
	elseif bot.status == BotStatus.wrong_password then
		return "Wrong Password"
	elseif bot.status == BotStatus.account_banned then
		return "Account Banned"
	elseif bot.status == BotStatus.location_banned then
		return "Location Banned"
	elseif bot.status == BotStatus.version_update then
		return "Version Update"
	elseif bot.status == BotStatus.advanced_account_protection then
		return "Advanced Account Protection"
	elseif bot.status == BotStatus.server_overload then
		return "Server Overload"
	elseif bot.status == BotStatus.too_many_login then
		return "Too Many Login"
	elseif bot.status == BotStatus.maintenance then
		return "Maintenance"
	elseif bot.status == BotStatus.http_block then
		return "Http Block"
	elseif bot.status == BotStatus.error_connecting then
		return "Error Connecting"
	elseif bot.status == BotStatus.captcha_requested then
		return "Captcha Requested"
	elseif bot.status == BotStatus.mod_entered then
		return "Mod Entered"
	elseif bot.status == BotStatus.changing_subserver then
		return "Changing Subserver"
	else
		return "nil"
	end
end

function allBotStatus(variable)
	if variable.status == BotStatus.online and string.find(world.name:upper(), variable.name:upper()) and variable.level < 2 then
		return "Skip Tutorial"
	elseif variable.status == BotStatus.online and variable:isInWorld(Save_Pack_World) and dropPackStatus == true then
		return "Dropping Pack"
	elseif variable.status == BotStatus.online and variable:isInWorld(Whitelist_World) and dropWhitelistStatus == true then
		return "Dropping Item Whitelist"
	elseif variable.status == BotStatus.online and variable:isInWorld(Save_Seed_World) and dropSeedBlockStatus == true then
		return "Dropping Seed or Block"
	elseif variable.status == BotStatus.online and variable:isInWorld(Pickaxe_World) and dropPickaxeStatus == true then
		return "Dropping " .. getItemName(Pickaxe_ID)
	elseif variable.status == BotStatus.online and variable:isInWorld(Pickaxe_World) and takingPickaxeStatus == true then
		return "Taking " .. getItemName(Pickaxe_ID)
	elseif variable.status == BotStatus.online and variable:isInWorld(Cook_World) and Start_Cooking == true then
		return "Is Cooking"
	elseif variable.status == BotStatus.offline then
		return "Offline"
    elseif variable.status == BotStatus.online then
		return "Online"
	elseif variable.status == BotStatus.wrong_password then
		return "Wrong Password"
	elseif variable.status == BotStatus.account_banned then
		return "Account Banned"
	elseif variable.status == BotStatus.location_banned then
		return "Location Banned"
	elseif variable.status == BotStatus.version_update then
		return "Version Update"
	elseif variable.status == BotStatus.advanced_account_protection then
		return "Advanced Account Protection"
	elseif variable.status == BotStatus.server_overload then
		return "Server Overload"
	elseif variable.status == BotStatus.too_many_login then
		return "Too Many Login"
	elseif variable.status == BotStatus.maintenance then
		return "Maintenance"
	elseif variable.status == BotStatus.http_block then
		return "Http Block"
	elseif variable.status == BotStatus.error_connecting then
		return "Error Connecting"
	elseif variable.status == BotStatus.captcha_requested then
		return "Captcha Requested"
	elseif variable.status == BotStatus.mod_entered then
		return "Mod Entered"
	elseif variable.status == BotStatus.changing_subserver then
		return "Changing Subserver"
	else
		return "nil"
	end
end
---- [ END STATUS ] ----


---- [ WEBHOOK HELPING ] ----
for _, packlist in pairs(Pack_ID) do
	table.insert(dropPackCountTable, " \n" .. getItemName(packlist) .. ": 0")
	sleep(100)
end

function checkDropPackCount2()
	dropPackCount2 = ""
	for number, packlist in pairs(dropPackCountTable) do
		dropPackCount2 = dropPackCount2 .. packlist .. " [" .. inventory:getItemCount(Pack_ID[number]) .. "] "
		sleep(100)
	end
end
---- [ END WEBHOOK HELPING ] ----


---- [ WEBHOOK ] ----
function webhookShareInfoBot(message1, message2)
	if Use_Webhook == "YES" then
		local wh = Webhook.new(Webhook_Link_Bot_Information)
		wh.username = "Grow King Scripts"
		wh.avatar_url = webhookAvatar
		wh.embed1.use = true
		wh.embed1.image = webhookImage
		wh.embed1.title = webhookTitle
		wh.embed1.description = message1 .. " \n\n" .. reportCenter
		wh.embed1.color = 15105570
		wh.embed1.footer.text = scriptName .. " \n" .. webhookDate()
		
		if useEmbed2 then
			wh.embed2.use = true
			wh.embed2.image = webhookImage
			wh.embed2.title = webhookTitle
			wh.embed2.description = message2 .. " \n\n" .. reportCenter
			wh.embed2.color = 15105570
			wh.embed2.footer.text = scriptName .. " \n" .. webhookDate()
			useEmbed2 = false
		end
		if Edit_Webhook_Message == "YES" then
			wh:edit(Message_ID_Bot_Information)
		else
			wh:send()
		end
	elseif Use_Webhook == "NO" then
		return
	end
end

lastActionTimeAllBotInformationCooldown = os.time() - All_Bot_Information_Cooldown
function webhookShareInfoAllBot()
	if Use_Webhook_For_All_Bot_Information == "YES" then
		local currentTime = os.time()
		local allBotInformationCooldown = All_Bot_Information_Cooldown
		botTimeShow = os.time() - botTime

		if currentTime - lastActionTimeAllBotInformationCooldown >= allBotInformationCooldown then
			lastActionTimeAllBotInformationCooldown = currentTime
			local wh = Webhook.new(Webhook_Link_All_Bot_Information)
			wh.username = "Grow King Scripts"
			wh.avatar_url = webhookAvatar
			wh.embed1.use = true
			wh.embed1.image = webhookImage
			wh.embed1.title = webhookTitle
			wh.embed1.color = 15105570
			for _, allBot in pairs(getBots()) do
				local status = allBotStatus(allBot)
				local description = "<:Status:1190695183440945182> [" .. status .. "] \n" ..
					"<:Purple_Gem:1190695162549108876> [" .. allBot.gem_count .. "] \n" .. 
					"<:Level:1190699579230916650> [" .. allBot.level .. "] \n" .. 
					"<:Laser_Grid:1190695132236894258> [" .. allBot:getInventory():getItemCount(Block_ID) .. "] \n" ..
					"<:Laser_Grid_Seed:1190695138947760249> [" .. allBot:getInventory():getItemCount(Seed_ID) .. "] \n" ..
					"<:Globe:1190695520210006036> [" .. allBot:getWorld().name:upper() .. "] \n" ..
					"<:Luxurious_Wall_Clock:1190695156333150258> [" .. secondON(botTimeShow) .. "]"

				wh.embed1:addField("***" .. allBot.name:upper() .. "***", description, true)
			end
			
			wh.embed1.footer.text = scriptName .. " \nMessage Delivery Cooldown " .. convertMillisecondsToHours(All_Bot_Information_Cooldown_Milliseconds) .. " \n" .. webhookDate()
			if Edit_Webhook_Message_For_All_Bot_Information == "YES" then
				wh:edit(Message_ID_All_Bot_Information)
			else
				wh:send()
			end
		else
			return
		end
	elseif Use_Webhook_For_All_Bot_Information == "NO" then
		return
	end
end

function webhookShareInfoDropped(message)
	if Use_Webhook == "YES" then
		local wh = Webhook.new(Webhook_Link_Dropped_Item)
		wh.username = "Grow King Scripts"
		wh.avatar_url = webhookAvatar
		wh.embed1.use = true
		wh.embed1.image = webhookImage
		wh.embed1.title = webhookTitle
		wh.embed1.description = message .. " \n\n" .. reportCenter
		wh.embed1.color = 15105570
		wh.embed1.footer.text = scriptName  .. " \n" .. webhookDate()
		if Edit_Webhook_Message == "YES" then
			wh:edit(Message_ID_Dropped_Item)
		else
			wh:send()
		end
	elseif Use_Webhook == "NO" then
		return
	end
end

function webhookShareInfoReconnect(message)
	if Use_Webhook == "YES" then
		local wh = Webhook.new(Webhook_Link_Reconnect)
		wh.username = "Grow King Scripts"
		wh.avatar_url = webhookAvatar
		wh.content = "@everyone"
		wh.embed1.use = true
		wh.embed1.image = webhookImage
		wh.embed1.title = webhookTitle
		wh.embed1.description = message .. " \n\n" .. reportCenter
		wh.embed1.color = 15105570
		wh.embed1.footer.text = scriptName .. " \n" .. webhookDate()
		if Edit_Webhook_Message == "YES" then
			wh:edit(Message_ID_Reconnect)
		else
			wh:send()
		end
	elseif Use_Webhook == "NO" then
		return
	end
end

function webhookShareInfoAds(message)
	if Use_Webhook == "YES" then
		local wh = Webhook.new(Webhook_Link_Bot_Information)
		wh.username = "Grow King Scripts"
		wh.avatar_url = webhookAvatar
		wh.embed1.use = true
		wh.embed1.image = webhookImage
		wh.embed1.title = "[ ADVERTISEMENT ]"
		wh.embed1.description = message .. " \n\n" .. reportCenter
		wh.embed1.color = 15105570
		wh.embed1.footer.text = scriptName .. " \n" .. webhookDate()
		if Edit_Webhook_Message == "YES" then
			return
		else
			wh:send()
		end
	elseif Use_Webhook == "NO" then
		return
	end
end
---- [ END WEBHOOK ] ----


---- [ LOG FILE ] ----
function newGuestLogFile(MAC, Description)
    local filename = string.format("%s.txt", newGuestFile)
	local newData = "MAC: " .. MAC .. " | Description: " .. Description .. "\n"
    
	local file = io.open(filename, "r")
    local fileContent = ""

    if file then
        fileContent = file:read("*a")
        file:close()
    end

   if not string.find(fileContent, newData, 1, true) then
        file = io.open(filename, "w")
        if file then
            file:write(newData)
            file:write(fileContent) 
            file:close()
        end
    end
end

function removeBotLogFile(GrowID, Description)
    local filename = string.format("%s.txt", removeBotFile)
	local newData
	if Bot_Format == "CID" then
		newData = "Bot Name: " .. GrowID .. " [" .. Bot_Format .. "]\nDescription: " .. Description .. "\n\n"
	elseif Bot_Format == "GUEST" then
		newData = "MAC: " .. bot:getLogin().mac .. " [" .. Bot_Format .. "]\nDescription: " .. Description .. "\n\n"
	elseif Bot_Format == "UBI" then
		newData = "Email: " .. Bot_List_Result[botStartNumber][1] .. " [" .. Bot_Format .. "]\nDescription: " .. Description .. "\n\n"
    end
	
    local file = io.open(filename, "r")
    local fileContent = ""

    if file then
        fileContent = file:read("*a")
        file:close()
    end

   if not string.find(fileContent, newData, 1, true) then
        file = io.open(filename, "w")
        if file then
            file:write(newData)
            file:write(fileContent)
            file:close()
        end
    end
end

function randomBreakOtherWorldLogFile(lockedBy, newRandomBreakOtherWorld)
	local filename = string.format("%s.txt", randomBreakOtherWorldFile)
	local newData
	if Bot_Format == "CID" then
		newData = "Bot Name: " .. lockedBy .. " [" .. Bot_Format .. "]\nBreak World Name: " .. newRandomBreakOtherWorld .. "\n\n"
	elseif Bot_Format == "GUEST" then
		newData = "MAC: " .. bot:getLogin().mac .. " [" .. Bot_Format .. "]\nBreak World Name: " .. newRandomBreakOtherWorld .. "\n\n"
	elseif Bot_Format == "UBI" then
		newData = "Email: " .. Bot_List_Result[botStartNumber][1] .. " [" .. Bot_Format .. "]\nBreak World Name: " .. newRandomBreakOtherWorld .. "\n\n"
    end
    
	local file = io.open(filename, "r")
    local fileContent = ""

    if file then
        fileContent = file:read("*a")
        file:close()
    end

   if not string.find(fileContent, newData, 1, true) then
        file = io.open(filename, "w")
        if file then
            file:write(newData)
            file:write(fileContent)
            file:close()
        end
    end
end
---- [ END LOG FILE ] ----


---- [ RANDOM SKIN COLOR ] ----
function generateRandomNumberSkinColor()
    local characters = "123456"
    local randomIndex = math.random(1, #characters)
    return string.sub(characters, randomIndex, randomIndex)
end

function randomSkinColor()
	local color = ""
    for i = 1, 1 do
        color = color .. generateRandomNumberSkinColor()
    end
    bot:setSkin(color)
	sleep(100)
end
---- [ END RANDOM SKIN COLOR ] ----


---- [ RANDOM GROWID, MAC, RID AND WORLD ] ----
function generateRandomCharacter()
    local characters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    local randomIndex = math.random(1, #characters)
    return string.sub(characters, randomIndex, randomIndex)
end

function randomGrowID()
	local growid = ""
    for i = 1, 7 do
        growid = growid .. generateRandomCharacter()
    end
    return growid:upper()
end

function randomMAC()
    local mac = ""
    for i = 1, 12 do
        mac = mac .. generateRandomCharacter()
        if i % 2 == 0 and i < 12 then
            mac = mac .. ":"
        end
    end
    return mac:upper()
end

function randomRID()
    local rid = ""
    for i = 1, 32 do
        rid = rid .. generateRandomCharacter()
    end
    return rid:upper()
end

function randomWorldBreakEvent(varlist, netid)
	if varlist:get(0):getString() == "OnRequestWorldSelectMenu" then
		message = varlist:get(1):getString()
		
		if message:match("add_floater|(%w*GKSPNB%w*)") then
			cachedWorldBreak = message:match("(%w*GKSPNB%w*)"):upper()
			unlistenEvents()
		end
	end
end

function randomWorldBreak()
	local retry = false
	local notHasAccess = false
	
	if Use_Random_World_For_Break == "YES" then
		if cachedWorldBreak == nil and notWorldBanned == true then
			sleep(1000)
			local worldNameHelping = { "WORLD0", "WORLD2", "WORLD3", "WORLD4", "WORLD5", "WORLD6", "WORLD7", "WORLD8", "WORLD9", "WORLD10", 
			"WORLD11", "WORLD13", "WORLD14", "WORLD15", "WORLD16", "WORLD17", "WORLD18", "WORLD19", "WORLD20" }
			local worldNameRandom = worldNameHelping[math.random(#worldNameHelping)]
			local maxJoinWorld = 0
			defaultWorldName = worldNameRandom
			defaultBotX = 0
			defaultBotY = 0
			if not bot:isInWorld() then
				while not bot:isInWorld() and maxJoinWorld < 5 and noStopScript == true do
					reconnect(defaultWorldName, defaultBotX, defaultBotY)
					bot:warp(worldNameRandom)
					sleep(Join_World_Delay)
					maxJoinWorld = maxJoinWorld + 1
					while maxJoinWorld >= 5 do
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
						if not bot:isInWorld(worldNameRandom) and not string.find(world.name:upper(), "GKSPNB") then
							bot:disconnect()
							sleep(100)
							reconnect(defaultWorldName, defaultBotX, defaultBotY)
						end
					end
				end
			end
			
			if bot:isInWorld() then
				if string.find(world.name:upper(), "GKSPNB") and world:hasAccess(bot.x, bot.y) == 0 then
					notHasAccess = true
				else
					bot:sendPacket(3, "action|quit_to_exit")
					addEvent(Event.variantlist, randomWorldBreakEvent)
					listenEvents(5)
				end
			end
		end
			
		if cachedWorldBreak == nil then
			if string.find(world.name:upper(), "GKSPNB") and notHasAccess == false then
				cachedWorldBreak = world.name
			elseif (not string.find(world.name:upper(), "GKSPNB") or notHasAccess == true) then
				local worldBreak = "GKSPNB"
				local worldNameLength = math.random(5, 10)
				for i = 1, worldNameLength do
					worldBreak = worldBreak .. generateRandomCharacter()
				end
				
				local typeWorld = math.random(1, 3)
				if typeWorld == 1 then
					cachedWorldBreak = worldBreak:sub(7) .. worldBreak:sub(1, 6)
				elseif typeWorld == 2 then
					cachedWorldBreak = worldBreak:sub(1, 6) .. worldBreak:sub(7)
				elseif typeWorld == 3 then
					cachedWorldBreak = worldBreak:sub(7, 10) .. worldBreak:sub(1, 6) .. worldBreak:sub(11, #worldBreak)
				end
			end
		end
	elseif Use_Random_World_For_Break == "NO" then
		cachedWorldBreak = ""
	end
	
    return cachedWorldBreak:upper()
end

function randomWorldQuest()
	local retry = false
	local notHasAccess = false
	
	if bot:isInWorld() then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if world:hasAccess(tile.x, tile.y) == 0 then
					notHasAccess = true
					break
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				defaultWorldName = world.name:upper()
				defaultBotX = bot.x
				defaultBotY = bot.y
				
				retry = true
				reconnect(defaultWorldName, defaultBotX, defaultBotY)
				break
			end
		end
	end
	
	if retry then
		randomWorldQuest()
	end
	
	if cachedWorldQuest == nil then
		if string.find(world.name:upper(), bot.name:upper()) and notHasAccess == false then
			cachedWorldQuest = world.name
		elseif string.find(world.name:upper(), "GKSQUEST") and notHasAccess == false then
			cachedWorldQuest = world.name
		elseif not string.find(world.name:upper(), bot.name:upper()) and not string.find(world.name:upper(), "GKSQUEST") then
			local worldQuest = "GKSQUEST"
			local worldNameLength = math.random(5, 10)
			for i = 1, worldNameLength do
				worldQuest = worldQuest .. generateRandomCharacter()
			end

			local typeWorld = math.random(1, 5)
			if typeWorld == 1 then
				cachedWorldQuest = worldQuest:sub(9) .. worldQuest:sub(1, 8)
			elseif typeWorld == 2 then
				cachedWorldQuest = worldQuest:sub(1, 8) .. worldQuest:sub(9)
			elseif typeWorld == 3 then
				cachedWorldQuest = worldQuest:sub(9) .. worldQuest:sub(1, 8) .. worldQuest:sub(10, #worldQuest)
			elseif typeWorld == 4 then
				cachedWorldQuest = worldQuest:sub(9, 10) .. worldQuest:sub(1, 8) .. worldQuest:sub(11, #worldQuest)
			elseif typeWorld == 5 then
				cachedWorldQuest = worldQuest:sub(9, 11) .. worldQuest:sub(1, 8) .. worldQuest:sub(12, #worldQuest)
			end
		end
    end
	
    return cachedWorldQuest:upper()
end
---- [ END RANDOM GROWID, MAC, RID AND WORLD ] ----



---- [ IGNORE GEMS ] ----
function ignoreGemsStatus()
	if Ignore_Gems == "YES" then
		return true
	elseif Ignore_Gems == "NO" then
		return false
	end
end
---- [ END IGNORE GEMS ] ----

---- [ BREAK OTHER WORLD ] ----
function breakOtherWorldStatus()
	if Break_Other_World == "YES" then
		if Use_Custom_World_For_Break == "YES" then
			return Custom_World_Break_Other_World
		elseif Use_Random_World_For_Break == "YES" then
			return randomWorldBreak()
		elseif Use_Tutorial_World_For_Break == "YES" then
			return tutorialWorld
		end
	elseif Break_Other_World == "NO" then
		return Rotation_World
	end
end
---- [ END BREAK OTHER WORLD ] ----


---- [ BAN WAVE ESTIMATED ] ----
function convertServerTimeToLocal(serverTime)
    local serverHour, serverMinute = serverTime:match("(%d+):(%d+)")
    serverHour = tonumber(serverHour)
    serverMinute = tonumber(serverMinute)
    
    serverHour = serverHour + Growtopia_Time_Difference
    if serverHour >= 24 then
        serverHour = serverHour - 24
    end
    
    return string.format("%02d:%02d", serverHour, serverMinute)
end

function banWaveEstimatedWithTime(time)
	local banWaveLocalTimes = {}

	for i = 1, #Ban_Wave_Estimated_Time do
		local localTime = convertServerTimeToLocal(Ban_Wave_Estimated_Time[i])
		table.insert(banWaveLocalTimes, localTime)
	end

    for i = 1, #banWaveLocalTimes do
        local targetTime = banWaveLocalTimes[i]
        local currentTime = os.date("%H:%M")
        local targetHour, targetMinute = targetTime:match("(%d+):(%d+)")
        local currentHour, currentMinute = currentTime:match("(%d+):(%d+)")
		
        targetHour = tonumber(targetHour)
        targetMinute = tonumber(targetMinute)
        currentHour = tonumber(currentHour)
        currentMinute = tonumber(currentMinute)
        
        local timeDifference = (currentHour * 60 + currentMinute) - (targetHour * 60 + targetMinute)
	
        if math.abs(timeDifference) <= 1 then
            return true
        end
    end
    return false
end

function banWaveEstimated()
	if Ban_Wave_Estimated == "YES" then
		if Ban_Wave_Estimated_With_Time == "YES" then
			local currentTime = os.date("%H:%M")
			
			if banWaveEstimatedWithTime(currentTime) then
				dropExceedPackGoOffline()
				
				while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
					seedWorld()
					dropSeed()
					while inventory:getItemCount(Block_ID) > 0 do
						dropBlock()
					end
				end
				
				while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
					pickaxeWorld()
					while not bot:isInTile(44, 13) do
						findpath(44, 13)
					end
					dropItem(Pickaxe_ID)
					if inventory:getItemCount(Pickaxe_ID) == 0 then
						webhookShareInfoDropped(
							"**[ BOT INFORMATION ]** \n" ..
							"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
							":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
							"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
							"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
							"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
							"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
							
							"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
							"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
							":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
							getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
						)
					end
				end
				
				dropEquipmentBeforeOfffline()
				hiddenWorld()
				
				autoRecon = false
				bot:disconnect()
				sleep(100)
				webhookShareInfoAllBot()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is offline during " .. convertMillisecondsToHours(Ban_Wave_Estimated_Cooldown_Milliseconds) .. " to avoid ban."
				)
				sleep(Ban_Wave_Estimated_Cooldown_Milliseconds)
				connectBot()
			else
				return
			end
		end
	elseif Ban_Wave_Estimated == "NO" then
		return
	end
end
---- [ END BAN WAVE ESTIMATED ] ----


---- [ MOD ENTERED ] ----
function modEntered()
	if bot.status == BotStatus.mod_entered then
		if true then
			if bot:isInWorld() and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg ~= 6 then
				bot:respawn()
				sleep(1000)
			end
			bot:setBubble(Bubble.talk)
			sleep(#"OMG! Hello mod prooooo..." * 80)
			bot:say("OMG! Hello mod prooooo...")
			sleep(10)
			bot:setBubble(Bubble.none)
			
			sleep(3000)
			
			bot:setBubble(Bubble.talk)
			sleep(#"Bye I want to go offline. I want to sleep." * 80)
			bot:say("Bye I want to go offline. I want to sleep.")
			sleep(10)
			bot:setBubble(Bubble.none)
			
			sleep(2000)
			
			bot:setBubble(Bubble.talk)
			sleep(#"I love playing this game!" * 80)
			bot:say("I love playing this game!")
			sleep(10)
			bot:setBubble(Bubble.none)
			
			sleep(2000)
			
			bot:setBubble(Bubble.talk)
			sleep(#"/wave" * 80)
			bot:say("/wave")
			sleep(10)
			bot:setBubble(Bubble.none)
			
			sleep(1000)
		end
		
		autoRecon = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is offline during " .. convertMillisecondsToHours(Mod_Entered_Cooldown_Milliseconds) .. " to avoid mod entred."
		)
		sleep(Mod_Entered_Cooldown_Milliseconds)
		connectBot()
	else
		return
	end
end
---- [ END MOD ENTERED ] ----


---- [ EQUIPMENT ] ----
function dropEquipmentBeforeOfffline()
	if bot.status == BotStatus.online then
		if (Auto_Consume == "YES") or (Auto_Fossil == "YES") or (Auto_Kill_Ghost == "YES") or (Anti_Fire == "YES") then
			dropEquipmentToOfffline = {}
			
			for _, value in ipairs(Consume_ID) do
				table.insert(dropEquipmentToOfffline, value)
			end
			
			for _, value in ipairs(fossilFinishEquipment) do
				table.insert(dropEquipmentToOfffline, value)
			end

			for _, value in ipairs(ghostEquipment) do
				table.insert(dropEquipmentToOfffline, value)
			end
			
			for _, value in ipairs(fireEquipment) do
				table.insert(dropEquipmentToOfffline, value)
			end
			
			local canDropCustomItem = false	
			for _, item in pairs(dropEquipmentToOfffline) do
				reconnect(Equipment_World, 1, 23)
				if inventory:getItemCount(item) > 0 then
					reconnect(Equipment_World, 1, 23)
					canDropCustomItem = true
					break
				end
			end
			
			if canDropCustomItem then
				reconnect(Equipment_World, 1, 23)
				equipmentWorld()
				dropEquipment(dropEquipmentToOfffline, 0)
			end
		end
	else
		reconnect(Equipment_World, 1, 23)
		dropEquipmentBeforeOfffline()
	end
end

function findpathEquipment(variable, maxRetrieve)
	reconnect(Equipment_World, 1, 23)
	
	upgradeBackpackForTakeEquipment(variable)

	local haveEquipment = false
	for _, item in pairs(variable) do
		local sendWebhookAmount = 0
		local countDrop = inventory:getItemCount(item) + objectSafeScan(item)
		while inventory:getItemCount(item) < maxRetrieve and countDrop < maxRetrieve do
			if sendWebhookAmount < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** The " .. getItemName(item) .. " in `" .. Equipment_World .. "` has run out or the " .. getItemName(item) .. " is being taken by another bot, " ..
					"so " .. bot.name:upper() .. " is waiting to take it! Please add stock if you feel there is not enough stock."
				)
				sendWebhookAmount = sendWebhookAmount + 1
			end
			
			if not bot:isInWorld(Equipment_World) then
				equipmentWorld()
			end
			reconnect(Equipment_World, 1, 23) 
			sleep(1000)
			countDrop = inventory:getItemCount(item) + objectSafeScan(item)
		end
		haveEquipment = true
	end
	
	if haveEquipment then
		for _, item in pairs(variable) do
			for _, obj in pairs(world:getObjects()) do
				if bot.status == BotStatus.online and obj.id == item then
					if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
						while not bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) do
							sleep(25000)
							reconnect(Equipment_World, 1, 23)
							findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
						end
						takeItem(item)
						break
					elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
						takeItem(item)
						break
					end
				elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
					reconnect(Equipment_World, 1, 23)
				end
			end
		end
		reconnect(Equipment_World, 1, 23)
	end
	
	sleep(500)
	
	local checkEquipmentLast = false
	for _, item in pairs(variable) do
		if inventory:getItemCount(item) < maxRetrieve then
			checkEquipmentLast = true
			break
		end
	end
	
	if checkEquipmentLast then
		findpathEquipment(variable, maxRetrieve)
	end
end
---- [ END EQUIPMENT ] ----


---- [ AUTO FOSSIL ] ----
function fossilEvent(varlist, netid)
	if varlist:get(0):getString() == "OnTalkBubble" then
		message = varlist:get(2):getString()
		if message:match("`2I unearthed a Fossil!`` I better be careful getting it out...") then
			unlistenEvents()
			reconnect(Rotation_World, 1, 23)
			while not inventory:getItem(3934).isActive do
				bot:wear(3934)
				sleep(math.random(Wear_Delay, Wear_Delay + 100))
			end
			while bot:isInWorld() and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).fg == 3918 and inventory:getItem(3934).isActive do
				reconnect(Rotation_World, 1, 23)
				bot:hit(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1)
				sleep(math.random(Hit_Delay, Hit_Delay + 100))
			end
		end
	end
end

function findpathFossil()
	local chosenTile = nil
	
	if bot.status == BotStatus.online then
		for _, tile in pairs(world:getTiles()) do 
			if bot.status == BotStatus.online then
				if tile.fg == 3918 and world:hasAccess(tile.x, tile.y) ~= 0 then
					chosenTile = tile
					break
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, 1, 23)
			end
		end
		
		if chosenTile then
			reconnect(Rotation_World, 1, 23)
			findpath(chosenTile.x, chosenTile.y + 1)
		end
	else
		reconnect(Rotation_World, 1, 23)
		findpathFossil()
	end
end

function takeFossil()
	local hasFossilEquipment = true
	
	if bot.status == BotStatus.online then
		if Auto_Fossil == "YES" and ((Spread_Rotation_World_List == "NO" and bot.index == indexUnrunningScript) or Spread_Rotation_World_List == "YES") and fossilRockScan() > 0 then
			bot.auto_collect = false
			sleep(100)
			
			local takeEquipment = false
			for _, item in pairs(fossilEquipment) do
				if inventory:getItemCount(item) == 0 then
					takeEquipment = true
					break
				end
			end
			
			if takeEquipment then
				equipmentWorld()
				findpathEquipment(fossilEquipment, 1)
				
				if inventory:getItemCount(3932) > 1 or inventory:getItemCount(3934) > 1 then
					while not bot:isInTile(45, 13) do
						findpath(45, 13)
					end
					
					while inventory:getItemCount(3932) > 1 do
						bot:setDirection(false)
						sleep(100)
						bot:drop(3932, inventory:getItemCount(3932) - 1)
						sleep(math.random(Drop_Delay, Drop_Delay + 100))
					end
					
					while inventory:getItemCount(3934) > 1 do
						bot:setDirection(false)
						sleep(100)
						bot:drop(3934, inventory:getItemCount(3934) - 1)
						sleep(math.random(Drop_Delay, Drop_Delay + 100))
					end
				end
				
				hiddenWorld()
				farmWorld()
			end
			
			sleep(500)
			
			if hasFossilEquipment then
				if sendWebhookAmountAutoFossil < 1 then
					webhookShareInfoBot(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Starting Auto Fossil \n\n" ..
						
						"**[ FOSSIL INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** Fossil World: `" .. world.name:upper() .. "` \n" ..
						"<:Fossil_Rock:1190695032001413191> **|** Fossil Rock Amount: " .. fossilRockScan()
					)
					sendWebhookAmountAutoFossil = sendWebhookAmountAutoFossil + 1
				end
				
				bot.auto_collect = false
				sleep(100)
				while not inventory:getItem(3932).isActive do
					reconnect(Rotation_World, 1, 23)
					bot:wear(3932)
					sleep(math.random(Wear_Delay, Wear_Delay + 100))
				end
				
				if bot.auto_collect == false then
					findpathFossil()
				elseif bot.auto_collect ~= false then
					bot.auto_collect = false
					sleep(100)
					findpathFossil()
				end
				
				local maxHit = 0
				while bot.auto_collect == false and bot:isInWorld() and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).fg == 3918 and maxHit < 15 do
					if not inventory:getItem(3932).isActive then
						reconnect(Rotation_World, 1, 23)
						bot:wear(3932)
						sleep(math.random(Wear_Delay, Wear_Delay + 100))
					end
					
					if inventory:getItem(3932).isActive then
						reconnect(Rotation_World, 1, 23)
						bot:hit(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1)
						addEvent(Event.variantlist, fossilEvent)
						listenEvents(2)
						maxHit = maxHit + 1
						if maxHit >= 15 then
							sleep(6000)
							maxHit = 0
						end
					end
				end
				
				sleep(500)
				
				for _, objFossil in pairs(world:getObjects()) do
					if objFossil.id == 3936 then
						bot:place(bot.x, bot.y - 1, 4132)
						sleep(math.random(Place_Delay, Place_Delay + 100))
					end
				end
				
				sleep(500)
				
				for _, objPolishedFossil in pairs(world:getObjects()) do
					if objPolishedFossil.id == 4134 then
						takeItem(4134)
						if inventory:getItemCount(10) > 0 and bot:isInWorld() and ((world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).fg == 0) or (world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).bg == 0) or (world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).bg == 14)) then 
							bot:place(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1, 10)
							sleep(math.random(Place_Delay, Place_Delay + 100))
						elseif inventory:getItemCount(2) > 0 and bot:isInWorld() and ((world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).fg == 0) or (world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).bg == 0) or (world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1).bg == 14)) then 
							bot:place(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1, 2)
							sleep(math.random(Place_Delay, Place_Delay + 100))
						end
					end
				end
				
				sleep(500)
				
				if fossilRockScan() > 0 then
					takeFossil()
				elseif fossilRockScan() == 0 then
					webhookShareInfoBot(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Finished Auto Fossil \n\n" ..
						
						"**[ FOSSIL INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** Fossil World: `" .. world.name:upper() .. "` \n" ..
						"<:Fossil_Rock:1190695032001413191> **|** Fossil Rock Amount: " .. fossilRockScan()
					)
					
					while inventory:getItemCount(Pickaxe_ID) > 0 and not inventory:getItem(Pickaxe_ID).isActive do
						bot:wear(Pickaxe_ID)
						sleep(math.random(Wear_Delay, Wear_Delay + 100))
					end
					
					equipmentWorld()
					dropEquipment(fossilFinishEquipment, 0)
					hiddenWorld()
					farmWorld()
				end
			end
		elseif Auto_Fossil == "NO" then
			return
		end
	else
		reconnect(Rotation_World, 1, 23)
		takeFossil()
	end
end
---- [ END AUTO FOSSIL ] ----


---- [ KILLING GHOST ] ----
function performActionKillingGhost()
	reconnect(Rotation_World, 1, 23)
	for _, npc in pairs(world:getNPCs()) do
		reconnect(Rotation_World, 1, 23)
		local pkt = GameUpdatePacket.new()
		pkt.type = 34
		pkt.count1 = npc.id
		pkt.count2 = 8
		pkt.pos_x = npc.x
		pkt.pos_y = npc.y
		pkt.pos2_x = world:getLocal().posx
		pkt.pos2_y = world:getLocal().posy
		bot:sendRaw(pkt)
		sleep(1000)
	end
	reconnect(Rotation_World, 1, 23)
end

function killingGhost()
	if bot.status == BotStatus.online then
		if Auto_Kill_Ghost == "YES" and ((Spread_Rotation_World_List == "NO" and bot.index == indexUnrunningScript) or Spread_Rotation_World_List == "YES") then
			if ghostScan() > 0 then		
				local takeEquipment = false
				for _, item in pairs(ghostEquipment) do
					if inventory:getItemCount(item) == 0 then
						takeEquipment = true
						break
					end
				end
				
				if takeEquipment then
					equipmentWorld()
					findpathEquipment(ghostEquipment, 1)
					
					for _, item in pairs(ghostEquipment) do
						if inventory:getItemCount(item) > 1 then
							while not bot:isInTile(45, 13) do
								findpath(45, 13)
							end
							
							while inventory:getItemCount(item) > 1 do
								bot:setDirection(false)
								sleep(100)
								bot:drop(item, inventory:getItemCount(item) - 1)
								sleep(math.random(Drop_Delay, Drop_Delay + 100))
							end
						end
					end
					
					hiddenWorld()
					farmWorld()
				end
				
				local hasGhostClothes = true			
				if hasGhostClothes then
					for _, wearing in pairs(ghostEquipment) do
						if inventory:getItemCount(wearing) > 0 and not inventory:getItem(wearing).isActive then
							bot:wear(wearing)
							sleep(math.random(Wear_Delay, Wear_Delay + 100))
						end
					end
				end
				
				if hasGhostClothes then
					reconnect(Rotation_World, 1, 23)
					local sendWebhookAmount = 0
					while ghostScan() > 0 do
						if sendWebhookAmount < 1 then
							webhookShareInfoBot(
								"**[ BOT INFORMATION ]** \n" ..
								"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
								":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
								"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
								"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
								"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
								"<a:toa:997296837352505415> **|** Bot Information: Starting Killing Ghost \n\n" ..
								
								"**[ GHOST INFORMATION ]** \n" ..
								"<:Globe:1190695520210006036> **|** Ghost World: `" .. world.name:upper() .. "` \n" ..
								":ghost: **|** Ghost Amount: " .. ghostScan()
							)
							sendWebhookAmount = sendWebhookAmount + 1
						end
						
						performActionKillingGhost()
						reconnect(Rotation_World, 1, 23)
					end
					
					if ghostScan() == 0 then
						webhookShareInfoBot(
							"**[ BOT INFORMATION ]** \n" ..
							"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
							":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
							"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
							"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n"  ..
							"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
							"<a:toa:997296837352505415> **|** Bot Information: Finished Killing Ghost \n\n" ..
							
							"**[ GHOST INFORMATION ]** \n" ..
							"<:Globe:1190695520210006036> **|** Ghost World: `" .. world.name:upper() .. "` \n" ..
							":ghost: **|** Ghost Amount: " .. ghostScan()
						)
						
						while inventory:getItemCount(Pickaxe_ID) > 0 and not inventory:getItem(Pickaxe_ID).isActive and Auto_Kill_Ghost_Only == "NO" do
							bot:wear(Pickaxe_ID)
							sleep(math.random(Wear_Delay, Wear_Delay + 100))
						end
						
						if Auto_Kill_Ghost_Only == "NO" then
							equipmentWorld()
							dropEquipment(ghostEquipment, 0)
							hiddenWorld()
							farmWorld()
						elseif Auto_Kill_Ghost_Only == "YES" and totalRotationWorldList == 1 then
							equipmentWorld()
							dropEquipment(ghostEquipment, 0)
							hiddenWorld()
							farmWorld()
						end
					end
					reconnect(Rotation_World, 1, 23)
				end
			end
		elseif Auto_Kill_Ghost == "NO" then
			return
		end
	else
		reconnect(Rotation_World, 1, 23)
		killingGhost()
	end
end
---- [ KILLING GHOST ] ----


---- [ WEARING SPECIFIC ITEM ] ----
function wearingSpecificItem()
	if bot.status == BotStatus.online then
		if Wearing_Specific_Item == "YES" then
			local takeEquipment = false
			for _, item in pairs(Wearing_Specific_Item_ID) do
				if inventory:getItemCount(item) == 0 then
					takeEquipment = true
					break
				end
			end
			
			if takeEquipment then
				equipmentWorld()
				findpathEquipment(Wearing_Specific_Item_ID, 1)
				
				for _, item in pairs(Wearing_Specific_Item_ID) do
					if inventory:getItemCount(item) > 1 then
						while not bot:isInTile(45, 13) do
							findpath(45, 12)
						end
						
						while inventory:getItemCount(item) > 1 do
							bot:setDirection(false)
							sleep(100)
							bot:drop(item, inventory:getItemCount(item) - Max_Specific_Item_To_Retrieve)
							sleep(math.random(Drop_Delay, Drop_Delay + 100))
						end
					end
				end
				
				for _, item in pairs(Wearing_Specific_Item_ID) do
					for _, itemActive in pairs(inventory:getItems()) do
						reconnect(Rotation_World, 1, 23)
						if itemActive.id == item then
							if itemActive.isActive then
								reconnect(Rotation_World, 1, 23)
							else
								reconnect(Rotation_World, 1, 23)
								bot:wear(item)
								sleep(math.random(Wear_Delay, Wear_Delay + 100))
							end
							reconnect(Rotation_World, 1, 23)
							break
						end
					end
				end
				
				
				hiddenWorld()
				farmWorld()
			end
		end
	else
		reconnect(Rotation_World, 1, 23)
		wearingSpecificItem()
	end
end
---- [ END WEARING SPECIFIC ITEM ] ----


---- [ AUTO CONSUME ] ----
function takeConsume()
	if bot.status == BotStatus.online then
		local takeConsume = false
		for _, item in pairs(Consume_ID) do
			if inventory:getItemCount(item) == 0 then
				takeEquipment = true
				break
			end
		end
			
		if takeEquipment then
			equipmentWorld()
			findpathEquipment(Consume_ID, 1)
			dropEquipment(Consume_ID, 1)
			
			for _, item in pairs(Consume_ID) do
				if inventory:getItemCount(item) == 1 then
					bot:place(bot.x, bot.y, item)
					sleep(math.random(Place_Delay, Place_Delay + 100))
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** The " .. getItemName(item) .. " is already in use by " .. bot.name:upper() .. "."
					)
				end
			end
		end
	else
		reconnect(Rotation_World, 1, 23)
		takeConsume()
	end
end

function autoConsume()
	if Auto_Consume == "YES" and bot:isInWorld() and getLocal().avatarFlags == 0 then
		if Bot_Level_Rotation == true then
			if bot.level < Min_Level then
				takeConsume()
				hiddenWorld()
				if not bot:isInWorld(Cook_World) and Start_Cooking == true then
					cookWorld()
					findpath(X_Cook, Y_Cook)
				else
					farmWorld()
				end
			elseif bot.level >= Min_Level then
				Bot_Level_Rotation = false
				return
			end
		end
		
		if Only_Consume_Until_Minimum_Level == "YES" and Bot_Level_Rotation == false then
			if bot.level < Min_Level then
				takeConsume()
				hiddenWorld()
				if not bot:isInWorld(Cook_World) and Start_Cooking == true then
					cookWorld()
					findpath(X_Cook, Y_Cook)
				else
					farmWorld()
				end
			elseif bot.level >= Min_Level then
				return
			end
		elseif Only_Consume_At_Specific_Level == "YES" and Bot_Level_Rotation == false then
			if TotalSpecifiedLevelList > 0 then
				local validConsume = nil
				
				for _, specifiedLevel in pairs(Specified_Level) do
					if bot.level > specifiedLevel then
						table.remove(Specified_Level, 1)
						TotalSpecifiedLevelList = #Specified_Level
						validConsume = false
						break
					elseif bot.level == specifiedLevel then
						validConsume = true
						break
					end
				end
				
				if validConsume == true then
					takeConsume()
					hiddenWorld()
					if not bot:isInWorld(Cook_World) and Start_Cooking == true then
						cookWorld()
						findpath(X_Cook, Y_Cook)
					else
						farmWorld()
					end
				elseif validConsume == false then
					autoConsume()
				end
			end
		end
	elseif Auto_Consume == "NO" then
		return
	end
end
---- [ END AUTO CONSUME ] ----


---- [ ANTI FIRE ] ----
function antiFire()
	if Anti_Fire == "YES" and ((Spread_Rotation_World_List == "NO" and bot.index == indexUnrunningScript) or Spread_Rotation_World_List == "YES") then
		if tileGrowScan(fireID) > 0 then
			local takeEquipment = false
			
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "]\n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Starting To Clear The Fire"
			)
	
			for _, item in pairs(fireEquipment) do
				if inventory:getItemCount(item) == 0 then
					takeEquipment = true
					break
				end
			end
			
			if takeEquipment then
				defaultWorldName = world.name:upper()
				defaultBotX = bot.x
				defaultBotY = bot.y
			
				equipmentWorld()
				findpathEquipment(fireEquipment, 1)
				
				if inventory:getItemCount(3066) > 1 then
					while not bot:isInTile(45, 13) do
						findpath(45, 13)
					end
					
					while inventory:getItemCount(3066) > 1 do
						bot:setDirection(false)
						sleep(100)
						bot:drop(3066, inventory:getItemCount(3066) - 1)
						sleep(math.random(Drop_Delay, Drop_Delay + 100))
					end
				end
				
				hiddenWorld()
				if defaultWorldName == Rotation_World then
					reconnect(Rotation_World, defaultBotX, defaultBotY)
					farmWorld()
				elseif ((defaultWorldName == Custom_World_Break_Other_World) or (defaultWorldName == randomWorldBreak())) then
					reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
					breakOtherWorld()
				end
			end
			
			if inventory:getItemCount(3066) > 0 and bot.anti_fire ~= true then
				bot.anti_fire = true
				sleep(100)
			end
			
			while tileGrowScan(fireID) > 0 and bot.anti_fire == true do 
				reconnect(Rotation_World, 1, 23)
				sleep(1000)
			end
		end
		
		if tileGrowScan(fireID) == 0 then
			bot.anti_fire = false
			sleep(100)
			if inventory:getItemCount(3066) > 0 then
				webhookShareInfoBot(
					"**[ BOT INFORMATION ]** \n" ..
					"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
					":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "]\n" ..
					"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
					"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
					"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
					"<a:toa:997296837352505415> **|** Bot Information: Finished To Clear The Fire"
				)
				
				defaultWorldName = world.name:upper()
				defaultBotX = bot.x
				defaultBotY = bot.y
				
				equipmentWorld()
				dropEquipment(fireEquipment, 0)
				hiddenWorld()
				if defaultWorldName == Rotation_World then
					reconnect(Rotation_World, defaultBotX, defaultBotY)
					farmWorld()
				elseif ((defaultWorldName == Custom_World_Break_Other_World) or (defaultWorldName == randomWorldBreak())) then
					reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
					breakOtherWorld()
				end
			end
		end
	elseif Anti_Fire == "NO" then
		bot.anti_fire = false
		sleep(100)
		return
	end
end
---- [ END ANTI FIRE ] ----


---- [ ANTI TOXIC ] ----
function antiToxic()
	if Anti_Toxic == "YES" and ((Spread_Rotation_World_List == "NO" and bot.index == indexUnrunningScript) or Spread_Rotation_World_List == "YES") then
		if tileSafeScan(778) > 0 then
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "]\n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Starting Auto Toxic"
			)
			if bot.anti_toxic ~= true then
				bot.anti_toxic = true
				sleep(100)
			end
			
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			while tileSafeScan(778) > 0 and bot.anti_toxic == true do
				reconnect(defaultWorldName, defaultBotX, defaultBotY)
				sleep(1000)
			end
			
			if tileSafeScan(778) == 0 then
				webhookShareInfoBot(
					"**[ BOT INFORMATION ]** \n" ..
					"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
					":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "]\n" ..
					"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
					"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
					"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
					"<a:toa:997296837352505415> **|** Bot Information: Finished Auto Toxic"
				)
			end
		end
	elseif Anti_Toxic == "NO" then
		bot.anti_toxic = false
		sleep(100)
		return
	end
end
---- [ END ANTI TOXIC ] ----


---- [ BOT PLAYTIME ] ----
function botPlayTime()
	local botTimeShow = os.time() - botTime
	
	if Change_Bot_On_Bot_Playtime == "YES" then
		if secondON(botTimeShow) <= convertMillisecondsToHours(Bot_Playtime_Milliseconds) then
			return
		else
			totalBotList = #Bot_List_Result
			if totalBotList > 1 then
				dropExceedPackGoOffline()
				
				while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
					seedWorld()
					dropSeed()
					while inventory:getItemCount(Block_ID) > 0 do
						dropBlock()
					end
				end
				
				while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
					pickaxeWorld()
					while not bot:isInTile(44, 13) do
						findpath(44, 13)
					end
					dropItem(Pickaxe_ID)
					if inventory:getItemCount(Pickaxe_ID) == 0 then	
						webhookShareInfoDropped(
							"**[ BOT INFORMATION ]** \n" ..
							"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
							":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
							"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
							"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
							"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
							"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
							
							"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
							"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
							":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
							getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
						)
					end
				end
				
				dropEquipmentBeforeOfffline()
				hiddenWorld()
				
				autoRecon = false
				bot:disconnect()
				sleep(100)
				webhookShareInfoAllBot()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " playtime has exceeded the limit."
				)
				if Change_Bot == "YES" then
					local currentBot = table.remove(Bot_List_Result, botStartNumber)
					table.insert(Bot_List_Result, currentBot)
					botStartNumber = 0
					changeBotStatus()
				elseif Change_Bot == "NO" then
					noStopScript = false
					removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
				end
			elseif totalBotList == 1 then
				Change_Bot_On_Bot_Playtime = "NO"
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Change bot on bot playtime is disabled, because the number of bot on the bot list is " .. totalBotList .. "."
				)
			end
		end
	elseif Change_Bot_On_Bot_Playtime == "NO" then
		return
	end
end

function matchStatusConnect()
	if bot.status ~= BotStatus.online and bot.status == BotStatus.offline then
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.wrong_password then
		autoRecon = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		removeBotLogFile(bot.name:upper(), statusBotDescription())
		if Change_Bot == "YES" then
			if totalBotList > 1 then
				table.remove(Bot_List_Result, botStartNumber)
				totalBotList = #Bot_List_Result
				botStartNumber = botStartNumber - 1
				changeBotStatus()
				return
			else
				removeBotIndex(Remove_Bot)
			end
		elseif Change_Bot == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
		end
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.account_banned then
		autoRecon = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		removeBotLogFile(bot.name:upper(), statusBotDescription())
		if Change_Bot == "YES" then
			if totalBotList > 1 then
				table.remove(Bot_List_Result, botStartNumber)
				totalBotList = #Bot_List_Result
				botStartNumber = botStartNumber - 1
				changeBotStatus()
				return
			else
				removeBotIndex(Remove_Bot)
			end
		elseif Change_Bot == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
		end
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.location_banned then
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		if Change_Proxy == "YES" then
			if totalChangeProxyList > 1 then
				local proxyMatch = bot:getProxy().ip .. ":" .. bot:getProxy().port .. ":" .. bot:getProxy().username .. ":" .. bot:getProxy().password
				if proxyMatch == Change_Proxy_List[proxyStartNumber] then
					table.remove(Change_Proxy_List, proxyStartNumber)
					totalChangeProxyList = #Change_Proxy_List
					proxyStartNumber = proxyStartNumber - 1
				end
				changeProxyList()
			else
				removeBotIndex(Remove_Bot)
			end
		elseif Change_Proxy == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the proxy because the feature was disabled.")
		end
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.version_update then
		autoRecon = false
		noStopScript = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		removeBotIndex(Remove_Bot, statusBotDescription())
		return
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.advanced_account_protection then
		if AAP_Verification == "YES" then
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Verify your account from AAP! \n" ..
				"<:Luxurious_Wall_Clock:1190695156333150258> **|** AAP Verification Time: " .. convertMillisecondsToHours(AAP_Verification_Cooldown)
			)
			sleep(AAP_Verification_Cooldown)
		elseif AAP_Verification == "NO" then
			autoRecon = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
			)
			removeBotLogFile(bot.name:upper(), statusBotDescription())
			if Change_Bot == "YES" then
				if totalBotList > 1 then
					table.remove(Bot_List_Result, botStartNumber)
					totalBotList = #Bot_List_Result
					botStartNumber = botStartNumber - 1
					changeBotStatus()
					return
				else
					removeBotIndex(Remove_Bot)
				end
			elseif Change_Bot == "NO" then
				noStopScript = false
				removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
			end
		end
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.server_overload then
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.too_many_login then
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.maintenance then
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<:Luxurious_Wall_Clock:1190695156333150258> **|** Maintenance Cooldown: " .. convertMillisecondsToHours(Maintenance_Cooldown_Milliseconds)
		)
		sleep(Maintenance_Cooldown_Milliseconds)
		return
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.http_block then
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		if Change_Proxy == "YES" then
			if totalChangeProxyList > 1 then
				local proxyMatch = bot:getProxy().ip .. ":" .. bot:getProxy().port .. ":" .. bot:getProxy().username .. ":" .. bot:getProxy().password
				if proxyMatch == Change_Proxy_List[proxyStartNumber] then
					table.remove(Change_Proxy_List, proxyStartNumber)
					totalChangeProxyList = #Change_Proxy_List
					proxyStartNumber = proxyStartNumber - 1
				end
				changeProxyList()
			else
				removeBotIndex(Remove_Bot)
			end
		elseif Change_Proxy == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the proxy because the feature was disabled.")
		end
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.error_connecting then
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		if Change_Proxy == "YES" then
			if totalChangeProxyList > 1 then
				local proxyMatch = bot:getProxy().ip .. ":" .. bot:getProxy().port .. ":" .. bot:getProxy().username .. ":" .. bot:getProxy().password
				if proxyMatch == Change_Proxy_List[proxyStartNumber] then
					table.remove(Change_Proxy_List, proxyStartNumber)
					totalChangeProxyList = #Change_Proxy_List
					proxyStartNumber = proxyStartNumber - 1
				end
				changeProxyList()
			else
				removeBotIndex(Remove_Bot)
			end
		elseif Change_Proxy == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the proxy because the feature was disabled.")
		end
	elseif bot.status ~= BotStatus.online and bot.status == BotStatus.captcha_requested then
		autoRecon = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		removeBotLogFile(bot.name:upper(), statusBotDescription())
		if Change_Bot == "YES" then
			if totalBotList > 1 then
				table.remove(Bot_List_Result, botStartNumber)
				totalBotList = #Bot_List_Result
				botStartNumber = botStartNumber - 1
				changeBotStatus()
				return
			else
				removeBotIndex(Remove_Bot)
			end
		elseif Change_Bot == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
		end
	end
end

function connectBot()
	statusConnectFunction = "CONNECTBOT"
	tutorialWorld = "nil"
	autoRecon = true
	
	if Bot_Format == "CID" and bot.name ~= Bot_List_Result[botStartNumber][1] then
		bot:updateBot(Bot_List_Result[botStartNumber][1], Bot_List_Result[botStartNumber][2], randomMAC(), randomRID())
		sleep(100)
	elseif Bot_Format == "GUEST" and tostring(bot:getLogin().mac) ~= Bot_List_Result[botStartNumber][1] then
		bot:updateBot(randomGrowID(), Bot_List_Result[botStartNumber][1], randomRID())
		sleep(100)
	elseif Bot_Format == "UBI" then
		bot:updateUbiBot(Bot_List_Result[botStartNumber][1], Bot_List_Result[botStartNumber][2])
		sleep(100)
	end
	
	if Platform_Used == "ANDROID" then
		bot:setPlatform(Platform.android)
	elseif Platform_Used == "WINDOWS" then
		bot:setPlatform(Platform.windows)
	elseif Platform_Used == "MACOS" then
		bot:setPlatform(Platform.macos)
	end
	
	if bot.status ~= BotStatus.online then
		bot:connect()
		sleep(Reconnect_Delay)
		maxReconnect()
		webhookShareInfoBot(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
		)
	end
	
	while bot.status ~= BotStatus.online and noStopScript == true do
		bot:connect()
		sleep(Reconnect_Delay)
		maxReconnect()
		webhookShareInfoBot(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
		)
	end
	connectCount = 0
	changingSubserver()
	if bot.status == BotStatus.online and string.find(world.name:upper(), bot.name:upper()) and bot.level < 2 then
		skipTutorial()
	end
	if Change_Bot_On_Max_Level == "YES" then
		if bot.status == BotStatus.online and bot.level >= Max_Level then
			dropExceedPackGoOffline()
			
			while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
				seedWorld()
				dropSeed()
				while inventory:getItemCount(Block_ID) > 0 do
					dropBlock()
				end
			end
			
			while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
				pickaxeWorld()
				while not bot:isInTile(44, 13) do
					findpath(44, 13)
				end
				dropItem(Pickaxe_ID)
				if inventory:getItemCount(Pickaxe_ID) == 0 then
					webhookShareInfoDropped(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
						
						"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
						":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
						getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
					)
				end
			end
			
			dropEquipmentBeforeOfffline()
			hiddenWorld()
			
			autoRecon = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[Max Level]` \n" .. 
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
			)
			removeBotLogFile(bot.name:upper(), "Max Level")
			if Change_Bot == "YES" then
				table.remove(Bot_List_Result, botStartNumber)
				totalBotList = #Bot_List_Result
				botStartNumber = botStartNumber - 1
				changeBotStatus()
			elseif Change_Bot == "NO" then
				noStopScript = false
				removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
			end
		end
	end
	randomWorldBreak()
	randomWorldQuest()
	
	proxyTime = os.time()
	botTime = os.time()
	botTimeShow = os.time() - botTime
	timeR()
	timeRS()
	
	useEmbed2 = true
	checkDropPackCount2()
	webhookShareInfoBot(
		"**[ BOT INFORMATION ]** \n" ..
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
		
		"**[ WORLD INFORMATION ]** \n" ..
		"<:Globe:1190695520210006036> **|** Current Farm World: `" .. Rotation_World .. "` \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
		"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
		"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
		"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n\n" ..
		
		"**[ TREE INFORMATION ]** \n" ..
		"<:Laser_Grid_Tree:1190695145188884661> **|** Farmed Tree: " .. getItemName(Block_ID) .. " \n\n" ..
		
		"**[ TIME INFORMATION ]** \n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow) .. " \n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Looping Time: " .. secondR(kalanzamansaniye6) .. " Minutes",
		
		
		"**[ ITEM INFORMATION ]** \n" ..
		"<:Seed_And_Block:1190695174993608805> **|** Total Seed and Block Dropped [In Backpack]: \n" ..
		getItemName(Seed_ID) .. ": " .. dropSeedCount .. " [" .. inventory:getItemCount(Seed_ID) .. "] \n" ..
		getItemName(Block_ID) .. ": " .. dropBlockCount .. " [" .. inventory:getItemCount(Block_ID) .. "] \n\n" ..
		
		":package: **|** Total Pack Dropped [In Backpack]:" ..
		dropPackCount2
	)
	
	--questSequenceBackup = false
	--startTutorialQuest()
	changeBotHelp()
end

function changeBotHelp()
	if Min_Level < getInfo(Block_ID).level and bot.level < getInfo(Block_ID).level and bot:getAge() <= 120 then
		Bot_Level_Rotation = true
		Min_Level = getInfo(Block_ID).level
		webhookShareInfoBot(
			"<a:toa:997296837352505415> **|** You need to be level " .. Min_Level .. " to break " .. getItemName(Block_ID) .. "! The minimum and maximum level on " .. bot.name:upper() .. " have been set to the latest. Now the minimum level is " .. Min_Level .. " and the maximum level is " .. Max_Level .. "." 
		)
	elseif inventory:getItemCount(Seed_ID) < 20 or inventory:getItemCount(Block_ID) == 0 then
		seedWorld()
	
		if bot:isInWorld(Save_Seed_World) then
			for _, obj in pairs(world:getObjects()) do
				if bot.status == BotStatus.online and obj.id == Seed_ID then
					if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
					elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
					end
				elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
					defaultWorldName = world.name:upper()
					defaultBotX = bot.x
					defaultBotY = bot.y
					
					reconnect(defaultWorldName, defaultBotX, defaultBotY)
				end
				takeItem(Seed_ID)
				webhookShareInfoAllBot()
				if inventory:getItemCount(Seed_ID) > 0 then break end
			end
			
			if inventory:getItemCount(Seed_ID) > 20 then
				bot:moveLeft(1)
				sleep(100)
				while inventory:getItemCount(Seed_ID) > 20 do
					bot:setDirection(false)
					sleep(100)
					bot:drop(Seed_ID, inventory:getItemCount(Seed_ID) - 20)
					sleep(math.random(Drop_Delay, Drop_Delay + 100))
				end
			end
				
			for _, obj in pairs(world:getObjects()) do
				if bot.status == BotStatus.online and obj.id == Block_ID then
					if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
					elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
					end
				elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
					defaultWorldName = world.name:upper()
					defaultBotX = bot.x
					defaultBotY = bot.y
					
					reconnect(defaultWorldName, defaultBotX, defaultBotY)
				end
				takeItem(Block_ID)
				webhookShareInfoAllBot()
				if inventory:getItemCount(Block_ID) > 0 then break end
			end
		end
		
		hiddenWorld()
	end
	
	main()
end

function changeBotStatus()
	if totalBotList == 0 and noStopScript == true then
		autoRecon = false
		noStopScript = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot( 
			"<a:toa:997296837352505415> **|** Your bot total in the bot list is " .. totalBotList .. ", so the script at this index will stop running."
		)
		removeBotIndex(Remove_Bot, "Your bot total in the bot list is " .. totalBotList .. ", so the script at this index will stop running.")
	end
	
	if noStopScript == true then
		if Change_Bot == "NO" then
			connectBot()
		end
		
		if Change_Bot_Cooldown_Milliseconds > 0 then
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** The bot in this index is offline during " .. convertMillisecondsToHours(Change_Bot_Cooldown_Milliseconds) .. " before the bot change."
			)
			sleep(Change_Bot_Cooldown_Milliseconds)
		end
		
		botStartNumber = botStartNumber + 1
		Bot_Format = niL
		if botStartNumber <= totalBotList then
			cachedWorldBreak = nil
			notWorldBanned = true
		elseif botStartNumber > totalBotList then
			botStartNumber = 1
		end
		
		if Bot_Format == nil then
			if not Bot_List_Result[botStartNumber][1]:find(":") and not Bot_List_Result[botStartNumber][1]:find("@") then
				Bot_Format = "CID"
			elseif Bot_List_Result[botStartNumber][1]:find(":") and not Bot_List_Result[botStartNumber][1]:find("@") then
				 Bot_Format = "GUEST"
			elseif Bot_List_Result[botStartNumber][1]:find("@") and not Bot_List_Result[botStartNumber][1]:find(":") then
				Bot_Format = "UBI"
			end
		end
		connectBot()
	end
end
---- [ END BOT PLAYTIME ] ----


---- [ TILE ROUNDING ] ----
function tileRounding(number)
    local decimal = number - math.floor(number)
    if decimal < 0.7 then
        return math.floor(number)
    else
        return math.ceil(number)
    end
end
---- [ END TILE ROUNDING ] ----


---- [ CHANGING SUBSERVER ] ----
function changingSubserver()
	if bot.status == BotStatus.changing_subserver then
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is currently changing subserver."
		)
		
		sleep(8000)
		maxReconnect()
		webhookShareInfoBot(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
		)
		bot:connect()
		--addEvent(Event.variantlist, tutorialQuestEvent)
		--listenEvents(Reconnect_Delay_Cooldown_Seconds)
		sleep(Reconnect_Delay)
		while bot.status == BotStatus.changing_subserver do
			maxReconnect()
			webhookShareInfoBot(
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
			)
			bot:connect()
			--addEvent(Event.variantlist, tutorialQuestEvent)
			--listenEvents(Reconnect_Delay_Cooldown_Seconds)
			sleep(Reconnect_Delay)
		end
	end
	connectCount = 0
end
---- [ END CHANGING SUBSERVER ] ----

---- [ SCAN ] ----
function fossilRockScan()
	local retry = false
	local fossil = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.fg == 3918 and bot:isInWorld(Rotation_World) and world:hasAccess(tile.x, tile.y) ~= 0 then
			if #bot:getPath(tile.x, tile.y + 1) > 0 then
				fossil = fossil + 1
			elseif #bot:getPath(tile.x, tile.y + 1) == 0 and bot:isInTile(tile.x, tile.y + 1) then
				fossil = fossil + 1
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		fossilRockScan()
	end
	
	return fossil
end

function unreadyTreeTutorialQuestScan(itemID)
	local retry = false
	local unreadyTree = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.fg == itemID and not tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
			if #bot:getPath(tile.x, tile.y) > 0 then
				unreadyTree = unreadyTree + 1
			elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
				unreadyTree = unreadyTree + 1
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		unreadyTreeTutorialQuestScan(itemID)
	end
		
	return unreadyTree
end

function readyTreeScan()
	local retry = false
	local readyTree = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.fg == Seed_ID and tile:canHarvest() and bot:isInWorld(Rotation_World) and world:hasAccess(tile.x, tile.y) ~= 0 then
			if #bot:getPath(tile.x, tile.y) > 0 then
				readyTree = readyTree + 1
			elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
				readyTree = readyTree + 1
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		readyTreeScan()
	end
		
	return readyTree
end

function readyTreeBelowScan()
	local retry = false
	local readyTree = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.y >= bot.y then
			if tile.fg == Seed_ID and tile:canHarvest() and bot:isInWorld(Rotation_World) and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y) > 0 then
					readyTree = readyTree + 1
					break
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
					readyTree = readyTree + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		readyTreeScan()
	end
		
	return readyTree
end

function unreadyTreeScan()
	local retry = false
	local unreadyTree = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.fg == Seed_ID and not tile:canHarvest() and bot:isInWorld(Rotation_World) and world:hasAccess(tile.x, tile.y) ~= 0 then
			if #bot:getPath(tile.x, tile.y) > 0 then
				unreadyTree = unreadyTree + 1
			elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
				unreadyTree = unreadyTree + 1
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		unreadyTreeScan()
	end
		
	return unreadyTree
end

function readyMatureRootsScan()
	local retry = false
	local readyMatureRoots = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online then
			if tile.fg == Mature_Roots_ID and bot:isInWorld(Rotation_World) and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y - 1) > 0 then
					readyMatureRoots = readyMatureRoots + 1
				elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1) then
					readyMatureRoots = readyMatureRoots + 1
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		readyMatureRootsScan()
	end
	return readyMatureRoots
end

function readyMatureRootsBelowScan()
	local retry = false
	local readyMatureRoots = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.y >= bot.y then 
			if tile.fg == Mature_Roots_ID and bot:isInWorld(Rotation_World) and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y - 1) > 0 then
					readyMatureRoots = readyMatureRoots + 1
					break
				elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1) then
					readyMatureRoots = readyMatureRoots + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		readyMatureRootsScan()
	end
	return readyMatureRoots
end

function jobScan()
	local retry = false
	job = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.fg == Seed_ID and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
			if #bot:getPath(tile.x, tile.y) > 0 then
				job = job + 1
			elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
				job = job + 1
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		jobScan()
	end
	
	return job
end

function emptyTileScan()
	local retry = false
	local emptyTile = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online then
			if bot:isInWorld(Rotation_World) and tile.fg == 0 and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y) > 0 then
					emptyTile = emptyTile + 1
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y - 1) then
					emptyTile = emptyTile + 1
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		emptyTileScan()
	end
		
	return emptyTile
end

function emptyTileBelowScan()
	local retry = false
	local emptyTile = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and tile.y >= bot.y then
			if bot:isInWorld(Rotation_World) and tile.fg == 0 and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y) > 0 then
					emptyTile = emptyTile + 1
					break
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y - 1) then
					emptyTile = emptyTile + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		emptyTileScan()
	end
		
	return emptyTile
end

function ghostScan()
	local retry = false
	local ghost = 0
	
	for _, ghosts in pairs(world:getNPCs()) do
		if bot.status == BotStatus.online then
			if ghosts.id > 0 then
				ghost = ghost + 1
			end
		else
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		ghostScan()
	end
		
	return ghost
end

function placedItemInOtherWorldScan(itemID)
	local retry = false
	local placed = 0
	
	if bot:isInWorld() then
		while bot:isInWorld() and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg ~= 6 do
			bot:respawn()
			sleep(1000)
		end
	
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if bot:isInWorld() and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and ((tile.x == bot.x and tile.y == bot.y - 1) or (tile.x == bot.x + 1 and tile.y == bot.y - 1)) then
					if (tile.fg == itemID or tile.bg == itemID) and world:hasAccess(tile.x, tile.y) ~= 0 then
						placed = placed + 1
						break
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				defaultWorldName = world.name:upper()
				defaultBotX = bot.x
				defaultBotY = bot.y
					
				retry = true
				reconnect(defaultWorldName, defaultBotX, defaultBotY)
				break
			end
		end
	end
	
	if retry then
		placedItemInOtherWorldScan(itemID)
	end
	
	return placed
end

function objectSafeScan(itemID)
	local retry = false
	local float = 0
	
	for _, obj in pairs(world:getObjects()) do
		if bot.status == BotStatus.online and obj.id == itemID then
			if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
				float = float + obj.count
			elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
				float = float + obj.count
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		objectSafeScan(itemID)
	end
	
	return float
end

function tileSafeScan(itemID)
	local retry = false
	local tileCount = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online then
			if (tile.fg == itemID or tile.bg == itemID) and world:hasAccess(tile.x, tile.y) ~= 0 then
				tileCount = tileCount + 1
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		tileSafeScan(itemID)
	end
	
	return tileCount
end

function objectGrowScan(itemID)
	local retry = false
	local count = 0
	
	for id, counts in pairs(world.growscan:getObjects()) do
		if bot.status == BotStatus.online then
			if id == itemID then
				count = counts
			end
		else
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		objectGrowScan(itemID)
	end
	
	return count
end

function tileGrowScan(itemID)
	local retry = false
	local count = 0
		
	for id, counts in pairs(world.growscan:getTiles()) do
		if bot.status == BotStatus.online then
			if id == itemID then
				count = counts
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		tileGrowScan(itemID)
	end
	
	return count
end

function doorScan()
	local retry = false
	local door = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online then
			if ((tile.fg == 12) or (tile.fg == 30) or (tile.fg == 1684) or (tile.fg == 544) or (tile.fg == 546) or (tile.fg == 10654)) then
				door = door + 1
				break
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		doorScan()
	end
	
	return door
end

function playerScan()
	local retry = false
	local playerCount = 0
	
	for _, player in pairs(world:getPlayers()) do
		if bot.status == BotStatus.online and not string.find(player.name:upper(), bot.name:upper()) then
			playerCount = playerCount + 1
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			retry = true
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			break
		end
	end
	
	if retry then
		playerScan()
	end
	
	return playerCount
end
---- [ END SCAN ] ----


---- [ WEBHOOK AUTO PLANT NO ] ----
function webhookAutoPlantNo()
	botTimeShow = os.time() - botTime
	timeRS()
	timeR()
	
	webhookShareInfoBot(
		"**[ BOT INFORMATION ]** \n" ..
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
		
		"**[ TIME INFORMATION ]**\n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow) .. " \n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Looping Time: " .. secondR(kalanzamansaniye6) .. " Minutes"
	)
end
---- [ END WEBHOOK AUTO PLANT NO ] ----


---- [ RANDOM CHAT ] ----
function getRandomChat()
    local randomIndex = math.random(#Random_Chat_List)
    return Random_Chat_List[randomIndex]
end

lastActionTimeChatCooldown = os.time() - Chat_Cooldown
function performActionRandomChat()
    local currentTime = os.time()
    local chatCooldown = Chat_Cooldown

    if currentTime - lastActionTimeChatCooldown >= chatCooldown then
        lastActionTimeChatCooldown = currentTime
        if math.random(2) == 1 then
            return getRandomChat()
        else
            return
        end
    else
        return
    end
end

function randomChat()
	if Random_Chat_Status == "YES" then
		local result = performActionRandomChat()
		if result then
			bot:setBubble(Bubble.talk)
			sleep(#result * 80)
			bot:say(result)
			sleep(10)
			bot:setBubble(Bubble.none)
		end
	elseif Random_Chat_Status == "NO" then
		return
	end
end
---- [ END RANDOM CHAT ] ----


---- [ CAPTCHA STATUS ] ----
function statusCaptchaDescription()
	if bot.captcha_status == CaptchaStatus.solved then
		return "Captcha Solved"
	elseif bot.captcha_status == CaptchaStatus.failed then
		return "Captcha That Cannot Be Solved"
	elseif bot.captcha_status == CaptchaStatus.no_access then
		return "Captcha That Cannot Be Solved Due To Http Forbidden or Bad Gateway Error"
	elseif bot.captcha_status == CaptchaStatus.invalid_key then
		return "Invalid Captcha Key"
	elseif bot.captcha_status == CaptchaStatus.invalid_token then
		return "Invalid Captcha Token"
	else 
		return "nil"
	end
end
---- [ END CAPTCHA STATUS ] ----


---- [ MATCH DOOR ID ] ----
function matchDoorID()
	if bot:isInWorld(Rotation_World) then
		return Rotation_Door_ID
	elseif bot:isInWorld(Save_Pack_World) then
		return Save_Pack_Door_ID
	elseif bot:isInWorld(Save_Seed_World) then
		return Save_Seed_Door_ID
	elseif bot:isInWorld(Custom_World_Break_Other_World) and Use_Custom_World_For_Break == "YES" then
		return Custom_World_Break_Other_World_Door_ID
	elseif bot:isInWorld(randomWorldBreak()) and Use_Random_World_For_Break == "YES" then
		return randomWorldBreak()
	elseif bot:isInWorld(tutorialWorld) and Use_Tutorial_World_For_Break == "YES" then
		return tutorialWorld
	elseif bot:isInWorld(Pickaxe_World) then
		return Pickaxe_Door_ID
	elseif bot:isInWorld(Equipment_World) then
		return Equipment_Door_ID
	elseif bot:isInWorld(Whitelist_World) then
		return Whitelist_Door_ID
	elseif bot:isInWorld(Cook_World) then
		return Cook_Door_ID
	else
		return "GKS"
	end
end
---- [ END MATCH DOOR ID ] ----


---- [ RECONNECT ] ----
function maxReconnect()
	matchStatusConnect()
	if connectCount < maxReconnectCount then
		connectCount = connectCount + 1
	else
		
		if (bot.status == BotStatus.offline or bot.status == 22) and bot:getPing() == 0 then
			connectCount = 0
			if Change_Proxy == "YES" then
				local proxyMatch = bot:getProxy().ip .. ":" .. bot:getProxy().port .. ":" .. bot:getProxy().username .. ":" .. bot:getProxy().password
				if proxyMatch == Change_Proxy_List[proxyStartNumber] then
					table.remove(Change_Proxy_List, proxyStartNumber)
					totalChangeProxyList = #Change_Proxy_List
					proxyStartNumber = proxyStartNumber - 1
				end
				changeProxyList()
			elseif Change_Proxy == "NO" then
				noStopScript = false
				removeBotIndex(Remove_Bot, "Failed to change the proxy because the feature was disabled.")
			end
		end
		
		if connectCount > 0 then
			webhookShareInfoReconnect(
				"<a:toa:997296837352505415> **|** Sorry, the maximum reconnect has reached the limit. Please wait until the bot is back online! \n" ..
				"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Max_Reconnect_Cooldown_Milliseconds)
			)
			sleep(Max_Reconnect_Cooldown_Milliseconds)
			connectCount = 0
		end
	end
end

function reconnect(world_name_reconnect, x, y)
	world_name_reconnect = world_name_reconnect:upper()
	
	if bot.status == BotStatus.online and bot:getPing() == 0 then
		webhookShareInfoAllBot()
		webhookShareInfoReconnect(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[Online With Ping 0 Detected]`"
		)
		bot:disconnect()
		sleep(100)
	end
	
	if autoRecon then
		if bot.status ~= BotStatus.online then
			webhookShareInfoAllBot()
			webhookShareInfoReconnect(
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
			)
			maxReconnect()
			webhookShareInfoReconnect(
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
			)
			bot:connect()
			sleep(Reconnect_Delay)
			while true do
				while bot.status ~= BotStatus.online and noStopScript == true do
					maxReconnect()
					webhookShareInfoReconnect(
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
					)
					bot:connect()
					sleep(Reconnect_Delay)
				end
				sleep(3000)
				changingSubserver()
				local maxJoinWorld = 0
				while bot.status == BotStatus.online and not bot:isInWorld(world_name_reconnect) do 
					bot:warp(world_name_reconnect .. "|" .. matchDoorID())
					if world_name_reconnect == Rotation_World then
						addEvent(Event.variantlist, worldFarmBannedEvent)
						listenEvents(10)
					elseif ((world_name_reconnect == Custom_World_Break_Other_World) or (world_name_reconnect == randomWorldBreak())) then
						addEvent(Event.variantlist, breakOtherWorldEvent)
						listenEvents(10)
					else
						addEvent(Event.variantlist, worldBannedEvent)
						listenEvents(10)
					end
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					while maxJoinWorld >= 5 do
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
						if not bot:isInWorld(world_name_reconnect) then
							bot:disconnect()
							sleep(100)
							reconnect(world_name_reconnect, x, y)
						end
					end
				end
				sleep(5000)
				if bot.status == BotStatus.online and bot:isInWorld(world_name_reconnect) then
					if Auto_Hidden_World == "YES" and (not bot:isInWorld(Rotation_World) or not bot:isInWorld(Custom_World_Break_Other_World) or not bot:isInWorld(randomWorldBreak()) or not bot:isInWorld(tutorialWorld) or not string.find(world.name:upper(), "GKSQUEST")) then
						for _, hiddenWorld in pairs(Hidden_World_List) do
							local hiddenWorld = hiddenWorld:upper()
							if hiddenWorld == world_name_reconnect and bot:isInWorld(hiddenWorld) then
								break
							end
						end
					else
						if bot:isInWorld() and (string.find(world.name:upper(), bot.name:upper()) or string.find(world.name:upper(), randomWorldBreak()) or string.find(world.name:upper(), "GKSQUEST")) then
							break
						else
							while bot.status == BotStatus.online and bot:isInWorld(world_name_reconnect) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and doorScan() > 0 do
								bot:warp(world_name_reconnect .. "|" .. matchDoorID())
								sleep(Join_World_Delay)
								changingSubserver()
								
								if bot:isInWorld() and (string.find(world.name:upper(), bot.name:upper()) or string.find(world.name:upper(), randomWorldBreak()) or string.find(world.name:upper(), "GKSQUEST")) then
									break
								end
							end
						end
					end
					
					if #bot:getPath(x, y) > 0 then
						while bot.status == BotStatus.online and bot:isInWorld(world_name_reconnect) and math.floor(world:getLocal().posx / 32) ~= x or math.floor(world:getLocal().posy / 32) ~= y do
							findpath(x, y)
						end
						if bot.status == BotStatus.online and bot:isInWorld(world_name_reconnect) and math.floor(world:getLocal().posx / 32) == x and math.floor(world:getLocal().posy / 32) == y then
							webhookShareInfoReconnect(
								"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is back online!"
							)
							connectCount = 0
							return false
						end
					elseif #bot:getPath(x, y) == 0 then
						local sendWebhookAmount = 0
						webhookShareInfoReconnect(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is back online!"
						)
						connectCount = 0
						return false
					end
				end
			end
		elseif bot.status == BotStatus.online and bot:isInWorld() then
			if bot:isInWorld() and string.find(world.name:upper(), bot.name:upper()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
				return
			elseif bot:isInWorld() and string.find(world.name:upper(), "GKSQUEST") and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
				return
			elseif bot:isInWorld() and string.find(world.name:upper(), randomWorldBreak()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
				return
			end
			
			if Auto_Hidden_World == "YES" and (not bot:isInWorld(Rotation_World) or not bot:isInWorld(Custom_World_Break_Other_World) or not bot:isInWorld(randomWorldBreak()) or not bot:isInWorld(tutorialWorld) or not string.find(world.name:upper(), "GKSQUEST")) then
				for _, hiddenWorld in pairs(Hidden_World_List) do
					local hiddenWorld = hiddenWorld:upper()
					if bot:isInWorld(hiddenWorld) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
						return
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(world_name_reconnect) and world_name_reconnect == Rotation_World and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				bot:warp(world_name_reconnect .. "|" .. matchDoorID())
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 3 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 3 times. Maybe the rotation door ID is wrong."
					)
					maxJoinWorld = 0
					nextWorldStatus = "otherCondition"
					loopStatus()
				end
			end
			
			while bot:isInWorld(world_name_reconnect) and world_name_reconnect ~= Rotation_World and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				bot:warp(world_name_reconnect .. "|" .. matchDoorID())
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the door ID is wrong.")
				end
			end
		end
	end
end
---- [ END RECONNECT ] ----


---- [ JOIN WORLD ] ----
function worldFarmBannedEvent(varlist, netid)
	if varlist:get(0):getString() == "OnConsoleMessage" then
		message = varlist:get(1):getString()
		if message:match("That world is inaccessible.") then
			unlistenEvents()
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. Rotation_World .. " world has been banned."
			)
			nextWorldStatus = false
			loopStatus()
		end
	end
end

function breakOtherWorldEvent(varlist, netid)
	if varlist:get(0):getString() == "OnConsoleMessage" then
		message = varlist:get(1):getString()
		if message:match("That world is inaccessible.") then
			unlistenEvents()
			if Use_Custom_World_For_Break == "YES" then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. Custom_World_Break_Other_World .. " world has been banned."
				)
				
				table.remove(Custom_World_For_Break_List_Result, 1)
				totalCustomWorldForBreakList = #Custom_World_For_Break_List_Result
				if totalCustomWorldForBreakList == 0 then
					removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a custom world for break list.")
				elseif totalCustomWorldForBreakList > 0 then
					Custom_World_Break_Other_World = Custom_World_For_Break_List_Result[1][1]:upper()
					Custom_World_Break_Other_World_Door_ID = Custom_World_For_Break_List_Result[1][2]:upper()
					breakOtherWorld()
				end
			elseif Use_Random_World_For_Break == "YES" then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. randomWorldBreak() .. " world has been banned."
				)
				cachedWorldBreak = nil
				notWorldBanned = false
				breakOtherWorld()
			end
		elseif message:match("Oops, you've created too many worlds today.  Try again tomorrow!") and noStopScript == true then
			unlistenEvents()
			autoRecon = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[Oops, you've created too many worlds today. Try again tomorrow!]`"
			)
			removeBotLogFile(bot.name:upper(), "Oops, you've created too many worlds today. Try again tomorrow!")
			if Change_Bot == "YES" then
				table.remove(Bot_List_Result, botStartNumber)
				totalBotList = #Bot_List_Result
				botStartNumber = botStartNumber - 1
				changeBotStatus()
			elseif Change_Bot == "NO" then
				noStopScript = false
				removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
			end
		end
	end
end

function worldBannedEvent(varlist, netid)
	if varlist:get(0):getString() == "OnConsoleMessage" then
		message = varlist:get(1):getString()
		if message:match("That world is inaccessible.") and noStopScript == true then			
			unlistenEvents()
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** World has been banned. The bot will be offline."
			)
			removeBotIndex(Remove_Bot, "World has been banned. The bot will be offline.")
		end
	end
end

function tutorialWorldEvent(varlist, netid)
	if varlist:get(0):getString() == "OnDialogRequest" then
		message = varlist:get(1):getString()
		
		if message:match("add_button|(%w*" .. bot.name:upper() .. "%w*)") then
			tutorialWorld = message:match("(%w*" .. bot.name:upper() .. "%w*)"):upper()
			webhookShareInfoBot(
				"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
				"<a:toa:997296837352505415> **|** Your PNB world has been updated to a tutorial world."
			)
			unlistenEvents()
		elseif not message:match("add_button|(%w*" .. bot.name:upper() .. "%w*)") and noStopScript == true then
			unlistenEvents()
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** Tutorial world not found. Make sure the tutorial world name has a bot name element!"
			)
			removeBotIndex(Remove_Bot, "Tutorial world not found. Make sure the tutorial world name has a bot name element!")
		end
	end
end

function farmWorld()
	reconnect(Rotation_World, 1, 23)
	
	if not bot:isInWorld(Rotation_World) then
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Rotation_World .. "|" .. Rotation_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			local maxJoinWorld = 0
			while not bot:isInWorld(Rotation_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Rotation_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Rotation_World .. "|" .. Rotation_Door_ID)
				addEvent(Event.variantlist, worldFarmBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Rotation_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Rotation_World, 1, 23)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Rotation_World, 1, 23)
				bot.auto_collect = true
				sleep(100)
				bot:warp(Rotation_World .. "|" .. Rotation_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 3 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 3 times. Maybe the rotation door ID is wrong."
					)
					maxJoinWorld = 0
					nextWorldStatus = "otherCondition"
					loopStatus()
				end
			end
			
			reconnect(Rotation_World, 1, 23)
			if bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg ~= 6 then
				bot.auto_collect = true
				sleep(100)
			else
				farmWorld()
			end
		else
			reconnect(Rotation_World, 1, 23)
			farmWorld()
		end
	elseif bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Rotation_World, 1, 23)
			bot.auto_collect = true
			sleep(100)
			bot:warp(Rotation_World .. "|" .. Rotation_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 3 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 3 times. Maybe the rotation door ID is wrong."
				)
				maxJoinWorld = 0
				nextWorldStatus = "otherCondition"
				loopStatus()
			end
		end
		
		reconnect(Rotation_World, 1, 23)
		if bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg ~= 6 then
			bot.auto_collect = true
			sleep(100)
		else
			farmWorld()
		end
	end
end

function packWorld()
	reconnect(Save_Pack_World, 1, 23)
	
	if not bot:isInWorld(Save_Pack_World) then
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Save_Pack_World .. "|" .. Save_Pack_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			
			local maxJoinWorld = 0
			while not bot:isInWorld(Save_Pack_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Save_Pack_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Save_Pack_World .. "|" .. Save_Pack_Door_ID)
				addEvent(Event.variantlist, worldBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Save_Pack_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Save_Pack_World, 1, 23)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Save_Pack_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Save_Pack_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Save_Pack_World .. "|" .. Save_Pack_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save pack door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save pack door ID is wrong.")
				end
			end
			reconnect(Save_Pack_World, 1, 23)
		else
			reconnect(Save_Pack_World, 1, 23)
			packWorld()
		end
	elseif bot:isInWorld(Save_Pack_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Save_Pack_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Save_Pack_World, 1, 23)
			bot.auto_collect = false
			sleep(100)
			bot:warp(Save_Pack_World .. "|" .. Save_Pack_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 5 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save pack door ID is wrong."
				)
				maxJoinWorld = 0
				autoRecon = false
				noStopScript = false
				removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save pack door ID is wrong.")
			end
		end
	end
end

function seedWorld()
	reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
	
	if not bot:isInWorld(Save_Seed_World) then 
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Save_Seed_World .. "|" .. Save_Seed_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			
			local maxJoinWorld = 0
			while not bot:isInWorld(Save_Seed_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Save_Seed_World .. "|" .. Save_Seed_Door_ID)
				addEvent(Event.variantlist, worldBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Save_Seed_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Save_Seed_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Save_Seed_World .. "|" .. Save_Seed_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save seed door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save seed door ID is wrong.")
				end
			end
			
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		else
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			seedWorld()
		end
	elseif bot:isInWorld(Save_Seed_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Save_Seed_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			bot.auto_collect = false
			sleep(100)
			bot:warp(Save_Seed_World .. "|" .. Save_Seed_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 5 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save seed door ID is wrong."
				)
				maxJoinWorld = 0
				autoRecon = false
				noStopScript = false
				removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the save seed door ID is wrong.")
			end
		end
	end
end

function pickaxeWorld()
	reconnect(Pickaxe_World, 1, 23)
	
	if not bot:isInWorld(Pickaxe_World) then  
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Pickaxe_World .. "|" .. Pickaxe_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			
			local maxJoinWorld = 0
			while not bot:isInWorld(Pickaxe_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Pickaxe_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Pickaxe_World .. "|" .. Pickaxe_Door_ID)
				addEvent(Event.variantlist, worldBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Pickaxe_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Pickaxe_World, 1, 23)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Pickaxe_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Pickaxe_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Pickaxe_World .. "|" .. Pickaxe_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the pickaxe door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the pickaxe door ID is wrong.")
				end
			end
			
			reconnect(Pickaxe_World, 1, 23)
		else
			reconnect(Pickaxe_World, 1, 23)
			pickaxeWorld()	
		end
	elseif bot:isInWorld(Pickaxe_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Pickaxe_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Pickaxe_World, 1, 23)
			bot.auto_collect = false
			sleep(100)
			bot:warp(Pickaxe_World .. "|" .. Pickaxe_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 5 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the pickaxe door ID is wrong."
				)
				maxJoinWorld = 0
				autoRecon = false
				noStopScript = false
				removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the pickaxe door ID is wrong.")
			end
		end
	end
end

function equipmentWorld()
	reconnect(Equipment_World, 1, 23)
	
	if not bot:isInWorld(Equipment_World) then  
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Equipment_World .. "|" .. Equipment_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			
			local maxJoinWorld = 0
			while not bot:isInWorld(Equipment_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Equipment_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Equipment_World .. "|" .. Equipment_Door_ID)
				addEvent(Event.variantlist, worldBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Equipment_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Equipment_World, 1, 23)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Equipment_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Equipment_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Equipment_World .. "|" .. Equipment_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the equipment door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the equipment door ID is wrong.")
				end
			end
			
			reconnect(Equipment_World, 1, 23)
		else
			reconnect(Equipment_World, 1, 23)
			equipmentWorld()
		end
	elseif bot:isInWorld(Equipment_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Equipment_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Equipment_World, 1, 23)
			bot.auto_collect = false
			sleep(100)
			bot:warp(Equipment_World .. "|" .. Equipment_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 5 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the equipment door ID is wrong."
				)
				maxJoinWorld = 0
				autoRecon = false
				noStopScript = false
				removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the equipment door ID is wrong.")
			end
		end
	end
end

function hiddenWorld()
	if Auto_Hidden_World == "YES" then
		bot.auto_collect = false
		sleep(100)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			for _, hiddenWorld in pairs(Hidden_World_List) do
				bot:sendPacket(3, "action|quit_to_exit")
				sleep(1000)
				
				local hiddenWorld = hiddenWorld:upper()
				bot:warp(hiddenWorld)
				sleep(Join_World_Delay)
				changingSubserver()
				
				reconnect(hiddenWorld, 50, 23)
				
				local maxJoinWorld = 0
				while not bot:isInWorld(hiddenWorld) and maxJoinWorld < 5 do
					reconnect(hiddenWorld, 50, 23)
					bot.auto_collect = false
					sleep(100)
					bot:warp(hiddenWorld)
					sleep(Join_World_Delay)
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					while maxJoinWorld >= 5 do
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
						if not bot:isInWorld(hiddenWorld) then
							bot:disconnect()
							sleep(100)
							reconnect(hiddenWorld, 50, 23)
						end
					end
				end
				lastHiddenWorld = hiddenWorld:upper()
			end
			
			if bot:isInWorld(lastHiddenWorld) then
				local checkFindpathUp = true
				local checkFindpathLeft = true
				local checkFindpathRight = true
				
				if checkFindpathUp and (#bot:getPath(bot.x, bot.y - 1) > 0 or #bot:getPath(bot.x, bot.y - 2) > 0 or #bot:getPath(bot.x, bot.y - 3) > 0) then
					local repeats = 0
					local randomRepeats = math.random(1, 3)
					while repeats < randomRepeats do
						local checkFindpathUpRandomRange = math.random(1, 3)
						reconnect(lastHiddenWorld)
						findpath(bot.x, bot.y - checkFindpathUpRandomRange)
						findpath(bot.x, bot.y + checkFindpathUpRandomRange)
						repeats = repeats + 1
					end
					bot:setBubble(Bubble.talk)
					sleep(#getRandomChat() * 80)
					bot:say(getRandomChat())
					sleep(10)
					bot:setBubble(Bubble.none)
				end
				
				if checkFindpathLeft and (#bot:getPath(bot.x - 1, bot.y) > 0 or #bot:getPath(bot.x - 2, bot.y) > 0 or #bot:getPath(bot.x - 3, bot.y) > 0) then
					local repeats = 0
					local randomRepeats = math.random(1, 3)
					while repeats < randomRepeats do
						local checkFindpathLeftRandomRange = math.random(1, 3)
						reconnect(lastHiddenWorld)
						findpath(bot.x - checkFindpathLeftRandomRange, bot.y)
						findpath(bot.x + checkFindpathLeftRandomRange, bot.y)
						repeats = repeats + 1
					end
					bot:setBubble(Bubble.talk)
					sleep(#getRandomChat() * 80)
					bot:say(getRandomChat())
					sleep(10)
					bot:setBubble(Bubble.none)
				end
				
				if checkFindpathRight and (#bot:getPath(bot.x + 1, bot.y) > 0 or #bot:getPath(bot.x + 2, bot.y) > 0 or #bot:getPath(bot.x + 3, bot.y) > 0) then
					local repeats = 0
					local randomRepeats = math.random(1, 3)
					while repeats < randomRepeats do
						local checkFindpathRightRandomRange = math.random(1, 3)
						reconnect(lastHiddenWorld)
						findpath(bot.x + checkFindpathRightRandomRange, bot.y)
						findpath(bot.x - checkFindpathRightRandomRange, bot.y)
						repeats = repeats + 1
					end
					bot:setBubble(Bubble.talk)
					sleep(#getRandomChat() * 80)
					bot:say(getRandomChat())
					sleep(10)
					bot:setBubble(Bubble.none)
				end
			end
		else
			reconnect(Rotation_World, 1, 23)
			farmWorld()
		end
	elseif Auto_Hidden_World == "NO" then
		return
	end
end

function breakOtherWorld()
	bot.auto_collect = false
	sleep(100)
	if bot.status == BotStatus.online and bot.auto_collect == false then 
	
		if Break_Other_World == "YES" then
			bot:sendPacket(3, "action|quit_to_exit")
			sleep(1000)
			
			if Use_Custom_World_For_Break == "YES" then
				bot:warp(Custom_World_Break_Other_World .. "|" .. Custom_World_Break_Other_World_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				
				local maxJoinWorld = 0
				while not bot:isInWorld(Custom_World_Break_Other_World) and maxJoinWorld < 5 and noStopScript == true do
					reconnect(Custom_World_Break_Other_World, 1, 23)
					bot.auto_collect = false
					sleep(100)
					bot:warp(Custom_World_Break_Other_World .. "|" .. Custom_World_Break_Other_World_Door_ID)
					addEvent(Event.variantlist, breakOtherWorldEvent)
					listenEvents(10)
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					while maxJoinWorld >= 5 do
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
						if not bot:isInWorld(Custom_World_Break_Other_World) then
							bot:disconnect()
							sleep(100)
							reconnect(Custom_World_Break_Other_World, 1, 23)
						end
					end
				end
				
				local maxJoinWorld = 0
				while bot:isInWorld(Custom_World_Break_Other_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and doorScan() > 0 and noStopScript == true do
					reconnect(Custom_World_Break_Other_World, 1, 23)
					bot.auto_collect = true
					sleep(100)
					bot:warp(Custom_World_Break_Other_World .. "|" .. Custom_World_Break_Other_World_Door_ID)
					sleep(Join_World_Delay)
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					if maxJoinWorld >= 5 then
						changingSubserver()
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the break other world door ID is wrong."
						)
						maxJoinWorld = 0
						autoRecon = false
						noStopScript = false
						removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the break other world door ID is wrong.")
					end
				end
				
				reconnect(Custom_World_Break_Other_World, 1, 23)
				bot.auto_collect = true
				sleep(100)
			elseif Use_Random_World_For_Break == "YES" then
				randomBreakOtherWorldLogFile(bot.name:upper(), randomWorldBreak())
				bot:warp(randomWorldBreak())
				sleep(Join_World_Delay)
				changingSubserver()
				local maxJoinWorld = 0
				while not bot:isInWorld(randomWorldBreak()) and maxJoinWorld < 5 and noStopScript == true do
					reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
					bot.auto_collect = false
					sleep(100)
					bot:warp(randomWorldBreak())
					addEvent(Event.variantlist, breakOtherWorldEvent)
					listenEvents(10)
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					while maxJoinWorld >= 5 do
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
						if not bot:isInWorld(randomWorldBreak()) then
							bot:disconnect()
							sleep(100)
							reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
						end
					end
				end

				if bot:isInWorld("DISNEYLAND") then
					cachedWorldBreak = nil
					breakOtherWorld()
				end

				while bot:isInWorld(randomWorldBreak()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg ~= 6 do
					bot:respawn()
					sleep(1000)
				end
				
				if bot:isInWorld(randomWorldBreak()) and world:hasAccess(bot.x, bot.y - 1) == 0 and placedItemInOtherWorldScan(204) > 0 then
					cachedWorldBreak = nil
					breakOtherWorld()
				end
				
				if bot:isInWorld(randomWorldBreak()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
					if placedItemInOtherWorldScan(204) == 0 then
						while inventory:getItemCount(204) < 1 and bot.gem_count >= 200 do
							bot:buy("big_lock")
							sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
						end
					end
					
					if bot:isInWorld(randomWorldBreak()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and inventory:getItemCount(204) >= 1 then
						bot:place(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32) - 1, 204)
						sleep(math.random(Place_Delay, Place_Delay + 100))
					end
					
					if placedItemInOtherWorldScan(226) == 0 and Buy_Signal_Jammer == "YES" then
						while inventory:getItemCount(226) < 1 and bot.gem_count >= 2000 do
							bot:buy("signal_jammer")
							sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
						end
					end
					
					if bot:isInWorld(randomWorldBreak()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and inventory:getItemCount(226) >= 1 then
						bot:place(math.floor(world:getLocal().posx / 32) + 1, math.floor(world:getLocal().posy / 32) - 1, 226)
						sleep(math.random(Place_Delay, Place_Delay + 100))
						if bot:isInWorld(randomWorldBreak()) and not world:getTile(math.floor(world:getLocal().posx / 32) + 1, math.floor(world:getLocal().posy / 32) - 1):hasFlag(64) then
							bot:hit(math.floor(world:getLocal().posx / 32) + 1, math.floor(world:getLocal().posy / 32) - 1)
							sleep(math.random(Hit_Delay, Hit_Delay + 100))
						end
					end
				end
				
				for _, tile in pairs(world:getTiles()) do
					if bot.status == BotStatus.online then
						if tile.fg == 204 and bot:isInWorld(randomWorldBreak()) and world:hasAccess(tile.x, tile.y) ~= 0 and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
							breakOtherWorldX = bot.x
							breakOtherWorldY = bot.y - 2
							break
						end
					elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
						reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
					end
				end
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
				bot.auto_collect = true
				sleep(100)
			elseif Use_Tutorial_World_For_Break == "YES" then
				bot:warp(tutorialWorld)
				sleep(Join_World_Delay)
				changingSubserver()
				
				local maxJoinWorld = 0
				while not bot:isInWorld(tutorialWorld) and maxJoinWorld < 5 and noStopScript == true do
					reconnect(tutorialWorld, 1, 1)
					bot.auto_collect = false
					sleep(100)
					bot:warp(tutorialWorld)
					addEvent(Event.variantlist, worldBannedEvent)
					listenEvents(10)
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					while maxJoinWorld >= 5 do
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
						if not bot:isInWorld(tutorialWorld) then
							bot:disconnect()
							sleep(100)
							reconnect(tutorialWorld, 1, 23)
						end
					end
				end
				
				reconnect(tutorialWorld, 1, 23)
				bot.auto_collect = true
				sleep(100)
			end
		elseif Break_Other_World == "NO" then
			return
		end
	else
		reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
		breakOtherWorld()
	end
end

function whitelistWorld()
	reconnect(Whitelist_World, 1, 23)
	
	if not bot:isInWorld(Whitelist_World) then  
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Whitelist_World .. "|" .. Whitelist_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			
			local maxJoinWorld = 0
			while not bot:isInWorld(Whitelist_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Whitelist_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Whitelist_World .. "|" .. Whitelist_Door_ID)
				addEvent(Event.variantlist, worldBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Whitelist_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Whitelist_World, 1, 23)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Whitelist_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Whitelist_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Whitelist_World .. "|" .. Whitelist_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the whitelist door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the whitelist door ID is wrong.")
				end
			end
			
			reconnect(Whitelist_World, 1, 23)
		else
			reconnect(Whitelist_World, 1, 23)
			whitelistWorld()	
		end
	elseif bot:isInWorld(Whitelist_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Whitelist_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Whitelist_World, 1, 23)
			bot.auto_collect = false
			sleep(100)
			bot:warp(Whitelist_World .. "|" .. Whitelist_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 5 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the whitelist door ID is wrong."
				)
				maxJoinWorld = 0
				autoRecon = false
				noStopScript = false
				removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the whitelist door ID is wrong.")
			end
		end
	end
end

function questWorld()
	reconnect(randomWorldQuest(), 1, 23)
	
	if not bot:isInWorld(randomWorldQuest()) then
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			local maxJoinWorld = 0
			while not bot:isInWorld(randomWorldQuest()) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(randomWorldQuest(), 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(randomWorldQuest())
				addEvent(Event.variantlist, tutorialQuestEvent)
				listenEvents(8)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(randomWorldQuest()) then
						bot:disconnect()
						sleep(100)
						reconnect(randomWorldQuest(), 1, 23)
					end
				end
			end
			
			if bot:isInWorld("DISNEYLAND") then
				cachedWorldQuest = nil
				questWorld()
			end
			
			while bot:isInWorld(randomWorldQuest()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg ~= 6 do
				bot:respawn()
				sleep(1000)
			end
			
			if bot:isInWorld(randomWorldQuest()) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and world:hasAccess(bot.x, bot.y) == 0 then
				cachedWorldQuest = nil
				questWorld()
			end
			
			reconnect(randomWorldQuest(), 1, 23)
			if bot:isInWorld(randomWorldQuest()) then
				bot.auto_collect = true
				sleep(100)
			else
				questWorld()
			end
		else
			reconnect(randomWorldQuest(), 1, 23)
			questWorld()
		end
	end
end

function cookWorld()
	reconnect(Cook_World, X_Cook, Y_Cook)
	
	if not bot:isInWorld(Cook_World) then  
		bot.auto_collect = false
		sleep(100)
		bot:sendPacket(3, "action|quit_to_exit")
		sleep(1000)
		
		if bot.status == BotStatus.online and bot.auto_collect == false then
			bot:warp(Cook_World .. "|" .. Cook_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			
			local maxJoinWorld = 0
			while not bot:isInWorld(Cook_World) and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Cook_World, X_Cook, Y_Cook)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Cook_World .. "|" .. Cook_Door_ID)
				addEvent(Event.variantlist, worldBannedEvent)
				listenEvents(10)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				while maxJoinWorld >= 5 do
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
						"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
					)
					sleep(Hard_Warp_Join_World_Delay)
					maxJoinWorld = 0
					if not bot:isInWorld(Cook_World) then
						bot:disconnect()
						sleep(100)
						reconnect(Cook_World, X_Cook, Y_Cook)
					end
				end
			end
			
			local maxJoinWorld = 0
			while bot:isInWorld(Cook_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
				reconnect(Cook_World, 1, 23)
				bot.auto_collect = false
				sleep(100)
				bot:warp(Cook_World .. "|" .. Cook_Door_ID)
				sleep(Join_World_Delay)
				changingSubserver()
				maxJoinWorld = maxJoinWorld + 1
				if maxJoinWorld >= 5 then
					changingSubserver()
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the cook door ID is wrong."
					)
					maxJoinWorld = 0
					autoRecon = false
					noStopScript = false
					removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the cook door ID is wrong.")
				end
			end
			
			reconnect(Cook_World, X_Cook, Y_Cook)
		else
			reconnect(Cook_World, X_Cook, Y_Cook)
			cookWorld()	
		end
	elseif bot:isInWorld(Cook_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 then
		local maxJoinWorld = 0
		while bot:isInWorld(Cook_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6 and maxJoinWorld < 5 and noStopScript == true do
			reconnect(Cook_World, X_Cook, Y_Cook)
			bot.auto_collect = false
			sleep(100)
			bot:warp(Cook_World .. "|" .. Cook_Door_ID)
			sleep(Join_World_Delay)
			changingSubserver()
			maxJoinWorld = maxJoinWorld + 1
			if maxJoinWorld >= 5 then
				changingSubserver()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the cook door ID is wrong."
				)
				maxJoinWorld = 0
				autoRecon = false
				noStopScript = false
				removeBotIndex(Remove_Bot, bot.name:upper() .. " has tried to enter the door ID 5 times. Maybe the cook door ID is wrong.")
			end
		end
	end
end
---- [ END JOIN WORLD ] ----


---- [ LEVELING ] ----
function leveling()
	if Leveling_Status == "HARVEST" then
		return
	elseif Leveling_Status == "COOK" then
		autoCook()
	end
end
---- [ END LEVELING ] ----


---- [ AUTO COOK ] ----
function takeIngredients()
	if bot.status == BotStatus.online then
		local takeIngredients = false
			
		for _, item in pairs(Ingredients_ID) do
			if inventory:getItemCount(item) < Tile_Cook then
				takeIngredients = true
				break
			end
		end
		
		if takeIngredients then
			equipmentWorld()
			findpathEquipment(Ingredients_ID, Tile_Cook)
			dropEquipment(Ingredients_ID, Tile_Cook)
			autoConsume()
			hiddenWorld()
			cookWorld()
		end
	else
		reconnect(Cook_World, X_Cook, Y_Cook)
		takeIngredients()
	end
end

function performActionAutoCook()
	sleep(1000)
	banWaveEstimated()
	
	if bot:isInWorld(Cook_World) and bot:isInTile(X_Cook, Y_Cook) then
		if Set_Food == 1 then
			for _, tile in pairs(world:getTiles()) do
				if math.abs(tile.x - X_Cook) <= 2 and math.abs(tile.y - Y_Cook) <= 2 then
					if (tile.fg == 4618 or tile.fg == 4498 or tile.fg == 4620) and world:getTile(tile.x, tile.y):getExtra().ingredient_count > 0 then
						bot:hit(tile.x, tile.y)
						sleep(400)
					end
				end
			end
			
			local arrozCurrentTime = os.time()
			local arrozCooldownRange = os.time() - 99600
			local arrozCooldown = 99600
			local arrozInterval = Tile_Cook * 800
			
			for _, tile in pairs(ovenTile) do
				if world:getTile(tile.x, tile.y):getExtra().ingredient_count == 0 then 
					bot:place(tile.x, tile.y, 3472)
					bot:sendPacket(2, "action|dialog_return\ndialog_name|oven\ntilex|".. tile.x .."|\ntiley|".. tile.y .."|\ncookthis|".. 3472 .."|\nbuttonClicked|low\n\n\ndisplay_timer|0")
					sleep(800)
				end
			end
			
			sleep(33300 - arrozInterval)
			
			for _, tile in pairs(ovenTile) do
				bot:place(tile.x, tile.y, 4602)
				sleep(400)
				bot:place(tile.x, tile.y, 4588)
				sleep(400)
			end
			
			sleep(36700 - arrozInterval)
			
			for _, tile in pairs(ovenTile) do
				bot:place(tile.x, tile.y, 962)
				sleep(800)
			end
			
			sleep(30000 - 600 - arrozInterval)
			
			if arrozCurrentTime - arrozCooldownRange >= arrozCooldown then
				for _, tile in pairs(ovenTile) do
					sleep(800)
					bot:hit(tile.x, tile.y, 962)
				end
			end
		end
	end
end

function autoCook()
	if bot.status == BotStatus.online then
		if Bot_Level_Rotation == true then
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Starting Auto Cook"
			)
			
			wearingSpecificItem()
			cookWorld()
					
			while bot.level < Min_Level do
				Start_Cooking = true
				
				ovenTile = {}
				if bot:isInWorld(Cook_World) then
					for _, tile in pairs(world:getTiles()) do
						if math.abs(tile.x - X_Cook) <= 2 and math.abs(tile.y - Y_Cook) <= 2 then
							if (tile.fg == 4618 or tile.fg == 4498 or tile.fg == 4620) and world:getTile(tile.x, tile.y):getExtra().ingredient_count == 0 then
								table.insert(ovenTile, {x = tile.x, y = tile.y})
							end
						end
					end
				end
				
				Tile_Cook = #ovenTile
				dropItemWhitelist(1)
				takeIngredients()
				
				while not bot:isInWorld(Cook_World) or (bot:isInWorld(Cook_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6) do
					reconnect(Cook_World, X_Cook, Y_Cook)	
					cookWorld()
				end

				while not bot:isInTile(X_Cook, Y_Cook) and #bot:getPath(X_Cook, Y_Cook) > 0 do
					reconnect(Cook_World, X_Cook, Y_Cook)
					findpath(X_Cook, Y_Cook)
				end
				
				webhookShareInfoAllBot()
				performActionAutoCook()
			end
			
			if bot.level >= Min_Level then
				Bot_Level_Rotation = false
				local leftoverIngredients = false
				local canDropItemWhitelist = false
				
				for _, whitelist in pairs(Item_Whitelist_ID) do
					if inventory:getItemCount(whitelist) >= maxDrop then
						canDropItemWhitelist = true
						break
					end
				end
				
				if canDropItemWhitelist then
					dropItemWhitelist(1)
				end
				
				for _, item in pairs(Ingredients_ID) do
					if inventory:getItemCount(item) > 0 then
						leftoverIngredients = true
						break
					end
				end
				
				if leftoverIngredients then
					equipmentWorld()
					dropEquipment(Ingredients_ID, 0)
					hiddenWorld()
					farmWorld()
				end
				
				Start_Cooking = false
				webhookShareInfoAllBot()
				webhookShareInfoBot(
					"**[ BOT INFORMATION ]** \n" ..
					"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
					":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
					"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
					"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
					"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
					"<a:toa:997296837352505415> **|** Bot Information: Finished Auto Cook"
				)
				main()
			end
		end
	
		if Only_Cook_At_Specific_Level == "YES" and Bot_Level_Rotation == false then
			if TotalSpecifiedLevelList > 0 then
				local validCook = nil
				
				for _, specifiedLevel in pairs(Specified_Level) do
					if bot.level > specifiedLevel then
						table.remove(Specified_Level, 1)
						TotalSpecifiedLevelList = #Specified_Level
						validCook = false
						break
					elseif bot.level == specifiedLevel then
						validCook = true
						checkSpecifiedLevel = specifiedLevel
						break
					end
				end
				
				if validCook == true then
					webhookShareInfoBot(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Starting Auto Cook"
					)
					
					wearingSpecificItem()
					cookWorld()
					
					while bot.level == checkSpecifiedLevel do
						Start_Cooking = true
						
						ovenTile = {}
						if bot:isInWorld(Cook_World) then
							for _, tile in pairs(world:getTiles()) do
								if math.abs(tile.x - X_Cook) <= 2 and math.abs(tile.y - Y_Cook) <= 2 then
									if (tile.fg == 4618 or tile.fg == 4498 or tile.fg == 4620) and world:getTile(tile.x, tile.y):getExtra().ingredient_count == 0 then
										table.insert(ovenTile, {x = tile.x, y = tile.y})
									end
								end
							end
						end
						
						Tile_Cook = #ovenTile
						dropItemWhitelist(1)
						takeIngredients()
						
						while not bot:isInWorld(Cook_World) or (bot:isInWorld(Cook_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6) do
							reconnect(Cook_World, X_Cook, Y_Cook)	
							cookWorld()
						end

						while not bot:isInTile(X_Cook, Y_Cook) and #bot:getPath(X_Cook, Y_Cook) > 0 do
							reconnect(Cook_World, X_Cook, Y_Cook)
							findpath(X_Cook, Y_Cook)
						end

						webhookShareInfoAllBot()
						performActionAutoCook()
					end
					
					if bot.level > checkSpecifiedLevel then
						local leftoverIngredients = false
						local canDropItemWhitelist = false
						
						for _, whitelist in pairs(Item_Whitelist_ID) do
							if inventory:getItemCount(whitelist) >= maxDrop then
								canDropItemWhitelist = true
								break
							end
						end
						
						if canDropItemWhitelist then
							dropItemWhitelist(1)
						end
						
						for _, item in pairs(Ingredients_ID) do
							if inventory:getItemCount(item) > 0 then
								leftoverIngredients = true
								break
							end
						end
						
						if leftoverIngredients then
							equipmentWorld()
							dropEquipment(Ingredients_ID, 0)
							hiddenWorld()
						end
						
						Start_Cooking = false
						webhookShareInfoAllBot()
						webhookShareInfoBot(
							"**[ BOT INFORMATION ]** \n" ..
							"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
							":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
							"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
							"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
							"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
							"<a:toa:997296837352505415> **|** Bot Information: Finished Auto Cook"
						)
						main()
					end
				elseif validConsume == false then
					autoCook()
				end
			end
		elseif Only_Cook_Until_Minimum_Level == "YES" and Bot_Level_Rotation == false and bot.level < Min_Level then
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Starting Auto Cook"
			)
			
			wearingSpecificItem()
			cookWorld()
			
			while bot.level < Min_Level do
				Start_Cooking = true
				
				ovenTile = {}
				if bot:isInWorld(Cook_World) then
					for _, tile in pairs(world:getTiles()) do
						if math.abs(tile.x - X_Cook) <= 2 and math.abs(tile.y - Y_Cook) <= 2 then
							if (tile.fg == 4618 or tile.fg == 4498 or tile.fg == 4620) and world:getTile(tile.x, tile.y):getExtra().ingredient_count == 0 then
								table.insert(ovenTile, {x = tile.x, y = tile.y})
							end
						end
					end
				end
				
				Tile_Cook = #ovenTile
				dropItemWhitelist(1)
				takeIngredients()
				
				while not bot:isInWorld(Cook_World) or (bot:isInWorld(Cook_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 6) do
					reconnect(Cook_World, X_Cook, Y_Cook)	
					cookWorld()
				end

				while not bot:isInTile(X_Cook, Y_Cook) and #bot:getPath(X_Cook, Y_Cook) > 0 do
					reconnect(Cook_World, X_Cook, Y_Cook)
					findpath(X_Cook, Y_Cook)
				end
				
				webhookShareInfoAllBot()
				performActionAutoCook()
			end
			
			if bot.level >= Min_Level then
				local leftoverIngredients = false
				local canDropItemWhitelist = false
				
				for _, whitelist in pairs(Item_Whitelist_ID) do
					if inventory:getItemCount(whitelist) >= maxDrop then
						canDropItemWhitelist = true
						break
					end
				end
				
				if canDropItemWhitelist then
					dropItemWhitelist(1)
				end
				
				for _, item in pairs(Ingredients_ID) do
					if inventory:getItemCount(item) > 0 then
						leftoverIngredients = true
						break
					end
				end
				
				if leftoverIngredients then
					equipmentWorld()
					dropEquipment(Ingredients_ID, 0)
					hiddenWorld()
				end
				
				Start_Cooking = false
				webhookShareInfoAllBot()
				webhookShareInfoBot(
					"**[ BOT INFORMATION ]** \n" ..
					"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
					":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
					"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
					"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
					"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
					"<a:toa:997296837352505415> **|** Bot Information: Finished Auto Cook"
				)
				main()
			end
		end
	elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
		reconnect(Cook_World, X_Cook, Y_Cook)
		autoCook()
	end
end
---- [ END AUTO COOK ] ----


---- [ LEVEL CHECK ] ----
function levelCheck()
	if Change_Bot_On_Max_Level == "YES" and bot.level >= Max_Level then
		dropExceedPackGoOffline()
		
		while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
			seedWorld()
			dropSeed()
			while inventory:getItemCount(Block_ID) > 0 do
				dropBlock()
			end
		end
		
		while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
			pickaxeWorld()
			while not bot:isInTile(44, 13) do
				findpath(44, 13)
			end
			dropItem(Pickaxe_ID)
			if inventory:getItemCount(Pickaxe_ID) == 0 then
				webhookShareInfoDropped(
					"**[ BOT INFORMATION ]** \n" ..
					"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
					":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
					"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
					"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
					"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
					"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
					
					"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
					"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
					":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
					getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
				)
			end
		end
		
		dropEquipmentBeforeOfffline()
		hiddenWorld()
		
		autoRecon = false
		bot:disconnect()
		sleep(100)
		webhookShareInfoAllBot()
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[Max Level]` \n" .. 
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
		)
		removeBotLogFile(bot.name:upper(), "Max Level")
		if Change_Bot == "YES" then
			table.remove(Bot_List_Result, botStartNumber)
			totalBotList = #Bot_List_Result
			botStartNumber = botStartNumber - 1
			changeBotStatus()
		elseif Change_Bot == "NO" then
			noStopScript = false
			removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
		end
	elseif Change_Bot_On_Max_Level == "NO" then 
		return
	end
end
---- [ END LEVEL CHECK ] ----


---- [ UPGRADE BACKPACK ] ----
function upgradeBackpackPrice()
	if inventory.slotcount == 16 then
		return 100
	elseif inventory.slotcount == 26 then
		return 200
	elseif inventory.slotcount == 36 then
		return 500
	elseif inventory.slotcount == 46 then
		return 1000
	elseif inventory.slotcount == 56 then
		return 1700
	elseif inventory.slotcount == 66 then
		return 2600
	elseif inventory.slotcount == 76 then
		return 3700
	elseif inventory.slotcount == 86 then
		return 5000
	elseif inventory.slotcount == 96 then
		return 6500
	elseif inventory.slotcount == 106 then
		return 8200
	else 
		return 999999999999
	end
end

function upgradeBackpack()
	local remainingBackpackSlots = inventory.slotcount - inventory.itemcount
	
	if remainingBackpackSlots >= 1 then
		return
	else
		if bot.gem_count >= upgradeBackpackPrice() then
			bot:buy("upgrade_backpack")
			sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
		else
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " gems are less than " .. upgradeBackpackPrice() .. "."
			)
		end
	end
end 

function upgradeBackpackForBuyPack()
	local remainingBackpackSlots = inventory.slotcount - inventory.itemcount
	
	if remainingBackpackSlots >=  #Pack_ID then
		return
	else
		if bot.gem_count >= upgradeBackpackPrice() then
			bot:buy("upgrade_backpack")
			sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
		else
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " gems are less than " .. upgradeBackpackPrice() .. "."
			)
		end
	end
end 

function upgradeBackpackForTakeEquipment(variable)
	local remainingBackpackSlots = inventory.slotcount - inventory.itemcount
	
	if remainingBackpackSlots >= #variable then
		return
	else
		if bot.gem_count >= upgradeBackpackPrice() then
			bot:buy("upgrade_backpack")
			sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
		else
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " gems are less than " .. upgradeBackpackPrice() .. "."
			)
		end
	end
end 

function upgradeBackpackForRareClothesPack()
	local remainingBackpackSlots = inventory.slotcount - inventory.itemcount
	
	if remainingBackpackSlots >= 3 then
		return
	else
		if bot.gem_count >= upgradeBackpackPrice() then
			bot:buy("upgrade_backpack")
			sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
		else
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " gems are less than " .. upgradeBackpackPrice() .. "."
			)
		end
	end
end 
---- [ END UPGRADE BACKPACK ] ----


---- [ SHOW ANIMATION ] ----
function showPunchAnimation()
	if Show_Punch_Animation == "YES" then
		return true
	elseif Show_Punch_Animation == "NO" then
		return false
	end
end

function showMoveAnimation()
	if Show_Move_Animation == "YES" then
		return true
	elseif Show_Move_Animation == "NO" then
		return false
	end
end
---- [ END SHOW ANIMATION ] ----


---- [ FINDPATH ANIMATION ] ----
function leftAnimation(var1, var2)
	if bot.status == BotStatus.online and showMoveAnimation() and getInfo(world:getTile(bot.x, bot.y + 1).fg).collision_type == 1 then
		if actionRotationAndFindpathAnimation == false then
			local pkt = GameUpdatePacket.new()
			pkt.flags = 48
			pkt.vec_x = (world:getLocal().posx)
			pkt.vec_y = (world:getLocal().posy)
			if not bot:isInTile(var1, var2) then
				pkt.vec2_x = (math.random(-250, -200))
				pkt.vec2_y = 0
			elseif bot:isInTile(var1, var2) then
				pkt.vec2_x = 0
				pkt.vec2_y = 0
			end
			pkt.int_x = -1
			pkt.int_y = -1

			sleep(50)
			bot:sendRaw(pkt)
		end
	else
		return
	end
end

function rightAnimation(var1, var2)
	if bot.status == BotStatus.online and showMoveAnimation() and getInfo(world:getTile(bot.x, bot.y + 1).fg).collision_type == 1 then
		if actionRotationAndFindpathAnimation == false then
			local pkt = GameUpdatePacket.new()
			pkt.flags = 32
			pkt.vec_x = (world:getLocal().posx)
			pkt.vec_y = (world:getLocal().posy)
			if not bot:isInTile(var1, var2) then
				pkt.vec2_x = (math.random(200, 250))
				pkt.vec2_y = 0
			elseif bot:isInTile(var1, var2) then
				pkt.vec2_x = 0
				pkt.vec2_y = 0
			end
			pkt.int_x = -1
			pkt.int_y = -1
			
			sleep(50)
			bot:sendRaw(pkt)
		end
	else
		return
	end
end

function upAnimation(var1, var2)
	if bot.status == BotStatus.online and showMoveAnimation() then
		if actionRotationAndFindpathAnimation == false then
			local pkt = GameUpdatePacket.new()
			if bot.x >= var1 then
				pkt.flags = 144
				lastFlags = 48
			elseif bot.x <= var1 then
				pkt.flags = 128
				lastFlags = 32
			end
			pkt.vec_x = (world:getLocal().posx)
			pkt.vec_y = (world:getLocal().posy)
			if not bot:isInTile(var1, var2) then
				pkt.vec2_x = 0
				pkt.vec2_y = (math.random(-450, -440))
			elseif bot:isInTile(var1, var2) then
				pkt.flags = lastFlags
				pkt.vec2_x = 0
				pkt.vec2_y = 0
			end
			pkt.int_x = -1
			pkt.int_y = -1

			sleep(50)
			bot:sendRaw(pkt)
		end
	else
		return
	end
end

function downAnimation(var1, var2)
	if bot.status == BotStatus.online and showMoveAnimation() then
		if actionRotationAndFindpathAnimation == false then
			local pkt = GameUpdatePacket.new()
			if onlySendOneFlags < 1 then
				onlySendOneFlags = onlySendOneFlags + 1
				if bot.x >= var1 then
					pkt.flags = 16
					lastFlags = 48
				elseif bot.x <= var1 then
					pkt.flags = 0
					lastFlags = 32
				end
			end
			pkt.vec_x = (world:getLocal().posx)
			pkt.vec_y = (world:getLocal().posy)
			if not bot:isInTile(var1, var2) then
				pkt.vec2_x = 0
				pkt.vec2_y = 40
				onlySendOneFlags = 0
			elseif bot:isInTile(var1, var2) then
				pkt.flags = lastFlags
				pkt.vec2_y = (math.random(-20, -10))
				pkt.vec2_x = 0
				pkt.vec2_y = 0
				onlySendOneFlags = 0
			end
			pkt.int_x = -1
			pkt.int_y = -1

			sleep(50)
			bot:sendRaw(pkt)
		end
	else
		return
	end
end
---- [ END FINDPATH ANIMATION ] ----


---- [ FINDPATH ] ----
function findpathMoveSpeedHelping()
	if actionRotationAndFindpathAnimation == true then
		Move_Speed = Move_Speed_2
	else
		Move_Speed = Move_Speed_1
	end
end

function findpath(variableX, variableY)
	bot:getLog():append("Action: findpath")
	findpathMoveSpeedHelping()
	path = bot:getPath(variableX, variableY)
	local defaultWorldName = world.name:upper()
	
	if bot.status == BotStatus.online then
		if #bot:getPath(variableX, variableY) == 0 and bot:isInTile(variableX, variableY) then
			reconnect(defaultWorldName, variableX, variableY)
			return
		elseif #bot:getPath(variableX, variableY) == 0 and not bot:isInTile(variableX, variableY) then
			local sendWebhookAmount = 0
			while #bot:getPath(variableX, variableY) == 0 and not bot:isInTile(variableX, variableY) do
				if sendWebhookAmount < 1 then
					webhookShareInfoBot( 
						"<a:toa:997296837352505415> **|** The bot cannot access to tile path [" .. variableX .. ", " .. variableY .. "]."
					)
					sendWebhookAmount = sendWebhookAmount + 1
				end
				
				local maxJoinWorld = 0
				while not bot:isInWorld(defaultWorldName) and maxJoinWorld < 5 and noStopScript == true do
					bot:warp(defaultWorldName)
					sleep(Join_World_Delay)
					changingSubserver()
					maxJoinWorld = maxJoinWorld + 1
					if maxJoinWorld >= 5 then
						webhookShareInfoBot(
							"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " has tried to enter the world 5 times. \n" ..
							"<:Luxurious_Wall_Clock:1190695156333150258> **|** Cooldown: " .. convertMillisecondsToHours(Hard_Warp_Join_World_Delay)
						)
						sleep(Hard_Warp_Join_World_Delay)
						maxJoinWorld = 0
					end
				end
				reconnect(defaultWorldName, variableX, variableY)
				sleep(1000)
			end
			findpath(variableX, variableY)
		elseif #bot:getPath(variableX, variableY) > 0 then
			if bot.status == BotStatus.online then
				onlySendOneFlags = 0
				for i = 1, #path do
					if bot.status == BotStatus.online and i % Move_Range == 0 then
						posBotX = bot.x
						posBotY = bot.y
						bot:moveTile(path[i].x, path[i].y)
						if posBotY > path[i].y then
							upAnimation(variableX, variableY)
						elseif posBotY < path[i].y then
							downAnimation(variableX, variableY)
						elseif posBotX > path[i].x then
							leftAnimation(variableX, variableY)
						elseif posBotX < path[i].x then
							rightAnimation(variableX, variableY)
						end
						sleep(math.random(Move_Speed, Move_Speed + 10))
					elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
						reconnect(defaultWorldName, variableX, variableY)
					end
				end
			else
				reconnect(defaultWorldName, variableX, variableY)
				findpath(variableX, variableY)
			end
				
			if bot.status == BotStatus.online then
				posBotX = bot.x
				posBotY = bot.y
				
				bot:moveTile(path[#path].x, path[#path].y)
				if posBotY > path[#path].y then
					upAnimation(variableX, variableY)
				elseif posBotY < path[#path].y then
					downAnimation(variableX, variableY)
				elseif posBotX > path[#path].x then
					leftAnimation(variableX, variableY)
				elseif posBotX < path[#path].x then
					rightAnimation(variableX, variableY)
				end
				sleep(math.random(Move_Speed, Move_Speed + 10))
				actionRotationAndFindpathAnimation = false
			else
				reconnect(defaultWorldName, variableX, variableY)
				findpath(variableX, variableY)
			end
		else
			reconnect(defaultWorldName, variableX, variableY)
			findpath(variableX, variableY)
		end
	end
end
---- [ END FINDPATH ] ----


----[ FINDPATH BREAK ] ----
function findpathBreak()
	if bot.status == BotStatus.online then
		reconnect(Rotation_World, X_Break, Y_Break)
		findpath(X_Break, Y_Break)
		while math.floor(world:getLocal().posx / 32) ~= X_Break and math.floor(world:getLocal().posy / 32) ~= Y_Break do
			reconnect(Rotation_World, X_Break, Y_Break)
			findpath(X_Break, Y_Break)
		end
	else
		reconnect(Rotation_World, X_Break, Y_Break)
		findpathBreak()
	end
end

function findpathBreakOtherWorld()
	if bot.status == BotStatus.online then
		local defaultWorldName = world.name:upper()
		
		if (Use_Custom_World_For_Break == "YES" or Use_Tutorial_World_For_Break == "YES") then
			reconnect(defaultWorldName, X_Break, Y_Break)
			findpath(X_Break, Y_Break)
			while math.floor(world:getLocal().posx / 32) ~= X_Break and math.floor(world:getLocal().posy / 32) ~= Y_Break do
				reconnect(defaultWorldName, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			end
		elseif Use_Random_World_For_Break == "YES" then
			reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			findpath(breakOtherWorldX, breakOtherWorldY)
			while math.floor(world:getLocal().posx / 32) ~= breakOtherWorldX and math.floor(world:getLocal().posy / 32) ~= breakOtherWorldY do
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
				findpath(breakOtherWorldX, breakOtherWorldX)
			end
		end
	else
		reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
		findpathBreakOtherWorld()
	end
end
----[ END FINDPATH BREAK ] ----


---- [ DROP ITEM ] ----
function dropItem(itemID)
	bot:setDirection(false)
	sleep(100)
	bot:drop(itemID, inventory:getItemCount(itemID))
	sleep(math.random(Drop_Delay, Drop_Delay + 100))
end

local markerTilesCache = {}
function markerScan(itemID)
	if markerTilesCache[itemID] and nextDropWorld == "NO" then
		return markerTilesCache[itemID]
	end
	
	local markerTiles = {}
	for _, tile in pairs(world:getTiles()) do 
		if bot.status == BotStatus.online then
			if (tile.fg == itemID and #bot:getPath(tile.x, tile.y) > 0) or (tile.bg == itemID and #bot:getPath(tile.x, tile.y) > 0) then
				local markerTile = {x = tile.x, y = tile.y}
				table.insert(markerTiles, markerTile)
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
			
			if (tile.fg == itemID and #bot:getPath(tile.x, tile.y) > 0) or (tile.bg == itemID and #bot:getPath(tile.x, tile.y) > 0) then
				local markerTile = {x = tile.x, y = tile.y}
				table.insert(markerTiles, markerTile)
			end
		end
	end
	markerTilesCache[itemID] = markerTiles
	return markerTiles
end

function dropPack()
	bot:getLog():append("Action: dropPack")
	dropPackStatus = true
	webhookShareInfoAllBot()
    bot.auto_collect = false
	sleep(100)
	
	if bot.status == BotStatus.online then
		reconnect(Save_Pack_World, 1, 23)
		local markerTiles = markerScan(Drop_Pack_Marker)
		local Start_Drop = #markerTiles
		local nextMarkerTile = markerTiles[Start_Drop]
		if #markerTiles > 0 then
			nextDropWorld = "NO"
			
			findpath(nextMarkerTile.x, nextMarkerTile.y)
			while bot.status == BotStatus.online and not bot:isInTile(nextMarkerTile.x, nextMarkerTile.y) do
				sleep(25000)
				reconnect(Save_Pack_World, 1, 23)
				findpath(nextMarkerTile.x, nextMarkerTile.y)
			end
			
			dropItem(5030)
			while inventory:getItemCount(5030) > 0 do
				reconnect(Save_Pack_World, 1, 23)
				table.remove(markerTiles, Start_Drop)
				Start_Drop = #markerTiles
				bot:moveUp(1)
				sleep(100)
				dropItem(5030)
			end
			if inventory:getItemCount(5030) == 0 then 
				bot:moveRight(1)
				sleep(100)
			end
			
			for _, pack in pairs(Pack_ID) do
				reconnect(Save_Pack_World, 1, 23)
				while bot.status == BotStatus.online and inventory:getItemCount(pack) > 0 do
					reconnect(Save_Pack_World, 1, 23)
					dropItem(pack)
					if inventory:getItemCount(pack) > 0 then
						reconnect(Save_Pack_World, 1, 23)
						table.remove(markerTiles, Start_Drop)
						Start_Drop = #markerTiles
						bot:moveUp(1)
						sleep(100)
					end
				end
				if inventory:getItemCount(pack) == 0 then 
					bot:moveRight(1)
					sleep(100)
				end
			end
			reconnect(Save_Pack_World, 1, 23)
			scanFloatTotalPack()
			dropPackStatus = false
		else
			webhookShareInfoAllBot()
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[Your Storage Pack Is Full]`"
			)
			
			nextDropWorld = "YES"
			table.remove(Save_Pack_World_List_Result, 1)
			totalSavePackWorldList = #Save_Pack_World_List_Result
			if totalSavePackWorldList == 0 then
				removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a save pack world list.")
			end
			Save_Pack_World = Save_Pack_World_List_Result[1][1]:upper()
			Save_Pack_Door_ID = Save_Pack_World_List_Result[1][2]:upper()
			if Save_Pack_Door_ID == "-" then
				Save_Pack_Door_ID = ""
			end
			Drop_Pack_Marker = tonumber(Save_Pack_World_List_Result[1][3])
			
			packWorld()
			dropPack()
		end
	else
		reconnect(Save_Pack_World, 1, 23)
		dropPack()
	end
end

function scanFloatTotalPack()
	dropPackCount = ""
	dropPackCountTable = {}
	for _, packlist in pairs(Pack_ID) do
		dropPackCount = dropPackCount .. " \n" .. getItemName(packlist) .. ": " .. objectGrowScan(packlist)
		table.insert(dropPackCountTable, " \n" .. getItemName(packlist) .. ": " .. objectGrowScan(packlist))
		sleep(100)
	end
	webhookShareInfoDropped(
		"**[ BOT INFORMATION ]** \n" .. 
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" .. 
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" .. 
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<a:toa:997296837352505415> **|** Bot Information: Dropping Pack \n\n" .. 
		
		"**[ WORLD INFORMATION ]** \n" ..
		"<:Globe:1190695520210006036> **|** Pack World: `" .. world.name:upper() .. "` \n" .. 
		":package: **|** Total Pack Dropped:" .. 
		dropPackCount
	)
end

function dropWhitelist()
	bot:getLog():append("Action: dropWhitelist")
	dropWhitelistStatus = true
	webhookShareInfoAllBot()
    bot.auto_collect = false
	sleep(100)
	
	if bot.status == BotStatus.online then
		reconnect(Whitelist_World, 1, 23)
		local markerTiles = markerScan(Drop_Whitelist_Marker)
		local Start_Drop = #markerTiles
		local nextMarkerTile = markerTiles[Start_Drop]
		if #markerTiles > 0 then
			nextDropWorld = "NO"
			
			findpath(nextMarkerTile.x, nextMarkerTile.y)
			while bot.status == BotStatus.online and not bot:isInTile(nextMarkerTile.x, nextMarkerTile.y) do
				sleep(25000)
				reconnect(Whitelist_World, 1, 23)
				findpath(nextMarkerTile.x, nextMarkerTile.y)
			end
			
			for _, whitelist in pairs(Item_Whitelist_ID) do
				reconnect(Whitelist_World, 1, 23)
				while bot.status == BotStatus.online and inventory:getItemCount(whitelist) > 0 do
					reconnect(Whitelist_World, 1, 23)
					dropItem(whitelist)
					if inventory:getItemCount(whitelist) > 0 then
						reconnect(Whitelist_World, 1, 23)
						table.remove(markerTiles, Start_Drop)
						Start_Drop = #markerTiles
						bot:moveUp(1)
						sleep(100)
					end
				end
			end
			reconnect(Whitelist_World, 1, 23)
			scanFloatTotalWhitelist()
			dropWhitelistStatus = false
		else
			webhookShareInfoAllBot()
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Whitelist World: `" .. Whitelist_World .. "` \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[Your Storage Whitelist Is Full]`"
			)
			
			nextDropWorld = "YES"
			table.remove(Whitelist_World_List_Result, 1)
			totalWhitelistWorldList = #Whitelist_World_List_Result
			if totalWhitelistWorldList == 0 then
				removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a whitelist world list.")
			end
			Whitelist_World = Whitelist_World_List_Result[1][1]:upper()
			Whitelist_Door_ID = Whitelist_World_List_Result[1][2]:upper()
			if Whitelist_Door_ID == "-" then
				Whitelist_Door_ID = ""
			end
			Drop_Whitelist_Marker = tonumber(Whitelist_World_List_Result[1][3])
			
			whitelistWorld()
			dropWhitelist()
		end
	else
		reconnect(Whitelist_World, 1, 23)
		dropWhitelist()
	end
end

function scanFloatTotalWhitelist()
	bot:getLog():append("Action: scanFloatTotalWhitelist")
	dropItemWhitelistCount = ""
	for _, whitelist in pairs(Item_Whitelist_ID) do
		dropItemWhitelistCount = dropItemWhitelistCount .. " \n" .. getItemName(whitelist) .. ": " .. objectGrowScan(whitelist)
		sleep(100)
	end
	webhookShareInfoDropped(
		"**[ BOT INFORMATION ]** \n" .. 
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" .. 
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" .. 
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<a:toa:997296837352505415> **|** Bot Information: Dropping Item Whitelist \n\n" .. 
		
		"**[ WORLD INFORMATION ]** \n" ..
		"<:Globe:1190695520210006036> **|** Whitelist World: `" .. world.name:upper() .. "` \n" .. 
		":package: **|** Total Item Whitelist Dropped:" .. 
		dropItemWhitelistCount
	)
end

function dropSeed()
	bot:getLog():append("Action: dropSeed")
	dropSeedBlockStatus = true
	webhookShareInfoAllBot()
    bot.auto_collect = false
	sleep(100)
	
	if bot.status == BotStatus.online then
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		local markerTiles = markerScan(Drop_Seed_Marker)
		local Start_Drop = #markerTiles
		local nextMarkerTile = markerTiles[Start_Drop]
		if #markerTiles > 0 then
			nextDropWorld = "NO"
			
			findpath(nextMarkerTile.x, nextMarkerTile.y)
			while bot.status == BotStatus.online and not bot:isInTile(nextMarkerTile.x, nextMarkerTile.y) do
				sleep(25000)
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				findpath(nextMarkerTile.x, nextMarkerTile.y)
			end
			
			while bot.status == BotStatus.online and inventory:getItemCount(Seed_ID) > 0 do
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				dropItem(Seed_ID)
				if inventory:getItemCount(Seed_ID) > 0 then
					reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
					table.remove(markerTiles, Start_Drop)
					Start_Drop = #markerTiles
					bot:moveUp(1)
					sleep(100)
				end
			end
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n"  ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Dropping Seed \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Seed World: `" .. world.name:upper() .. "` \n" ..
				"<:Laser_Grid_Seed:1190695138947760249> **|** Total Seed Dropped: \n" ..
				getItemName(Seed_ID) .. ": " .. objectGrowScan(Seed_ID)
			)
			dropSeedCount = objectGrowScan(Seed_ID)
			dropSeedBlockStatus = false
		else
			webhookShareInfoAllBot()
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Your Storage Seed Is Full]`"
			)
			
			nextDropWorld = "YES"
			table.remove(Save_Seed_World_List_Result, 1)
			totalSaveSeedWorldList = #Save_Seed_World_List_Result
			if totalSaveSeedWorldList == 0 then
				removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a save seed world list.")
			end
			Save_Seed_World = Save_Seed_World_List_Result[1][1]:upper()
			Save_Seed_Door_ID = Save_Seed_World_List_Result[1][2]:upper()
			if Save_Seed_Door_ID == "-" then
				Save_Seed_Door_ID = ""
			end
			Drop_Seed_Marker = tonumber(Save_Seed_World_List_Result[1][3])
			
			seedWorld()
			dropSeed()
		end
	else
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		dropSeed()
	end
end

function dropBlock()
	bot:getLog():append("Action: dropBlock")
	dropSeedBlockStatus = true
	webhookShareInfoAllBot()
	bot.auto_collect = false
	sleep(100)
		
	if bot.status == BotStatus.online then
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		local markerTiles = markerScan(Drop_Seed_Marker)
		local Start_Drop = #markerTiles
		local nextMarkerTile = markerTiles[Start_Drop]
		if #markerTiles > 0 then
			nextDropWorld = "NO"
			
			findpath(nextMarkerTile.x + 1, nextMarkerTile.y)
			while bot.status == BotStatus.online and not bot:isInTile(nextMarkerTile.x + 1, nextMarkerTile.y) do
				sleep(25000)
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				findpath(nextMarkerTile.x + 1, nextMarkerTile.y)
			end
			
			while bot.status == BotStatus.online and inventory:getItemCount(Block_ID) > 0 do
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				dropItem(Block_ID)
				if inventory:getItemCount(Block_ID) > 0 then
					reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
					table.remove(markerTiles, Start_Drop)
					Start_Drop = #markerTiles
					bot:moveUp(1)
					sleep(100)
				end
			end
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "]\n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Dropping Block \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Block World: `" .. world.name:upper() .. "` \n" ..
				"<:Laser_Grid:1190695132236894258> **|** Total Block Dropped: \n" ..
				getItemName(Block_ID) .. ": " .. objectGrowScan(Block_ID)
			)
			dropBlockCount = objectGrowScan(Block_ID)
			dropSeedBlockStatus = false
		else
			webhookShareInfoAllBot()
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "]\n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Block World: `" .. Save_Seed_World .. "` \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Your Storage Block Is Full]`"
			)
			
			nextDropWorld = "YES"
			table.remove(Save_Seed_World_List_Result, 1)
			totalSaveSeedWorldList = #Save_Seed_World_List_Result
			if totalSaveSeedWorldList == 0 then
				removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a save seed world list.")
			end
			Save_Seed_World = Save_Seed_World_List_Result[1][1]:upper()
			Save_Seed_Door_ID = Save_Seed_World_List_Result[1][2]:upper()
			if Save_Seed_Door_ID == "-" then
				Save_Seed_Door_ID = ""
			end
			Drop_Seed_Marker = tonumber(Save_Seed_World_List_Result[1][3])
			
			seedWorld()
			dropSeed()
		end
	else
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		dropBlock()
	end
end

function dropEquipment(variable, equipmentDropCount)
	bot:getLog():append("Action: dropEquipment")
	webhookShareInfoAllBot()
	bot.auto_collect = false
	sleep(100)
		
	if bot.status == BotStatus.online then
		reconnect(Equipment_World, 1, 23)
		local markerTiles = markerScan(Drop_Equipment_Marker)
		local Start_Drop = #markerTiles
		local nextMarkerTile = markerTiles[Start_Drop]
		if #markerTiles > 0 then
			nextDropWorldWorld = "NO"
			
			findpath(nextMarkerTile.x, nextMarkerTile.y)
			while bot.status == BotStatus.online and not bot:isInTile(nextMarkerTile.x, nextMarkerTile.y) do
				sleep(25000)
				reconnect(Equipment_World, 1, 23)
				findpath(nextMarkerTile.x, nextMarkerTile.y)
			end
				
			for _, item in pairs(variable) do
				while bot.status == BotStatus.online and inventory:getItemCount(item) > equipmentDropCount do
					reconnect(Equipment_World, 1, 23)
					bot:setDirection(false)
					sleep(100)
					bot:drop(item, inventory:getItemCount(item) - equipmentDropCount)
					sleep(math.random(Drop_Delay, Drop_Delay + 100))
					
					if inventory:getItemCount(item) > equipmentDropCount then
						reconnect(Equipment_World, 1, 23)
						table.remove(markerTiles, Start_Drop)
						Start_Drop = #markerTiles
						bot:moveUp(1)
						sleep(100)
					end
				end
			end
			reconnect(Equipment_World, 1, 23)
			scanFloatTotalEquipment(variable)
		else
			webhookShareInfoAllBot()
			webhookShareInfoDropped(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "]\n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Equipment World: `" .. Equipment_World .. "` \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Your Storage Equipment Is Full]`"
			)
			
			nextDropWorld = "YES"
			table.remove(Equipment_World_List_Result, 1)
			totalEquipmentWorldList = #Equipment_World_List_Result
			if totalEquipmentWorldList == 0 then
				removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a equipment world list.")
			end
			Equipment_World = Equipment_World_List_Result[1][1]:upper()
			Equipment_Door_ID = Equipment_World_List_Result[1][2]:upper()
			if Equipment_Door_ID == "-" then
				Equipment_Door_ID = ""
			end
			Drop_Equipment_Marker = tonumber(Equipment_World_List_Result[1][3])
			
			equipmentWorld()
			dropEquipment(variable, equipmentDropCount)
		end
	else
		reconnect(Equipment_World, 1, 23)
		dropEquipment(variable, equipmentDropCount)
	end
end

function scanFloatTotalEquipment(variable)
	dropEquipmentCount = ""
	for _, packlist in pairs(variable) do
		dropEquipmentCount = dropEquipmentCount .. " \n" .. getItemName(packlist) .. ": " .. objectGrowScan(packlist)
		sleep(100)
	end
	webhookShareInfoDropped(
		"**[ BOT INFORMATION ]** \n" ..
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "]\n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<a:toa:997296837352505415> **|** Bot Information: Dropping Equipment \n\n" ..
		
		"**[ WORLD INFORMATION ]** \n" ..
		"<:Globe:1190695520210006036> **|** Equipment World: `" .. world.name:upper() .. "` \n" ..
		":package: **|** Total Equipment Dropped:" .. 
		dropEquipmentCount
	)
end
---- [ END DROP ] ----


---- [ TAKE ITEM ] ----
function performActionTakeItem(x, y, itemID)
	local pkt = GameUpdatePacket.new()
	pkt.type = 11
	pkt.int_data = itemID
	pkt.pos_x = x
	pkt.pos_y = y
	bot:sendRaw(pkt)
	sleep(200)
end

function takeItem(itemID)
	for _, obj in pairs(world:getObjects()) do
		if obj.id == itemID then
			if math.abs(bot.x - math.floor(obj.x / 32)) <= 4 and math.abs(bot.y - math.floor(obj.y / 32)) <= 4 then
				performActionTakeItem(obj.x, obj.y, obj.oid)
				break
			end
		end
	end
end
---- [ END TAKE ITEM ] ----


---- [ BUY PACK ] ----
function buyPack()
	bot:getLog():append("Action: buyPack")
	if bot.status == BotStatus.online then
		if Auto_Buy_Pack == "YES" then
			local maxBuy = 0
			local packExceed = false
			
			while bot.status == BotStatus.online and bot.gem_count >= Pack_Price and maxBuy < Max_Buy_Pack do
				reconnect(Save_Pack_World, 1, 23)
				maxBuy = maxBuy + 1
				upgradeBackpackForBuyPack()
				bot:buy(Pack_Name_To_Buy)
				sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
				for _, pack in pairs(Pack_ID) do
					if inventory:getItemCount(pack) >= Max_Pack_To_Drop then 
						packExceed = true
					end
				end
				
				if packExceed then
					break
				end
			end
			
			
			reconnect(Save_Pack_World, 1, 23)
			dropExceedPack()
		elseif Auto_Buy_Pack == "NO" then
			return
		end
	else
		reconnect(Save_Pack_World, 1, 23)
		buyPack()
	end
end

function dropExceedPack()
	if Auto_Buy_Pack == "YES" then
		local canDropPack = false
		for _, pack in pairs(Pack_ID) do
			if inventory:getItemCount(pack) < Max_Pack_To_Drop then
				return
			elseif inventory:getItemCount(pack) >= Max_Pack_To_Drop then
				canDropPack = true
				break
			end
		end
		
		if canDropPack then
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
			
			packWorld()
			dropPack()
			hiddenWorld()
			if defaultWorldName == Rotation_World then
				reconnect(Rotation_World, defaultBotX, defaultBotY)
				farmWorld()
			elseif ((defaultWorldName == Custom_World_Break_Other_World) or (defaultWorldName == randomWorldBreak())) then
				reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
				breakOtherWorld()
			end
		end
	end
end

function dropExceedPackGoOffline()
	if Auto_Buy_Pack == "YES" then
		local canDropPack = false
		for _, pack in pairs(Pack_ID) do
			if inventory:getItemCount(pack) > 0 then
				canDropPack = true
				break
			end
		end

		if canDropPack then
			packWorld()
			dropPack()
			hiddenWorld()
		end
	end
end
---- [ END BUY PACK ] ----


---- [ ITEM WHITELIST ] ----
function dropItemWhitelist(maxDrop)
	if Drop_Item_Whitelist == "YES" then
		local canDropItemWhitelist = false
		for _, whitelist in pairs(Item_Whitelist_ID) do
			if inventory:getItemCount(whitelist) >= maxDrop then
				canDropItemWhitelist = true
				break
			end
		end
		
		if canDropItemWhitelist then
			whitelistWorld()
			dropWhitelist()
			hiddenWorld()
			if not bot:isInWorld(Cook_World) and Start_Cooking == true then
				return
			else
				farmWorld()
			end
		end
	end
end
---- [ END ITEM WHITELIST ] ----


---- [ TRASH ITEM ] ----
function trashItem()
	if Auto_Trash == "YES" then
		for _, trash in ipairs(Trash_Item_ID) do
			reconnect(Rotation_World, 1, 23)
			if inventory:getItemCount(trash) > 0 then
				bot:trash(trash, inventory:getItemCount(trash))
				reconnect(Rotation_World, 1, 23)
			end
		end
	end
	reconnect(Rotation_World, 1, 23)
end
---- [ END TRASH ITEM ] ----


---- [ SKIP TUTORIAL ] ----
function skipTutorial()
	webhookShareInfoBot(
		"**[ BOT INFORMATION ]** \n" ..
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "]\n" ..
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<a:toa:997296837352505415> **|** Bot Information: Starting Skipping Tutorial"
	)
	
	if string.find(world.name:upper(), bot.name:upper()) and bot.level < 2 then
		if bot.status == BotStatus.online and inventory:getItemCount(9640) > 0 then
			for _, tile in pairs(world:getTiles()) do
				if bot.status == BotStatus.online then
					while tile.fg == 6 and inventory:getItemCount(9640) > 0 do
						bot:place(tile.x, tile.y - 1, 9640)
						sleep(math.random(Place_Delay, Place_Delay + 100))
					end
				elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
					defaultWorldName = world.name:upper()
					defaultBotX = bot.x
					defaultBotY = bot.y
					
					reconnect(defaultWorldName, defaultBotX, defaultBotY)
				end
			end
		end
		
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Information: Finished Skipping Tutorial"
		)
	end
end
---- [ END SKIP TUTORIAL ] ----


---- [ TAKE PICKAXE ] ---- 
function findpathPickaxe()
	if bot.status == BotStatus.online then
		reconnect(Pickaxe_World, 1, 23)
		upgradeBackpack()
		while objectSafeScan(Pickaxe_ID) == 0 and inventory:getItemCount(Pickaxe_ID) == 0 do
			if sendWebhookAmountTakePickaxe < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** The " .. getItemName(Pickaxe_ID) .. " in `" .. Pickaxe_World .. "` has run out or the " .. getItemName(Pickaxe_ID) .. " is being taken by another bot, " ..
					"so " .. bot.name:upper() .. " is waiting to take it! Please add stock if you feel there is not enough stock."
				)
				sendWebhookAmountTakePickaxe = sendWebhookAmountTakePickaxe + 1
			end
			
			if not bot:isInWorld(Pickaxe_World) then
				pickaxeWorld()
			end
			reconnect(Pickaxe_World, 1, 23)
			sleep(1000)
		end
		
		for _, obj in pairs(world:getObjects()) do
			if bot.status == BotStatus.online and obj.id == Pickaxe_ID then
				if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
					findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
				elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
					findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
				end 
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Pickaxe_World, 1, 23)
			end
			
			takeItem(Pickaxe_ID)
			
			if inventory:getItemCount(Pickaxe_ID) >= 1 then 
				break
			end
		end
		
		reconnect(Pickaxe_World, 1, 23)
		
		if inventory:getItemCount(Pickaxe_ID) > 1 then
			reconnect(Pickaxe_World, 1, 23)
			while not bot:isInTile(44, 13) do
				findpath(44, 13)
			end
			dropPickaxe()
		end
		
		if inventory:getItemCount(Pickaxe_ID) == 1 then
			reconnect(Pickaxe_World, 1, 23)
			bot:wear(Pickaxe_ID)
			sleep(math.random(Wear_Delay, Wear_Delay + 100))
		elseif inventory:getItemCount(Pickaxe_ID) == 0 then
			findpathPickaxe()
		end
		reconnect(Pickaxe_World, 1, 23)
	else
		reconnect(Pickaxe_World, 1, 23)
		findpathPickaxe()
	end
end

function dropPickaxe()
	if bot.status == BotStatus.online then
		while inventory:getItemCount(Pickaxe_ID) > 1 do
			bot:setDirection(false)
			sleep(100)
			bot:drop(Pickaxe_ID, inventory:getItemCount(Pickaxe_ID) - 1)
			sleep(math.random(Drop_Delay, Drop_Delay + 100))
			reconnect(Pickaxe_World, 1, 23)
		end
		reconnect(Pickaxe_World, 1, 23)
		if inventory:getItemCount(Pickaxe_ID) == 1 then
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " success to take the " .. getItemName(Pickaxe_ID) .. " \n\n" ..
				
				"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
				":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
				getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
			)
		elseif inventory:getItemCount(Pickaxe_ID) == 0 then
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " failed to take the " .. getItemName(Pickaxe_ID) .. ", try again!"
			)
			sendWebhookAmountTakePickaxe = 0
			findpathPickaxe()
		end
		reconnect(Pickaxe_World, 1, 23)
	else
		reconnect(Pickaxe_World, 1, 23)
		takePickaxe()
	end
end

function takePickaxe()
	reconnect(Pickaxe_World, 1, 23)
	
	if bot.status == BotStatus.online then
		if Take_Pickaxe == "YES" then
			if inventory:getItemCount(Pickaxe_ID) > 1 then
				pickaxeWorld()
				dropPickaxeStatus = true
				webhookShareInfoAllBot()
				while not bot:isInTile(44, 13) do
					findpath(44, 13)
				end
				dropPickaxe()
				dropPickaxeStatus = false
				
				if inventory:getItemCount(Pickaxe_ID) == 1 and not inventory:getItem(Pickaxe_ID).isActive then
					while inventory:getItemCount(Pickaxe_ID) == 1 and not inventory:getItem(Pickaxe_ID).isActive do
						bot:wear(Pickaxe_ID)
						sleep(math.random(Wear_Delay, Wear_Delay + 100))
					end
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** The " .. getItemName(Pickaxe_ID) .. " is already in use by " .. bot.name:upper() .. "."
					)
					return
				end
			
				if inventory:getItemCount(Pickaxe_ID) == 1 and inventory:getItem(Pickaxe_ID).isActive then
					webhookShareInfoBot(
						"<a:toa:997296837352505415> **|** The " .. getItemName(Pickaxe_ID) .. " is already in use by " .. bot.name:upper() .. "."
					)
					return
				end
				
				hiddenWorld()
			end
			
			if inventory:getItemCount(Pickaxe_ID) == 1 and not inventory:getItem(Pickaxe_ID).isActive then
				if not bot:isInWorld(Rotation_World) then
					farmWorld()
				end
				
				while inventory:getItemCount(Pickaxe_ID) == 1 and not inventory:getItem(Pickaxe_ID).isActive do
					bot:wear(Pickaxe_ID)
					sleep(math.random(Wear_Delay, Wear_Delay + 100))
				end
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** The " .. getItemName(Pickaxe_ID) .. " is already in use by " .. bot.name:upper() .. "."
				)
				return
			elseif inventory:getItemCount(Pickaxe_ID) == 1 and inventory:getItem(Pickaxe_ID).isActive then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** The " .. getItemName(Pickaxe_ID) .. " is already in use by " .. bot.name:upper() .. "."
				)
				return
			end
			
			if inventory:getItemCount(Pickaxe_ID) == 0 then
				reconnect(Pickaxe_World, 1, 23)
				pickaxeWorld()
				takingPickaxeStatus = true
				webhookShareInfoAllBot()
				sendWebhookAmountTakePickaxe = 0
				findpathPickaxe()
				takingPickaxeStatus = false
				hiddenWorld()
			end
		elseif Take_Pickaxe == "NO" then
			return
		end
	else
		reconnect(Pickaxe_World, 1, 23)
		takePickaxe()
	end
end
---- [ END TAKE PICKAXE ] ---- 


---- [ TAKE SEED ] ----
function findpathSeed()
	if bot.status == BotStatus.online then
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		
		for _, obj in pairs(world:getObjects()) do
			if bot.status == BotStatus.online and obj.id == Seed_ID then
				if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
					findpathSeedX = tileRounding(obj.x / 32)
					findpathSeedY = tileRounding(obj.y / 32)
					
					findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
						
					while not bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) do
						sleep(25000)
						reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
					end
					
					takeItem(Seed_ID)
					takeItem(112)
				elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
					findpathSeedX = tileRounding(obj.x / 32)
					findpathSeedY = tileRounding(obj.y / 32)
					
					findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
						
					while not bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) do
						sleep(25000)
						reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
					end
					
					takeItem(Seed_ID)
					takeItem(112)
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			end
				
			if objectSafeScan(Seed_ID) == 0 and inventory:getItemCount(Seed_ID) < 50 then
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				webhookShareInfoAllBot()
				break
			elseif objectSafeScan(Seed_ID) > 0 and inventory:getItemCount(Seed_ID) >= 50 then
				reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
				webhookShareInfoAllBot()
				break
			end
		end
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
	else
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		findpathSeed()
	end
end

function takeSeed()
	if bot.status == BotStatus.online then
		if Auto_Plant == "YES" then
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			seedWorld()
			reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
			if objectSafeScan(Seed_ID) == 0 then
				lastCheck()
			end
			findpathSeed()
			hiddenWorld()
			farmWorld()
		elseif Auto_Plant == "NO" then
			lastCheck()
		end
	else
		reconnect(Save_Seed_World, findpathSeedX, findpathSeedY)
		takeSeed()
	end
end
---- [ END TAKE SEED ] ----


---- [ WEARING RARE CLOTHES ] ----
Rare_Clothes_Pack = { 250, 1716, 82, 78, 754, 146, 356, 72, 46, 124, 1720, 92, 1122, 212, 84, 1722, 1844, 
2718, 70, 4966, 288, 232, 788, 148, 448, 134, 50, 74, 1504, 494, 266, 852, 132, 2954, 3060, 3056, 1800, 
88, 2960, 1022, 2578, 3164, 86, 302, 1332, 304, 1116, 6788, 492, 1690, 316, 1850, 1718, 1838, 1032, 1860, 
1026, 3048, 724, 1590, 798, 488, 1342, 794, 268, 1504, 8884, 1858, 1314, 1688, 1312, 3590, 446, 1856, 
1854, 1516, 1316, 2700, 4968, 4964, 6796, 1862, 310, 290, 296, 6674, 1864, 4954, 1476, 896, 1848, 496, 136, 
2958, 2576, 1954, 152, 796, 1524, 2928, 80, 2934, 150, 1120, 1142, 1478, 154, 452, 258, 2882, 156, 160, 1140, 3530, 
312, 1124, 690, 3052, 294, 1650, 1652, 348, 1736, 576, 292, 1146, 1028, 1762, 600, 11204, 1118 }
function wearRareClothesPack()
	if bot.status == BotStatus.online then
		for _, wearing in pairs(Rare_Clothes_Pack) do
			reconnect(Rotation_World, 1, 23)
			for _, itemActive in pairs(inventory:getItems()) do
				reconnect(Rotation_World, 1, 23)
				if itemActive.id == wearing then
					if itemActive.isActive then
						reconnect(Rotation_World, 1, 23)
					else
						reconnect(Rotation_World, 1, 23)
						bot:wear(wearing)
						sleep(math.random(Wear_Delay, Wear_Delay + 100))
					end
					reconnect(Rotation_World, 1, 23)
					break
				end
			end
		end
	else
		reconnect(Rotation_World, 1, 23)
		wearRareClothesPack()
	end
end

function hasRareClothesPack()
	if bot.status == BotStatus.online then
		if Auto_Buy_Rare_Clothes_Pack == "YES" then
			local shouldGoToNext = false
			
			for _, hasRareClothesPack in pairs(Rare_Clothes_Pack) do
				reconnect(Rotation_World, 1, 23)
				if inventory:getItemCount(hasRareClothesPack) > 0 then
					shouldGoToNext = true
					for _, itemActive in pairs(inventory:getItems()) do
						reconnect(Rotation_World, 1, 23)
						if itemActive.id == hasRareClothesPack then
							if itemActive.isActive then
								reconnect(Rotation_World, 1, 23)
							else
								reconnect(Rotation_World, 1, 23)
								bot:wear(hasRareClothesPack)
								sleep(math.random(Wear_Delay, Wear_Delay + 100))
							end
							reconnect(Rotation_World, 1, 23)
							break
						end
					end
				end
			end
			
			local checkWearPickaxe = false
			if shouldGoToNext then
				reconnect(Rotation_World, 1, 23)
				checkWearPickaxe = true
			else
				reconnect(Rotation_World, 1, 23)
				upgradeBackpackForRareClothesPack()
				if bot.gem_count >= 500 then 
					bot:buy("rare_clothes")
					sleep(math.random(Auto_Buy_Delay, Auto_Buy_Delay + 100))
				end
				wearRareClothesPack()
			end

			if checkWearPickaxe then
				if inventory:getItem(Pickaxe_ID).isActive then
					return
				elseif inventory:getItemCount(Pickaxe_ID) > 0 and not inventory:getItem(Pickaxe_ID).isActive then
					while inventory:getItemCount(Pickaxe_ID) > 0 and not inventory:getItem(Pickaxe_ID).isActive do
						bot:wear(Pickaxe_ID)
						sleep(math.random(Wear_Delay, Wear_Delay + 100))
					end
				end
			end
		elseif Auto_Buy_Rare_Clothes_Pack == "NO" then 
			return 
		end
	else
		reconnect(Rotation_World, 1, 23)
		hasRareClothesPack()
	end
end
---- [ END WEARING RARE CLOTHES ] ----


---- [ TAKE FLOATING BLOCK ] ----
function findpathBlock()
	reconnect(Rotation_World, findpathBlockX, findpathBlockY)
	leveling()
	autoConsume()
	randomSkinColor()
	trashItem()
	dropItemWhitelist(Max_Item_Whitelist_To_Drop)
	killingGhost()
	antiToxic()
	antiFire()
	bot.auto_collect = true
	sleep(100)
	
	if bot.status == BotStatus.online then
		if Auto_Take_Floating_Block == "YES" and objectSafeScan(Block_ID) > 0 and bot.level >= Min_Level then
			if objectSafeScan(Block_ID) > 0 then
				if inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then 
					reconnect(Rotation_World, findpathBlockX, findpathBlockY)
					webhookShareInfoAllBot()
					hasRareClothesPack()
					pnb()
				end
			elseif objectSafeScan(Block_ID) == 0 then
				if inventory:getItemCount(Block_ID) < Max_Block_To_Retrieve then 
					reconnect(Rotation_World, findpathBlockX, findpathBlockY)
					webhookShareInfoAllBot()
					return
				elseif inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then 
					reconnect(Rotation_World, findpathBlockX, findpathBlockY)
					webhookShareInfoAllBot()
					hasRareClothesPack()
					pnb()
				end
			end
			
			actionRotationAndFindpathAnimation = false
			
			for _, obj in pairs(world:getObjects()) do
				if bot.status == BotStatus.online and obj.id == Block_ID then
					if #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) > 0 then
						findpathBlockX = tileRounding(obj.x / 32)
						findpathBlockY = tileRounding(obj.y / 32)
						
						modEntered()
						autoConsume()
						randomChat()
						levelCheck()
						banWaveEstimated()
						proxyPlayTime()
						botPlayTime()
						
						findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
						
						while not bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) do
							sleep(25000)
							reconnect(Rotation_World, findpathBlockX, findpathBlockY)
							findpath(tileRounding(obj.x / 32), tileRounding(obj.y / 32))
						end
						
						webhookShareInfoAllBot()
						
						if inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then 
							webhookShareInfoAllBot()
							hasRareClothesPack()
							pnb()
						end
					elseif #bot:getPath(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) == 0 and bot:isInTile(tileRounding(obj.x / 32), tileRounding(obj.y / 32)) then
						findpathBlockX = tileRounding(obj.x / 32)
						findpathBlockY = tileRounding(obj.y / 32)
						
						modEntered()
						autoConsume()
						randomChat()
						levelCheck()
						banWaveEstimated()
						proxyPlayTime()
						botPlayTime()
						
						webhookShareInfoAllBot()
						
						if inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then 
							webhookShareInfoAllBot()
							hasRareClothesPack()
							pnb()
						end
					end
				elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
					reconnect(Rotation_World, findpathBlockX, findpathBlockY)
				end
			end
			
			if objectSafeScan(Block_ID) == 0 then
				if inventory:getItemCount(Block_ID) < Max_Block_To_Retrieve then 
					webhookShareInfoAllBot()
					harvest1()
				elseif inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then 
					webhookShareInfoAllBot()
					hasRareClothesPack()
					pnb()
				end
			end
		elseif Auto_Take_Floating_Block == "NO" then
			return
		end
	else
		reconnect(Rotation_World, findpathBlockX, findpathBlockY)
		findpathBlock()
	end
end
---- [ END TAKE FLOATING BLOCK ] ----


---- [ PUNCH MATURE ROOTS ] ----
function checkTileMatureRoots1()
	local retry = false
	local count = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.y == bot.y then
			if tile.fg == Mature_Roots_ID and tile.x > bot.x and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y - 1) > 0 then
					count = count + 1
					break
				elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1) then
					count = count + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			retry = true
			reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			break
		end
	end
	
	if retry then
		checkTileMatureRoots1()
	end
	
	return count
end

function checkTileMatureRoots2()
	local retry = false
	local count = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.y == bot.y then
			if tile.fg == Mature_Roots_ID and tile.x < bot.x and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y - 1) > 0 then
					count = count + 1
					break
				elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1) then
					count = count + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			retry = true
			reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			break
		end
	end
	
	if retry then
		checkTileMatureRoots2()
	end
	
	return count
end

function punchMatureRootsHelping1()
	if readyMatureRootsScan() > 0 then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.y >= bot.y then
					if tile.fg == Mature_Roots_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y - 1) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y - 1) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							findpath(tile.x, tile.y - 1)

							while not bot:isInTile(tile.x, tile.y - 1) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y - 1)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
						
							webhookShareInfoAllBot()
							break
						elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
								
							findpath(tile.x, tile.y - 1)

							while not bot:isInTile(tile.x, tile.y - 1) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y - 1)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
						
							webhookShareInfoAllBot()
							break
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
end

function punchMatureRootsHelping2()
	if readyMatureRootsScan() > 0 then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.fg == Mature_Roots_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
					if #bot:getPath(tile.x, tile.y - 1) > 0 then
						tileHarvestPlantX = tile.x
						tileHarvestPlantY = tile.y
						
						if #bot:getPath(tile.x, tile.y - 1) == 1 then
							actionRotationAndFindpathAnimation = true
						else
							actionRotationAndFindpathAnimation = false
						end
							
						findpath(tile.x, tile.y - 1)

						while not bot:isInTile(tile.x, tile.y - 1) and world:hasAccess(tile.x, tile.y) ~= 0 do
							sleep(25000)
							reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
							findpath(tile.x, tile.y - 1)
						end
						
						if bot:getPing() < High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
						elseif bot:getPing() >= High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
						end
					
						webhookShareInfoAllBot()
						break
					elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1) then
						tileHarvestPlantX = tile.x
						tileHarvestPlantY = tile.y
							
						findpath(tile.x, tile.y - 1)

						while not bot:isInTile(tile.x, tile.y - 1) and world:hasAccess(tile.x, tile.y) ~= 0 do
							sleep(25000)
							reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
							findpath(tile.x, tile.y - 1)
						end
						
						if bot:getPing() < High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
						elseif bot:getPing() >= High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
						end
					
						webhookShareInfoAllBot()
						break
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
end

function punchMatureRoots1()
	reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
	bot.auto_collect = false
	sleep(100)
	
	if readyMatureRootsScan() > 0 then
		if readyMatureRootsBelowScan() > 0 then
			punchMatureRootsHelping1()
		elseif readyMatureRootsBelowScan() == 0 then
			punchMatureRootsHelping2()
		end
		
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.y == bot.y then				
					if tile.fg == Mature_Roots_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y - 1) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y - 1) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							findpath(tile.x, tile.y - 1)

							while not bot:isInTile(tile.x, tile.y - 1) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y - 1)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
						
							webhookShareInfoAllBot()
						end
					end
					
					if checkTileMatureRoots1() == 0 then
						if tile.x == 99 and bot.x >= 50 then
							if tile.y > 0 and tile.y < 52 then
								if #bot:getPath(99, tile.y + 2) > 0 then
									findpath(99, tile.y + 2)
									punchMatureRoots2()
								elseif #bot:getPath(99, tile.y + 2) == 0 then 
									if bot:isInTile(99, tile.y + 2) then
										punchMatureRoots2()
									elseif not bot:isInTile(99, tile.y + 2) then
										punchMatureRootsHelping2()
										punchMatureRoots1()
									end
								end
							elseif tile.y > 51 then
								punchMatureRootsHelping2()
								punchMatureRoots1()
							end
						elseif tile.x == 99 and bot.x <= 49 then
							if tile.y > 0 and tile.y < 52 then
								if #bot:getPath(0, tile.y + 2) > 0 then
									findpath(0, tile.y + 2)
								elseif #bot:getPath(0, tile.y + 2) == 0 then
									if not bot:isInTile(0, tile.y + 2) then
										punchMatureRootsHelping2()
										punchMatureRoots1()
									end
								end
							elseif tile.y > 51 then
								punchMatureRootsHelping2()
								punchMatureRoots1()
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if readyMatureRootsScan() > 0 then
		punchMatureRoots1()
	elseif readyMatureRootsScan() == 0 then
		return
	end
end

function punchMatureRoots2()
	if readyMatureRootsScan() > 0 then
		local tiles = world:getTiles()
		for i = #tiles, 1, -1 do
			local tile = tiles[i]
			if bot.status == BotStatus.online then
				if tile.y == bot.y then
					if tile.fg == Seed_ID and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							findpath(tile.x, tile.y - 1)

							while not bot:isInTile(tile.x, tile.y - 1) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y - 1)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						end
					end
					
					if checkTileMatureRoots2() == 0 then
						if tile.x == 0 and bot.x <= 49 then
							if tile.y > 0 and tile.y < 52 then
								if #bot:getPath(0, tile.y + 2) > 0 then
									findpath(0, tile.y + 2)
									punchMatureRoots1()
								elseif #bot:getPath(0, tile.y + 2) == 0 then
									if bot:isInTile(0, tile.y + 2) then
										punchMatureRoots1()
									elseif not bot:isInTile(0, tile.y + 2) then
										punchMatureRootsHelping2()
										punchMatureRoots1()
									end
								end
							elseif tile.y > 51 then
								punchMatureRootsHelping2()
								punchMatureRoots1()
							end
						elseif tile.x == 0 and bot.x >= 50 then
							if tile.y > 0 and tile.y < 52 then
								if #bot:getPath(99, tile.y + 2) > 0 then
									findpath(99, tile.y + 2)
								elseif #bot:getPath(99, tile.y + 2) == 0 then
									if not bot:isInTile(99, tile.y + 2) then
										punchMatureRootsHelping2()
										punchMatureRoots1()
									end
								end
							elseif tile.y > 51 then
								punchMatureRootsHelping2()
								punchMatureRoots1()
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if readyMatureRootsScan() > 0 then
		punchMatureRoots1()
	elseif readyMatureRootsScan() == 0 then
		return
	end
end
---- [ END PUNCH MATURE ROOTS ] ----


---- [ HARVEST ] ----
function checkTileHarvest1()
	local retry = false
	local count = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.y == bot.y then
			if tile.fg == Seed_ID and tile.x > bot.x and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y) > 0 then
					count = count + 1
					break
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
					count = count + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			retry = true
			reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			break
		end
	end
	
	if retry then
		checkTileHarvest1()
	end
	
	return count
end

function checkTileHarvest2()
	local retry = false
	local count = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.y == bot.y then
			if tile.fg == Seed_ID and tile.x < bot.x and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then 
				if #bot:getPath(tile.x, tile.y) > 0 then
					count = count + 1
					break
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
					count = count + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			retry = true
			reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			break
		end
	end
	
	if retry then
		checkTileHarvest2()
	end
	
	return count
end

function harvestHelping1()
	bot:getLog():append("Action: harvestHelping1")
	if readyTreeScan() > 0 then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.y >= bot.y then
					if tile.fg == Seed_ID and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							findpath(tile.x, tile.y)
							
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
							break
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							findpath(tile.x, tile.y)
							
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
							break
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
		
	if readyTreeScan() == 0 then
		if bot.level < Min_Level then
			lastCheck()
		elseif  bot.level >= Min_Level then
			if inventory:getItemCount(Block_ID) > 0 then
				pnbLast()
			else
				lastCheck2()
			end
		end
	end
end

function harvestHelping2()
	bot:getLog():append("Action: harvestHelping2")
	if readyTreeScan() > 0 then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.fg == Seed_ID and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
					if #bot:getPath(tile.x, tile.y) > 0 then
						tileHarvestPlantX = tile.x
						tileHarvestPlantY = tile.y
						
						if #bot:getPath(tile.x, tile.y) == 1 then
							actionRotationAndFindpathAnimation = true
						else
							actionRotationAndFindpathAnimation = false
						end
							
						findpath(tile.x, tile.y)
						
						while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
							sleep(25000)
							reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
							findpath(tile.x, tile.y)
						end
						
						if bot:getPing() < High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
						elseif bot:getPing() >= High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
						end
						
						webhookShareInfoAllBot()
						break
					elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
						tileHarvestPlantX = tile.x
						tileHarvestPlantY = tile.y
						
						findpath(tile.x, tile.y)
						
						while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
							sleep(25000)
							reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
							findpath(tile.x, tile.y)
						end
						
						if bot:getPing() < High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
						elseif bot:getPing() >= High_Ping then
							bot:hit(tile.x, tile.y)
							sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
						end
						
						webhookShareInfoAllBot()
						break
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if readyTreeScan() == 0 then
		if bot.level < Min_Level then
			lastCheck()
		elseif  bot.level >= Min_Level then
			if inventory:getItemCount(Block_ID) > 0 then
				pnbLast()
			else
				lastCheck2()
			end
		end
	end
end

function harvest1()
	bot:getLog():append("Action: harvest1")
	reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
	leveling()
	autoConsume()
	randomSkinColor()
	trashItem()
	dropItemWhitelist(Max_Item_Whitelist_To_Drop)
	killingGhost()
	antiToxic()
	antiFire()
	wearingSpecificItem()
	bot.auto_collect = true
	sleep(100)
	
	if readyTreeScan() > 0 then
		if readyTreeBelowScan() > 0 then
			harvestHelping1()
		elseif readyTreeBelowScan() == 0 then
			harvestHelping2()
		end
		
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.y == bot.y then
					if tile.fg == Seed_ID and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							findpath(tile.x, tile.y)
							
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						end
					end
					
					if inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then
						hasRareClothesPack()
						pnb()
					elseif Auto_Buy_Pack == "YES" and bot.gem_count >= 10000 and bot.level < Min_Level then
						buyPack()
					else
						if checkTileHarvest1() == 0 then
							if tile.x == 99 and bot.x >= 50 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(99, tile.y + 2) > 0 then
										findpath(99, tile.y + 2)
										harvest2()
									elseif #bot:getPath(99, tile.y + 2) == 0 then 
										if bot:isInTile(99, tile.y + 2) then
											harvest2()
										elseif not bot:isInTile(99, tile.y + 2) then
											harvestHelping2()
											harvest1()
										end
									end
								elseif tile.y > 51 then
									harvestHelping2()
									harvest1()
								end
							elseif tile.x == 99 and bot.x <= 49 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(0, tile.y + 2) > 0 then
										findpath(0, tile.y + 2)
									elseif #bot:getPath(0, tile.y + 2) == 0 then
										if not bot:isInTile(0, tile.y + 2) then
											harvestHelping2()
											harvest1()
										end
									end
								elseif tile.y > 51 then
									harvestHelping2()
									harvest1()
								end
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if readyTreeScan() > 0 then
		findpathBlock()
		harvest1()
	elseif readyTreeScan() == 0 then
		if bot.level < Min_Level then
			lastCheck()
		elseif  bot.level >= Min_Level then
			if inventory:getItemCount(Block_ID) > 0 then
				pnbLast()
			else
				lastCheck2()
			end
		end
	end
end

function harvest2()
	bot:getLog():append("Action: harvest2")
	if readyTreeScan() > 0 then
		local tiles = world:getTiles()
		for i = #tiles, 1, -1 do
			local tile = tiles[i]
			if bot.status == BotStatus.online then
				if tile.y == bot.y then
					if tile.fg == Seed_ID and tile:canHarvest() and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							findpath(tile.x, tile.y)
									
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
								
							if bot:getPing() < High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(Harvest_Delay, Harvest_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:hit(tile.x, tile.y)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						end
					end
					
					if inventory:getItemCount(Block_ID) >= Max_Block_To_Retrieve and bot.level >= Min_Level then
						hasRareClothesPack()
						pnb()
					elseif Auto_Buy_Pack == "YES" and bot.gem_count >= 10000 and bot.level < Min_Level then
						buyPack()
					else
						if checkTileHarvest2() == 0 then
							if tile.x == 0 and bot.x <= 49 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(0, tile.y + 2) > 0 then
										findpath(0, tile.y + 2)
										harvest1()
									elseif #bot:getPath(0, tile.y + 2) == 0 then
										if bot:isInTile(0, tile.y + 2) then
											harvest1()
										elseif not bot:isInTile(0, tile.y + 2) then
											harvestHelping2()
											harvest1()
										end
									end
								elseif tile.y > 51 then
									harvestHelping2()
									harvest1()
								end
							elseif tile.x == 0 and bot.x >= 50 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(99, tile.y + 2) > 0 then
										findpath(99, tile.y + 2)
									elseif #bot:getPath(99, tile.y + 2) == 0 then 
										if not bot:isInTile(99, tile.y + 2) then
											harvestHelping2()
											harvest1()
										end
									end
								elseif tile.y > 51 then
									harvestHelping2()
									harvest1()
								end
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if readyTreeScan() > 0 then
		findpathBlock()
		harvest1()
	elseif readyTreeScan() == 0 then
		if bot.level < Min_Level then
			lastCheck()
		elseif  bot.level >= Min_Level then
			if inventory:getItemCount(Block_ID) > 0 then
				pnbLast()
			else
				lastCheck2()
			end
		end
	end
end
---- [ END HARVEST ] ----


---- [ PLANT ] ----
function webhookPlant()
	botTimeShow = os.time() - botTime
	timeRS()
	timeR()
	
	useEmbed2 = true
	checkDropPackCount2()
	webhookShareInfoBot(
		"**[ BOT INFORMATION ]** \n" ..
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
		"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
		
		"**[ WORLD INFORMATION ]** \n" ..
		"<:Globe:1190695520210006036> **|** Current Farm World: `" .. Rotation_World .. "` \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
		"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
		"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
		"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n\n" ..
		
		"**[ TREE INFORMATION ]** \n" ..
		"<:Laser_Grid_Tree:1190695145188884661> **|** Farmed Tree: " .. getItemName(Block_ID) .. " \n" ..
		"<:Laser_Grid_Tree:1190695145188884661> **|** Ready Tree Amount: " .. readyTreeScan() .. " \n" ..
		"<:Laser_Grid_Tree:1190695145188884661> **|** Unready Tree Amount: " .. unreadyTreeScan() .. " \n" ..
		"<:Laser_Grid:1190695132236894258> **|** Floating Block Amount: " .. objectSafeScan(Block_ID) .. " \n\n" ..
		
		"**[ FOSSIL INFORMATION ]**\n" ..
		"<:Fossil_Rock:1190695032001413191> **|** Fossil Rock Amount: " .. fossilRockScan() .. " \n\n" ..
		
		"**[ TIME INFORMATION ]**\n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow) .. " \n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Looping Time: " .. secondR(kalanzamansaniye6) .. " Minutes",
		
		
		"**[ ITEM INFORMATION ]** \n" ..
		"<:Seed_And_Block:1190695174993608805> **|** Total Seed and Block Dropped [In Backpack]: \n" ..
		getItemName(Seed_ID) .. ": " .. dropSeedCount .. " [" .. inventory:getItemCount(Seed_ID) .. "] \n" ..
		getItemName(Block_ID) .. ": " .. dropBlockCount .. " [" .. inventory:getItemCount(Block_ID) .. "] \n\n" ..
		
		":package: **|** Total Pack Dropped [In Backpack]:" ..
		dropPackCount2
	)
end

function checkTilePlant1()
	local retry = false
	local count = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.y == bot.y then
			if tile.fg == 0 and tile.x > bot.x and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y) > 0 then
					count = count + 1
					break
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
					count = count + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			retry = true
			reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			break
		end
	end
	
	if retry then
		checkTilePlant1()
	end
	
	return count
end

function checkTilePlant2()
	local retry = false
	local count = 0
	
	for _, tile in pairs(world:getTiles()) do
		if bot.status == BotStatus.online and bot:isInWorld(Rotation_World) and tile.y == bot.y then
			if tile.fg == 0 and tile.x < bot.x and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
				if #bot:getPath(tile.x, tile.y) > 0 then
					count = count + 1
					break
				elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
					count = count + 1
					break
				end
			end
		elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
			retry = true
			reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			break
		end
	end
	
	if retry then
		checkTilePlant2()
	end
	
	return count
end

function plantHelping1()
	bot:getLog():append("Action: plantHelping1")
	if inventory:getItemCount(Seed_ID) > 0 and emptyTileScan() > 0 then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.y >= bot.y then
					if tile.fg == 0 and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
						
							findpath(tile.x, tile.y)
							
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(Plant_Delay, Plant_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
							break
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
								
							findpath(tile.x, tile.y)
							
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(Plant_Delay, Plant_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
							break
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
end

function plantHelping2()
	bot:getLog():append("Action: plantHelping2")
	if inventory:getItemCount(Seed_ID) > 0 and emptyTileScan() > 0 then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.fg == 0 and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID then
					if #bot:getPath(tile.x, tile.y) > 0 then
						tileHarvestPlantX = tile.x
						tileHarvestPlantY = tile.y
							
						if #bot:getPath(tile.x, tile.y) == 1 then
							actionRotationAndFindpathAnimation = true
						else
							actionRotationAndFindpathAnimation = false
						end
							
						findpath(tile.x, tile.y)
						
						while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
							sleep(25000)
							reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
							findpath(tile.x, tile.y)
						end
						
						if bot:getPing() < High_Ping then
							bot:place(tile.x, tile.y, Seed_ID)
							sleep(math.random(Plant_Delay, Plant_Delay + 100))
						elseif bot:getPing() >= High_Ping then
							bot:place(tile.x, tile.y, Seed_ID)
							sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
						end
						
						webhookShareInfoAllBot()
						break
					elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
						tileHarvestPlantX = tile.x
						tileHarvestPlantY = tile.y
							
						findpath(tile.x, tile.y)
						
						while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
							sleep(25000)
							reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
							findpath(tile.x, tile.y)
						end
						
						if bot:getPing() < High_Ping then
							bot:place(tile.x, tile.y, Seed_ID)
							sleep(math.random(Plant_Delay, Plant_Delay + 100))
						elseif bot:getPing() >= High_Ping then
							bot:place(tile.x, tile.y, Seed_ID)
							sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
						end
						
						webhookShareInfoAllBot()
						break
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
end

function plant1()
	bot:getLog():append("Action: plant1")
	reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
	autoConsume()
	randomSkinColor()
	trashItem()
	dropItemWhitelist(Max_Item_Whitelist_To_Drop)
	killingGhost()
	antiToxic()
	antiFire()
	bot.auto_collect = true
	sleep(100)
	
	if inventory:getItemCount(Seed_ID) > 0 and emptyTileScan() > 0 then
		if emptyTileBelowScan() > 0 then
			plantHelping1()
		elseif emptyTileBelowScan() == 0 then
			plantHelping2()
		end
		
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if tile.y == bot.y then
					if tile.fg == 0 and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID and world:hasAccess(tile.x, tile.y) ~= 0 then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y			
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
						
							findpath(tile.x, tile.y)
								
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(Plant_Delay, Plant_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y			
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							if bot:getPing() < High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(Plant_Delay, Plant_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						end
						
						if emptyTileBelowScan() == 0 then
							break
						end
					end
					
					if inventory:getItemCount(Seed_ID) == 0 then
						break
					elseif inventory:getItemCount(Seed_ID) > 0 then
						if checkTilePlant1() == 0 then
							if tile.x == 99 and bot.x >= 50 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(99, tile.y + 2) > 0 then
										findpath(99, tile.y + 2)
										plant2()
									elseif #bot:getPath(99, tile.y + 2) == 0 then
										if bot:isInTile(99, tile.y + 2) then
											plant2()
										elseif not bot:isInTile(99, tile.y + 2) then
											plantHelping2()
											plant1()
										end
									end
								elseif tile.y > 51 then
									plantHelping2()
									plant1()
								end
							elseif tile.x == 99 and bot.x <= 49 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(0, tile.y + 2) > 0 then
										findpath(0, tile.y + 2)
									elseif #bot:getPath(0, tile.y + 2) == 0 then
										if not bot:isInTile(0, tile.y + 2) then
											plantHelping2()
											plant1()
										end
									end
								elseif tile.y > 51 then
									plantHelping2()
									plant1()
								end
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if inventory:getItemCount(Seed_ID) > 0 and emptyTileScan() > 0 then
		plant1()
	else
		lastCheck2()
	end
end

function plant2()
	bot:getLog():append("Action: plant2")
	if inventory:getItemCount(Seed_ID) > 0 and emptyTileScan() > 0 then
		local tiles = world:getTiles()
		for i = #tiles, 1, -1 do
			local tile = tiles[i]
			if bot.status == BotStatus.online then
				if tile.y == bot.y then
					if tile.fg == 0 and world:getTile(tile.x, tile.y + 1).fg ~= 0 and world:getTile(tile.x, tile.y + 1).fg % 2 == 0 and world:getTile(tile.x, tile.y + 1).fg ~= Block_ID then
						if #bot:getPath(tile.x, tile.y) > 0 then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y
							
							if #bot:getPath(tile.x, tile.y) == 1 then
								actionRotationAndFindpathAnimation = true
							else
								actionRotationAndFindpathAnimation = false
							end
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							findpath(tile.x, tile.y)
									
							while not bot:isInTile(tile.x, tile.y) and world:hasAccess(tile.x, tile.y) ~= 0 do
								sleep(25000)
								reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
								findpath(tile.x, tile.y)
							end
							
							if bot:getPing() < High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(Plant_Delay, Plant_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						elseif #bot:getPath(tile.x, tile.y) == 0 and bot:isInTile(tile.x, tile.y) then
							tileHarvestPlantX = tile.x
							tileHarvestPlantY = tile.y			
							
							modEntered()
							autoConsume()
							randomChat()
							levelCheck()
							banWaveEstimated()
							proxyPlayTime()
							botPlayTime()
							
							if bot:getPing() < High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(Plant_Delay, Plant_Delay + 100))
							elseif bot:getPing() >= High_Ping then
								bot:place(tile.x, tile.y, Seed_ID)
								sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
							end
							
							webhookShareInfoAllBot()
						end
						
						if emptyTileBelowScan() == 0 then
							break
						end
					end
					
					if inventory:getItemCount(Seed_ID) == 0 then
						break
					elseif inventory:getItemCount(Seed_ID) > 0 then
						if checkTilePlant2() == 0 then
							if tile.x == 0 and bot.x <= 49 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(0, tile.y + 2) > 0 then
										findpath(0, tile.y + 2)
										plant1()
									elseif #bot:getPath(0, tile.y + 2) == 0 then
										if bot:isInTile(0, tile.y + 2) then
											plant1()
										elseif not bot:isInTile(0, tile.y + 2) then
											plantHelping2()
											plant1()
										end
									end
								elseif tile.y > 51 then
									plantHelping2()
									plant1()
								end
							elseif tile.x == 0 and bot.x >= 50 then
								if tile.y > 0 and tile.y < 52 then
									if #bot:getPath(99, tile.y + 2) > 0 then
										findpath(99, tile.y + 2)
									elseif #bot:getPath(99, tile.y + 2) == 0 then
										if not bot:isInTile(99, tile.y + 2) then
											plantHelping2()
											plant1()
										end
									end
								elseif tile.y > 51 then
									plantHelping2()
									plant1()
								end
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				reconnect(Rotation_World, tileHarvestPlantX, tileHarvestPlantY)
			end
		end
	end
	
	if inventory:getItemCount(Seed_ID) > 0 and emptyTileScan() > 0 then
		plant1()
	else
		lastCheck2()
	end
end
---- [ END PLANT ] ----


---- [ PNB ] ----
function retrieveItems(varlist, netid)
	if varlist:get(0):getString() == "OnDialogRequest" then
		message = varlist:get(1):getString()
		if message:match("The machine is currently empty") and noStopScript == true then
			unlistenEvents()
		elseif message:match("Unstable") and noStopScript == true then			
			unstableX = message:match("tilex|(%d+)")
			unstableY = message:match("tiley|(%d+)")
			retrieveItem = "action|dialog_return\ndialog_name|itemsucker_block\ntilex|" .. unstableX .. "|\ntiley|" .. unstableY .. "|\nbuttonClicked|retrieveitem\n\nchk_enablesucking|1"
			bot:sendPacket(2, retrieveItem)
		elseif message:match("Gaia") and noStopScript == true then	
			gaiaX = k.v2:match("tilex|(%d+)")
			gaiaY = k.v2:match("tiley|(%d+)")
			retrieveItem = "action|dialog_return\ndialog_name|itemsucker_seed\ntilex|" .. gaiaX .. "|\ntiley|" .. gaiaY .. "|\nbuttonClicked|retrieveitem\n\nchk_enablesucking|1"
			bot:sendPacket(2, retrieveItem)
		end
	
		if message:match("How many") and noStopScript == true then			
			retrieveX = message:match("tilex|(%d+)")
			retrieveY = message:match("tiley|(%d+)")
			amount = message:match("Amount:|(%d+)")
			removedItemFromSucker = "action|dialog_return\ndialog_name|itemremovedfromsucker\ntilex|" .. retrieveX .. "|\ntiley|" .. retrieveY .. "|\nitemtoremove|" .. amount
			bot:sendPacket(2, removedItemFromSucker)
		end
	end
end

function pnb()
	bot:getLog():append("Action: pnb")
	if tutorialWorld == "nil" and Break_Other_World == "YES" and Use_Tutorial_World_For_Break == "YES" and not string.find(tutorialWorld, bot.name:upper()) then
		bot:sendPacket(2, "action|wrench\n|netid|" .. world:getLocal().netid)
		sleep(500)
		bot:sendPacket(2, "action|dialog_return\ndialog_name|popup\nnetID|" .. world:getLocal().netid .. "|\nbuttonClicked|my_worlds")
		addEvent(Event.variantlist, tutorialWorldEvent)
		listenEvents(2)
	end
	
	dropExceedPack()
	
	if bot.status == BotStatus.online and Auto_Buy_Pack == "YES" and bot.gem_count >= Pack_Price and Break_Other_World == "NO" then
		reconnect(Save_Pack_World, 1, 23)
		buyPack()
	elseif bot.status == BotStatus.online and Auto_Buy_Pack == "YES" and bot.gem_count >= Pack_Price and Break_Other_World == "YES" and (Use_Custom_World_For_Break == "YES" or Use_Tutorial_World_For_Break == "YES") then
		reconnect(Save_Pack_World, 1, 23)
		buyPack()
	elseif bot.status == BotStatus.online and Auto_Buy_Pack == "YES" and bot.gem_count >= Pack_Price and Break_Other_World == "YES" and Use_Random_World_For_Break == "YES" then
		breakOtherWorld()
		if Auto_Buy_Pack == "YES" and bot.gem_count >= Pack_Price then
			if placedItemInOtherWorldScan(204) > 0 and placedItemInOtherWorldScan(226) > 0 and Buy_Signal_Jammer == "YES" then
				reconnect(Save_Pack_World, 1, 23)
				buyPack()
			elseif placedItemInOtherWorldScan(204) > 0 and Buy_Signal_Jammer == "NO" then
				reconnect(Save_Pack_World, 1, 23)
				buyPack()
			end
		end
	end
	
	reconnect(Rotation_World, X_Break, Y_Break)
	if Break_Other_World == "NO" and not bot:isInWorld(Rotation_World) then
		farmWorld()
	elseif Break_Other_World == "YES" and (Use_Custom_World_For_Break == "YES" and not bot:isInWorld(Custom_World_Break_Other_World)) or (Use_Random_World_For_Break == "YES" and not bot:isInWorld(randomWorldBreak())) or (Use_Tutorial_World_For_Break == "YES" and not bot:isInWorld(tutorialWorld)) then
		breakOtherWorld()
	end
	
	randomSkinColor()	
	bot:setDirection(true)
	sleep(100)
	modEntered()
	leveling()
	autoConsume()
	levelCheck()
	banWaveEstimated()
	proxyPlayTime()
	botPlayTime()

	local checkValidPosition = true
	if checkValidPosition then
		if bot:isInWorld(Rotation_World) and not bot:isInTile(X_Break, Y_Break) then
			reconnect(Rotation_World, X_Break, Y_Break)
			findpath(X_Break, Y_Break)
		elseif Use_Custom_World_For_Break == "YES" and bot:isInWorld(Custom_World_Break_Other_World) and not bot:isInTile(X_Break, Y_Break) then
			reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
			findpath(X_Break, Y_Break)
		elseif Use_Random_World_For_Break == "YES" and bot:isInWorld(randomWorldBreak()) and not bot:isInTile(breakOtherWorldX, breakOtherWorldY) then
			reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			findpath(breakOtherWorldX, breakOtherWorldY)
		elseif Use_Tutorial_World_For_Break == "YES" and bot:isInWorld(tutorialWorld) and not bot:isInTile(X_Break, Y_Break) then
			reconnect(tutorialWorld, X_Break, Y_Break)
			findpath(X_Break, Y_Break)
		end
	end
	
	while bot.status == BotStatus.online and inventory:getItemCount(Block_ID) > 0 and Break_Other_World == "NO" do
		if bot:isInWorld(Rotation_World) and Auto_Retrieve == "NO" and bot.auto_collect ~= true then
			bot.auto_collect = true
			sleep(100)
		elseif bot:isInWorld(Rotation_World) and Auto_Retrieve == "YES" and bot.auto_collect ~= false then
			bot.auto_collect = false
			sleep(100)
		end
		
		reconnect(Rotation_World, X_Break, Y_Break)
		
		if bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 0 and Auto_Plant == "YES" then
			bot:place(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32), Seed_ID)
			sleep(math.random(Place_Delay, Place_Delay + 100))
		end
		
		webhookShareInfoAllBot()
		modEntered()
		autoConsume()
		randomChat()
		levelCheck()
		banWaveEstimated()
		proxyPlayTime()
		botPlayTime()
		
		if emptyTileScan() > 0 and inventory:getItemCount(Seed_ID) > 150 and Auto_Plant == "YES" then
			webhookPlant()
			plant1()
		elseif emptyTileScan() == 0 and inventory:getItemCount(Seed_ID) > 150 then
			bot.auto_collect = false
			sleep(100)
			seedWorld()
			dropSeed()
			takeItem(Block_ID)
			hiddenWorld()
			farmWorld()
			findpathBreak()
			bot:setDirection(true)
			sleep(100)
			if bot:isInWorld(Rotation_World) then
				bot.auto_collect = true
				sleep(100)
			end
		end
		
		if checkValidPosition then
			while bot:isInWorld(Rotation_World) and not bot:isInTile(X_Break, Y_Break) do
				sleep(25000)
				reconnect(Rotation_World, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			end
		end
		
		if not bot:isInWorld(Rotation_World) then
			farmWorld()
			findpathBreak()
		elseif bot:isInWorld(Rotation_World) then
			breaker()
			breakerHelper()
		end
	end
	
	while bot.status == BotStatus.online and inventory:getItemCount(Block_ID) > 0 and Break_Other_World == "YES" do
		if (bot:isInWorld(Custom_World_Break_Other_World) or bot:isInWorld(randomWorldBreak()) or bot:isInWorld(tutorialWorld)) and Auto_Retrieve == "NO" and bot.auto_collect ~= true then
			bot.auto_collect = true
			sleep(100)
		elseif (bot:isInWorld(Custom_World_Break_Other_World) or bot:isInWorld(randomWorldBreak()) or bot:isInWorld(tutorialWorld)) and Auto_Retrieve == "YES" and bot.auto_collect ~= false then
			bot.auto_collect = false
			sleep(100)
		end
		
		if Break_Other_World == "YES" and Use_Custom_World_For_Break == "YES" then
			reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
		elseif Break_Other_World == "YES" and Use_Random_World_For_Break == "YES" then
			reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
		end
		
		webhookShareInfoAllBot()
		modEntered()
		autoConsume()
		randomChat()
		levelCheck()
		banWaveEstimated()
		proxyPlayTime()
		botPlayTime()
		
		if emptyTileScan() > 0 and inventory:getItemCount(Seed_ID) > 150 and Auto_Plant == "YES" then
			farmWorld()
			webhookPlant()
			plant1()
		elseif emptyTileScan() == 0 and inventory:getItemCount(Seed_ID) > 150 then
			bot.auto_collect = false
			sleep(100)
			seedWorld()
			dropSeed()
			takeItem(Block_ID)
			hiddenWorld()
			breakOtherWorld()
			findpathBreakOtherWorld()
			bot:setDirection(true)
			sleep(100)
			if bot:isInWorld(randomWorldBreak()) then
				bot.auto_collect = true
				sleep(100)
			end
		end
		
		if checkValidPosition then
			while Use_Custom_World_For_Break == "YES" and bot:isInWorld(Custom_World_Break_Other_World) and not bot:isInTile(X_Break, Y_Break) do
				sleep(25000)
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			end
			
			while Use_Random_World_For_Break == "YES" and bot:isInWorld(randomWorldBreak()) and not bot:isInTile(breakOtherWorldX, breakOtherWorldY) do
				sleep(25000)
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
				findpath(breakOtherWorldX, breakOtherWorldY)
			end
			
			while Use_Tutorial_World_For_Break == "YES" and bot:isInWorld(tutorialWorld) and not bot:isInTile(X_Break, Y_Break) do
				sleep(25000)
				reconnect(tutorialWorld, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			end
		end
		
		if (Use_Custom_World_For_Break == "YES" and not bot:isInWorld(Custom_World_Break_Other_World)) or (Use_Random_World_For_Break == "YES" and not bot:isInWorld(randomWorldBreak())) or (Use_Tutorial_World_For_Break == "YES" and not bot:isInWorld(tutorialWorld)) then
			breakOtherWorld()
			findpathBreakOtherWorld()
		elseif (bot:isInWorld(Custom_World_Break_Other_World) or bot:isInWorld(randomWorldBreak()) or bot:isInWorld(tutorialWorld)) then
			breaker()
			breakerHelper()
		end
	end
	
	webhookShareInfoAllBot()
	
	if Auto_Retrieve == "YES" and bot.status == BotStatus.online then
		local retrieveUnstable = true
		if retrieveUnstable then
			if wrenchUnstableX == nil and wrenchUnstableY == nil then
				for _, tile in pairs(world:getTiles()) do
					if bot.status == BotStatus.online then
						if tile.fg == 6948 then
							findpath(tile.x, tile.y - 1)
							while not bot:isInTile(tile.x, tile.y - 1) do
								findpath(tile.x, tile.y - 1)
								sleep(3000)
							end
							
							wrenchUnstableX = tile.x
							wrenchUnstableY = tile.y
							break
						end
					elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
						defaultBotX = bot.x
						defaultBotY = bot.y
						
						if Break_Other_World == "YES" then
							if Use_Custom_World_For_Break == "YES" then
								reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
							elseif Use_Random_World_For_Break == "YES" then
								reconnect(randomWorldBreak(), defaultBotX, defaultBotY)
							elseif Use_Tutorial_World_For_Break == "YES" then
								reconnect(tutorialWorld, defaultBotX, defaultBotY)
							end
						elseif Break_Other_World == "NO" then
							reconnect(Rotation_World, defaultBotX, defaultBotY)
						end
					end
				end
			else
				findpath(wrenchUnstableX, wrenchUnstableY - 1)
				while not bot:isInTile(wrenchUnstableX, wrenchUnstableY - 1) do
					findpath(wrenchUnstableX, wrenchUnstableY - 1)
					sleep(3000)
				end
			end
			
			bot:setBubble(Bubble.brb)
			sleep(500)
			bot:wrench(wrenchUnstableX, wrenchUnstableY)
			addEvent(Event.variantlist, retrieveItems)
			listenEvents(5)
			bot:setBubble(Bubble.none)
		end
		
		if inventory:getItemCount(Block_ID) > 0 then
			pnb()
		end
		
		local retrieveGaia = true
		if retrieveGaia then
			if wrenchGaiaX == nil and wrenchGaiaY == nil then
				for _, tile in pairs(world:getTiles()) do
					if bot.status == BotStatus.online then
						if tile.fg == 6946 then
							findpath(tile.x, tile.y - 1)
							while not bot:isInTile(tile.x, tile.y - 1) do
								findpath(tile.x, tile.y - 1)
								sleep(3000)
							end
							
							wrenchGaiaX = tile.x
							wrenchGaiaY = tile.y
							break
						end
					elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
						defaultBotX = bot.x
						defaultBotY = bot.y
						
						if Break_Other_World == "YES" then
							if Use_Custom_World_For_Break == "YES" then
								reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
							elseif Use_Random_World_For_Break == "YES" then
								reconnect(randomWorldBreak(), defaultBotX, defaultBotY)
							elseif Use_Tutorial_World_For_Break == "YES" then
								reconnect(tutorialWorld, defaultBotX, defaultBotY)
							end
						elseif Break_Other_World == "NO" then
							reconnect(Rotation_World, defaultBotX, defaultBotY)
						end
					end
				end
			else
				findpath(wrenchGaiaX, wrenchGaiaY - 1)
				while not bot:isInTile(wrenchGaiaX, wrenchGaiaY - 1) do
					findpath(wrenchGaiaX, wrenchGaiaY - 1)
					sleep(3000)
				end
			end
			
			bot:setBubble(Bubble.brb)
			sleep(500)
			bot:wrench(wrenchGaiaX, wrenchGaiaY)
			addEvent(Event.variantlist, retrieveItems)
			listenEvents(5)
			bot:setBubble(Bubble.none)
		end
	end
	
	if bot.status ~= BotStatus.online then
		reconnect(Rotation_World, X_Break, Y_Break)
		if inventory:getItemCount(Block_ID) > 0 then
			pnb()
		end
	end
	
	lastPNBBlockTileCheck()
	
	if Auto_Plant == "YES" then
		if not bot:isInWorld(Rotation_World) then
			farmWorld()
		end
		
		webhookPlant()
		plant1()
	elseif Auto_Plant == "NO" then
		webhookAutoPlantNo()
		if inventory:getItemCount(Seed_ID) > 0 then
			reconnect(Rotation_World, 1, 23)
			bot.auto_collect = false
			sleep(100)
			seedWorld()
			dropSeed()
			takeItem(Block_ID)
			hiddenWorld()
			farmWorld()
			reconnect(Rotation_World, 1, 23)
		end
		
		findpathBlock()
		harvest1()
	end
end

function pnbLast()
	bot:getLog():append("Action: pnbLast")
	if inventory:getItemCount(Block_ID) > 0 then
		if tutorialWorld == "nil" and Break_Other_World == "YES" and Use_Tutorial_World_For_Break == "YES" and not string.find(tutorialWorld, bot.name:upper()) then
			bot:sendPacket(2, "action|wrench\n|netid|" .. world:getLocal().netid)
			sleep(500)
			bot:sendPacket(2, "action|dialog_return\ndialog_name|popup\nnetID|" .. world:getLocal().netid .. "|\nbuttonClicked|my_worlds")
			addEvent(Event.variantlist, tutorialWorldEvent)
			listenEvents(2)
		end
		
		if Break_Other_World == "NO" and not bot:isInWorld(Rotation_World) then
			farmWorld()
		elseif Break_Other_World == "YES" and (Use_Custom_World_For_Break == "YES" and not bot:isInWorld(Custom_World_Break_Other_World)) or (Use_Random_World_For_Break == "YES" and not bot:isInWorld(randomWorldBreak())) or (Use_Tutorial_World_For_Break == "YES" and not bot:isInWorld(tutorialWorld)) then
			breakOtherWorld()
		end
		
		randomSkinColor()
		bot:setDirection(true)
		sleep(100)
		
		if bot:isInWorld(Rotation_World) then
			bot.auto_collect = true
			sleep(100)
		end
		
		local checkValidPosition = true
		if checkValidPosition then
			if bot:isInWorld(Rotation_World) and not bot:isInTile(X_Break, Y_Break) then
				reconnect(Rotation_World, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			elseif Use_Custom_World_For_Break == "YES" and bot:isInWorld(Custom_World_Break_Other_World) and not bot:isInTile(X_Break, Y_Break) then
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			elseif Use_Random_World_For_Break == "YES" and bot:isInWorld(randomWorldBreak()) and not bot:isInTile(breakOtherWorldX, breakOtherWorldY) then
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
				findpath(breakOtherWorldX, breakOtherWorldY)
			elseif Use_Tutorial_World_For_Break == "YES" and bot:isInWorld(tutorialWorld) and not bot:isInTile(X_Break, Y_Break) then
				reconnect(tutorialWorld, X_Break, Y_Break)
				findpath(X_Break, Y_Break)
			end
		end
		
		while bot.status == BotStatus.online and inventory:getItemCount(Block_ID) > 0 and Break_Other_World == "NO" do
			if bot:isInWorld(Rotation_World) and Auto_Retrieve == "NO" and bot.auto_collect ~= true then
				bot.auto_collect = true
				sleep(100)
			elseif bot:isInWorld(Rotation_World) and Auto_Retrieve == "YES" and bot.auto_collect ~= false then
				bot.auto_collect = false
				sleep(100)
			end
			
			reconnect(Rotation_World, X_Break, Y_Break)
			
			if bot:isInWorld(Rotation_World) and world:getTile(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32)).fg == 0 and Auto_Plant == "YES" then
				bot:place(math.floor(world:getLocal().posx / 32), math.floor(world:getLocal().posy / 32), Seed_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			end
			
			webhookShareInfoAllBot()
			modEntered()
			autoConsume()
			randomChat()
			levelCheck()
			banWaveEstimated()
			proxyPlayTime()
			botPlayTime()
			
			if emptyTileScan() > 0 and inventory:getItemCount(Seed_ID) > 150 and Auto_Plant == "YES" then
				webhookPlant()
				plant1()
			elseif emptyTileScan() == 0 and inventory:getItemCount(Seed_ID) > 150 then
				bot.auto_collect = false
				sleep(100)
				seedWorld()
				dropSeed()
				takeItem(Block_ID)
				hiddenWorld()
				farmWorld()
				findpathBreak()
				bot:setDirection(true)
				sleep(100)
				if bot:isInWorld(Rotation_World) then
					bot.auto_collect = true
					sleep(100)
				end
			end
			
			if checkValidPosition then
				while bot:isInWorld(Rotation_World) and not bot:isInTile(X_Break, Y_Break) do
					sleep(25000)
					reconnect(Rotation_World, X_Break, Y_Break)
					findpath(X_Break, Y_Break)
				end
			end
			
			if not bot:isInWorld(Rotation_World) then
				farmWorld()
				findpathBreak()
			elseif bot:isInWorld(Rotation_World) then
				breaker()
				breakerHelper()
			end
		end
		
		while bot.status == BotStatus.online and inventory:getItemCount(Block_ID) > 0 and Break_Other_World == "YES" do
			if (bot:isInWorld(Custom_World_Break_Other_World) or bot:isInWorld(randomWorldBreak()) or bot:isInWorld(tutorialWorld)) and Auto_Retrieve == "NO" and bot.auto_collect ~= true then
				bot.auto_collect = true
				sleep(100)
			elseif (bot:isInWorld(Custom_World_Break_Other_World) or bot:isInWorld(randomWorldBreak()) or bot:isInWorld(tutorialWorld)) and Auto_Retrieve == "YES" and bot.auto_collect ~= false then
				bot.auto_collect = false
				sleep(100)
			end
			
			if Break_Other_World == "YES" and Use_Custom_World_For_Break == "YES" then
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
			elseif Break_Other_World == "YES" and Use_Random_World_For_Break == "YES" then
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			end
			
			webhookShareInfoAllBot()
			modEntered()
			autoConsume()
			randomChat()
			levelCheck()
			banWaveEstimated()
			proxyPlayTime()
			botPlayTime()
			
			if emptyTileScan() > 0 and inventory:getItemCount(Seed_ID) > 150 and Auto_Plant == "YES" then
				farmWorld()
				webhookPlant()
				plant1()
			elseif emptyTileScan() == 0 and inventory:getItemCount(Seed_ID) > 150 then
				bot.auto_collect = false
				sleep(100)
				seedWorld()
				dropSeed()
				takeItem(Block_ID)
				hiddenWorld()
				breakOtherWorld()
				findpathBreakOtherWorld()
				bot:setDirection(true)
				sleep(100)
				if bot:isInWorld(randomWorldBreak()) then
					bot.auto_collect = true
					sleep(100)
				end
			end
			
			if checkValidPosition then
				while Use_Custom_World_For_Break == "YES" and bot:isInWorld(Custom_World_Break_Other_World) and not bot:isInTile(X_Break, Y_Break) do
					sleep(25000)
					reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
					findpath(X_Break, Y_Break)
				end
				
				while Use_Random_World_For_Break == "YES" and bot:isInWorld(randomWorldBreak()) and not bot:isInTile(breakOtherWorldX, breakOtherWorldY) do
					sleep(25000)
					reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
					findpath(breakOtherWorldX, breakOtherWorldY)
				end
				
				while Use_Tutorial_World_For_Break == "YES" and bot:isInWorld(tutorialWorld) and not bot:isInTile(X_Break, Y_Break) do
					sleep(25000)
					reconnect(tutorialWorld, X_Break, Y_Break)
					findpath(X_Break, Y_Break)
				end
			end
			
			if (Use_Custom_World_For_Break == "YES" and not bot:isInWorld(Custom_World_Break_Other_World)) or (Use_Random_World_For_Break == "YES" and not bot:isInWorld(randomWorldBreak())) or (Use_Tutorial_World_For_Break == "YES" and not bot:isInWorld(tutorialWorld)) then
				breakOtherWorld()
				findpathBreakOtherWorld()
			elseif (bot:isInWorld(Custom_World_Break_Other_World) or bot:isInWorld(randomWorldBreak()) or bot:isInWorld(tutorialWorld)) then
				breaker()
				breakerHelper()
			end
		end
	end
	
	webhookShareInfoAllBot()
	
	if Auto_Retrieve == "YES" and bot.status == BotStatus.online then
		local retrieveUnstable = true
		if retrieveUnstable then
			if wrenchUnstableX == nil and wrenchUnstableY == nil then
				for _, tile in pairs(world:getTiles()) do
					if bot.status == BotStatus.online then
						if tile.fg == 6948 then
							findpath(tile.x, tile.y - 1)
							while not bot:isInTile(tile.x, tile.y - 1) do
								findpath(tile.x, tile.y - 1)
								sleep(3000)
							end
							
							wrenchUnstableX = tile.x
							wrenchUnstableY = tile.y
							break
						end
					elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
						defaultBotX = bot.x
						defaultBotY = bot.y
						
						if Break_Other_World == "YES" then
							if Use_Custom_World_For_Break == "YES" then
								reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
							elseif Use_Random_World_For_Break == "YES" then
								reconnect(randomWorldBreak(), defaultBotX, defaultBotY)
							elseif Use_Tutorial_World_For_Break == "YES" then
								reconnect(tutorialWorld, defaultBotX, defaultBotY)
							end
						elseif Break_Other_World == "NO" then
							reconnect(Rotation_World, defaultBotX, defaultBotY)
						end
					end
				end
			else
				findpath(wrenchUnstableX, wrenchUnstableY - 1)
				while not bot:isInTile(wrenchUnstableX, wrenchUnstableY - 1) do
					findpath(wrenchUnstableX, wrenchUnstableY - 1)
					sleep(3000)
				end
			end
			
			bot:setBubble(Bubble.brb)
			sleep(500)
			bot:wrench(wrenchUnstableX, wrenchUnstableY)
			addEvent(Event.variantlist, retrieveItems)
			listenEvents(5)
			bot:setBubble(Bubble.none)
		end
		
		if inventory:getItemCount(Block_ID) > 0 then
			pnbLast()
		end
		
		local retrieveGaia = true
		if retrieveGaia then
			if wrenchGaiaX == nil and wrenchGaiaY == nil then
				for _, tile in pairs(world:getTiles()) do
					if bot.status == BotStatus.online then
						if tile.fg == 6946 then
							findpath(tile.x, tile.y - 1)
							while not bot:isInTile(tile.x, tile.y - 1) do
								findpath(tile.x, tile.y - 1)
								sleep(3000)
							end
							
							wrenchGaiaX = tile.x
							wrenchGaiaY = tile.y
							break
						end
					elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
						defaultBotX = bot.x
						defaultBotY = bot.y
						
						if Break_Other_World == "YES" then
							if Use_Custom_World_For_Break == "YES" then
								reconnect(Custom_World_Break_Other_World, defaultBotX, defaultBotY)
							elseif Use_Random_World_For_Break == "YES" then
								reconnect(randomWorldBreak(), defaultBotX, defaultBotY)
							elseif Use_Tutorial_World_For_Break == "YES" then
								reconnect(tutorialWorld, defaultBotX, defaultBotY)
							end
						elseif Break_Other_World == "NO" then
							reconnect(Rotation_World, defaultBotX, defaultBotY)
						end
					end
				end
			else
				findpath(wrenchGaiaX, wrenchGaiaY - 1)
				while not bot:isInTile(wrenchGaiaX, wrenchGaiaY - 1) do
					findpath(wrenchGaiaX, wrenchGaiaY - 1)
					sleep(3000)
				end
			end
				
			bot:setBubble(Bubble.brb)
			sleep(500)
			bot:wrench(wrenchGaiaX, wrenchGaiaY)
			addEvent(Event.variantlist, retrieveItems)
			listenEvents(5)
			bot:setBubble(Bubble.none)
		end
	end
	
	if bot.status ~= BotStatus.online then
		reconnect(Rotation_World, X_Break, Y_Break)
		if inventory:getItemCount(Block_ID) > 0 then
			pnbLast()
		end
	end
	
	lastPNBBlockTileCheck()
	
	if Auto_Plant == "YES" then
		if not bot:isInWorld(Rotation_World) then
			farmWorld()
		end
	elseif Auto_Plant == "NO" then
		webhookAutoPlantNo()
		if inventory:getItemCount(Seed_ID) > 0 then
			reconnect(Rotation_World, 1, 23)
			bot.auto_collect = false
			sleep(100)
			seedWorld()
			dropSeed()
			takeItem(Block_ID)
			hiddenWorld()
			farmWorld()
		end
	end
	
	lastCheck1()
end

function lastPNBBlockTileCheck()
	if Break_Other_World == "YES" then
		if Use_Custom_World_For_Break == "YES" then
			reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
		elseif Use_Random_World_For_Break == "YES" then
			reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
		elseif Use_Tutorial_World_For_Break == "YES" then
			reconnect(tutorialWorld, X_Break, Y_Break)
		end
	elseif Break_Other_World == "NO" then
		reconnect(Rotation_World, X_Break, Y_Break)
	end
	
	if bot:isInWorld(Rotation_World) then
		for _, tile in pairs(world:getTiles()) do
			if bot.status == BotStatus.online then
				if (tile.fg == Block_ID or tile.bg == Block_ID) then
					if tile.y == 0 and world:hasAccess(tile.x, tile.y) ~= 0 then
						if Break_Other_World == "YES" then
							if Use_Custom_World_For_Break == "YES" then
								reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
							elseif Use_Random_World_For_Break == "YES" then
								reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
							elseif Use_Tutorial_World_For_Break == "YES" then
								reconnect(tutorialWorld, X_Break, Y_Break)
							end
						elseif Break_Other_World == "NO" then
							reconnect(Rotation_World, X_Break, Y_Break)
						end
						
						if #bot:getPath(tile.x, tile.y + 1) > 0 then
							findpath(tile.x, tile.y + 1)
							
							while not bot:isInTile(tile.x, tile.y + 1) and #bot:getPath(tile.x, tile.y + 1) > 0 do
								sleep(25000)
								if Break_Other_World == "YES" then
									if Use_Custom_World_For_Break == "YES" then
										reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
									elseif Use_Random_World_For_Break == "YES" then
										reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
									elseif Use_Tutorial_World_For_Break == "YES" then
										reconnect(tutorialWorld, X_Break, Y_Break)
									end
								elseif Break_Other_World == "NO" then
									reconnect(Rotation_World, X_Break, Y_Break)
								end
								
								findpath(tile.x, tile.y + 1)
							end
							
							destroyDefault(tile.x, tile.y)
						elseif #bot:getPath(tile.x, tile.y + 1) == 0 and bot:isInTile(tile.x, tile.y + 1) then
							destroyDefault(tile.x, tile.y)
						end
					elseif tile.y == 1 and world:hasAccess(tile.x, tile.y) ~= 0 then
						if Break_Other_World == "YES" then
							if Use_Custom_World_For_Break == "YES" then
								reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
							elseif Use_Random_World_For_Break == "YES" then
								reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
							elseif Use_Tutorial_World_For_Break == "YES" then
								reconnect(tutorialWorld, X_Break, Y_Break)
							end
						elseif Break_Other_World == "NO" then
							reconnect(Rotation_World, X_Break, Y_Break)
						end
						
						if #bot:getPath(tile.x, tile.y - 1) > 0 then
							findpath(tile.x, tile.y - 1)
							
							while not bot:isInTile(tile.x, tile.y - 1) and #bot:getPath(tile.x, tile.y - 1) > 0 do
								sleep(25000)
								if Break_Other_World == "YES" then
									if Use_Custom_World_For_Break == "YES" then
										reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
									elseif Use_Random_World_For_Break == "YES" then
										reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
									elseif Use_Tutorial_World_For_Break == "YES" then
										reconnect(tutorialWorld, X_Break, Y_Break)
									end
								elseif Break_Other_World == "NO" then
									reconnect(Rotation_World, X_Break, Y_Break)
								end
								
								findpath(tile.x, tile.y - 1)
							end
							
							destroyDefault(tile.x, tile.y)
						elseif #bot:getPath(tile.x, tile.y - 1) == 0 and bot:isInTile(tile.x, tile.y - 1)	 then
							destroyDefault(tile.x, tile.y)
						end
					else
						if world:hasAccess(tile.x, tile.y) ~= 0 then
							if Break_Other_World == "YES" then
								if Use_Custom_World_For_Break == "YES" then
									reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
								elseif Use_Random_World_For_Break == "YES" then
									reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
								elseif Use_Tutorial_World_For_Break == "YES" then
									reconnect(tutorialWorld, X_Break, Y_Break)
								end
							elseif Break_Other_World == "NO" then
								reconnect(Rotation_World, X_Break, Y_Break)
							end
						
							if #bot:getPath(tile.x, tile.y - 2) > 0 then
								findpath(tile.x, tile.y - 2)
								
								while not bot:isInTile(tile.x, tile.y - 2) and #bot:getPath(tile.x, tile.y - 2) > 0 do
									sleep(25000)
									if Break_Other_World == "YES" then
										if Use_Custom_World_For_Break == "YES" then
											reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
										elseif Use_Random_World_For_Break == "YES" then
											reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
										elseif Use_Tutorial_World_For_Break == "YES" then
											reconnect(tutorialWorld, X_Break, Y_Break)
										end
									elseif Break_Other_World == "NO" then
										reconnect(Rotation_World, X_Break, Y_Break)
									end
									
									findpath(tile.x, tile.y - 2)
								end
								
								destroyDefault(tile.x, tile.y)
							elseif #bot:getPath(tile.x, tile.y - 2) == 0 and bot:isInTile(tile.x, tile.y - 2) then
								destroyDefault(tile.x, tile.y)
							end
						end
					end
				end
			elseif bot.status ~= BotStatus.online or (bot.status == BotStatus.online and bot:getPing() == 0) then
				if Break_Other_World == "YES" then
					if Use_Custom_World_For_Break == "YES" then
						reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
					elseif Use_Random_World_For_Break == "YES" then
						reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
					elseif Use_Tutorial_World_For_Break == "YES" then
						reconnect(tutorialWorld, X_Break, Y_Break)
					end
				elseif Break_Other_World == "NO" then
					reconnect(Rotation_World, X_Break, Y_Break)
				end
			end
		end
	end
end

function destroy(x, y)
	while bot.status == BotStatus.online and (world:getTile(x, y).fg ~= 0 or world:getTile(x, y).bg ~= 0) and (bot:isInTile(X_Break, Y_Break) or bot:isInTile(breakOtherWorldX, breakOtherWorldY)) do
		if Break_Other_World == "YES" then
			if Use_Custom_World_For_Break == "YES" then
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
			elseif Use_Random_World_For_Break == "YES" then
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			elseif Use_Tutorial_World_For_Break == "YES" then
				reconnect(tutorialWorld, X_Break, Y_Break)
			end
		elseif Break_Other_World == "NO" then
			reconnect(Rotation_World, X_Break, Y_Break)
		end
		
		if not bot:isInTile(X_Break, Y_Break) and (bot:isInWorld(Rotation_World) or bot:isInWorld(Custom_World_Break_Other_World)) then
			sleep(25000)
			if Break_Other_World == "YES" then
				if Use_Custom_World_For_Break == "YES" then
					reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
				elseif Use_Random_World_For_Break == "YES" then
					reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
				elseif Use_Tutorial_World_For_Break == "YES" then
					reconnect(tutorialWorld, X_Break, Y_Break)
				end
			elseif Break_Other_World == "NO" then
				reconnect(Rotation_World, X_Break, Y_Break)
			end
			findpath(X_Break, Y_Break)
		elseif not bot:isInTile(breakOtherWorldX, breakOtherWorldY) and bot:isInWorld(randomWorldBreak()) then
			sleep(25000)
			if Break_Other_World == "YES" then
				if Use_Custom_World_For_Break == "YES" then
					reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
				elseif Use_Random_World_For_Break == "YES" then
					reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
				elseif Use_Tutorial_World_For_Break == "YES" then
					reconnect(tutorialWorld, X_Break, Y_Break)
				end
			elseif Break_Other_World == "NO" then
				reconnect(Rotation_World, X_Break, Y_Break)
			end
			findpath(breakOtherWorldX, breakOtherWorldY)
		end
		
		breakerHelper()
		
		if bot:getPing() < High_Ping and world:hasAccess(x, y) ~= 0 then
			bot:hit(x, y)
			sleep(math.random(Hit_Delay, Hit_Delay + 100))
		elseif bot:getPing() >= High_Ping and world:hasAccess(x, y) ~= 0 then
			bot:hit(x, y)
			sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
		end
		
		if Break_Other_World == "YES" then
			if Use_Custom_World_For_Break == "YES" then
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
			elseif Use_Random_World_For_Break == "YES" then
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			elseif Use_Tutorial_World_For_Break == "YES" then
				reconnect(tutorialWorld, X_Break, Y_Break)
			end
		elseif Break_Other_World == "NO" then
			reconnect(Rotation_World, X_Break, Y_Break)
		end
	end
	
	if Break_Other_World == "YES" then
		if Use_Custom_World_For_Break == "YES" then
			reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
		elseif Use_Random_World_For_Break == "YES" then
			reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
		elseif Use_Tutorial_World_For_Break == "YES" then
			reconnect(tutorialWorld, X_Break, Y_Break)
		end
	elseif Break_Other_World == "NO" then
		reconnect(Rotation_World, X_Break, Y_Break)
	end
end

function destroyDefault(x, y)
	while bot.status == BotStatus.online and (world:getTile(x, y).fg ~= 0 or world:getTile(x, y).bg ~= 0) do
		if bot:isInWorld(Rotation_World) then
			reconnect(Rotation_World, X_Break, Y_Break)
		else
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
		end
		
		if bot:getPing() < High_Ping and world:hasAccess(x, y) ~= 0 then
			bot:hit(x, y)
			sleep(math.random(Hit_Delay, Hit_Delay + 100))
		elseif bot:getPing() >= High_Ping and world:hasAccess(x, y) ~= 0 then
			bot:hit(x, y)
			sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
		end
		
		if bot:isInWorld(Rotation_World) then
			reconnect(Rotation_World, X_Break, Y_Break)
		else
			defaultWorldName = world.name:upper()
			defaultBotX = bot.x
			defaultBotY = bot.y
				
			reconnect(defaultWorldName, defaultBotX, defaultBotY)
		end
	end
	
	if bot:isInWorld(Rotation_World) then
		reconnect(Rotation_World, X_Break, Y_Break)
	else
		defaultWorldName = world.name:upper()
		defaultBotY = bot.y
		defaultBotX = bot.x
				
		reconnect(defaultWorldName, defaultBotX, defaultBotY)
	end
end

function randomRangeBreak(range_start, range_end)
    local numbers = {}
    for i = range_start, range_end do
        table.insert(numbers, i)
    end

    local permutations = {}
    for i = 1, 1 do
        local shuffled = {}
        local temp_numbers = {table.unpack(numbers)}
        while #temp_numbers > 0 do
            local index = math.random(#temp_numbers)
            table.insert(shuffled, table.remove(temp_numbers, index))
        end
        permutations[i] = shuffled
    end
    return permutations
end

function breaker()
	if PNB_Range == 5 then
		Range_Break = randomRangeBreak(-2, 2)
	elseif PNB_Range == 4 then
		Range_Break = randomRangeBreak(-2, 1)
	elseif PNB_Range == 3 then
		Range_Break = randomRangeBreak(-1, 1)
	elseif PNB_Range == 2 then
		Range_Break = randomRangeBreak(-1, 0)
	elseif PNB_Range == 1 then
		Range_Break = randomRangeBreak(0, 0)
	end
	
	if Break_Other_World == "YES" and Use_Tutorial_World_For_Break == "YES" and bot:isInWorld(tutorialWorld) and playerScan() > 0 then
		for _, player in pairs(world:getPlayers()) do
			if not string.find(player.name:upper(), bot.name:upper()) then
				bot:setBubble(Bubble.talk)
				sleep(#("/ban " .. player.name) * 80)
				bot:say("/ban " .. player.name)
				sleep(10)
				bot:setBubble(Bubble.none)
			end
		end
	end
	
	if math.floor(world:getLocal().posx / 32) == X_Break and math.floor(world:getLocal().posy / 32) == Y_Break then
		if Break_Other_World == "YES" then
			if Use_Custom_World_For_Break == "YES" then
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
			elseif Use_Random_World_For_Break == "YES" then
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			elseif Use_Tutorial_World_For_Break == "YES" then	
				reconnect(tutorialWorld, X_Break, Y_Break)
			end
		elseif Break_Other_World == "NO" then
			reconnect(Rotation_World, X_Break, Y_Break)
		end
		
		if PNB_Range == 5 then
			if bot:getPing() < High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][3], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][4], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][5], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][3], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][4], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][5], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(X_Break - 1, Y_Break + Range_Break[1][1])
			destroy(X_Break - 1, Y_Break + Range_Break[1][2])
			destroy(X_Break - 1, Y_Break + Range_Break[1][3])
			destroy(X_Break - 1, Y_Break + Range_Break[1][4])
			destroy(X_Break - 1, Y_Break + Range_Break[1][5])
		elseif PNB_Range == 4 then
			if bot:getPing() < High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][3], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][4], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][3], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][4], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(X_Break - 1, Y_Break + Range_Break[1][1])
			destroy(X_Break - 1, Y_Break + Range_Break[1][2])
			destroy(X_Break - 1, Y_Break + Range_Break[1][3])
			destroy(X_Break - 1, Y_Break + Range_Break[1][4])
		elseif PNB_Range == 3 then
			if bot:getPing() < High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][3], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][3], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(X_Break - 1, Y_Break + Range_Break[1][1])
			destroy(X_Break - 1, Y_Break + Range_Break[1][2])
			destroy(X_Break - 1, Y_Break + Range_Break[1][3])
		elseif PNB_Range == 2 then
			if bot:getPing() < High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(X_Break - 1, Y_Break + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(X_Break - 1, Y_Break + Range_Break[1][1])
			destroy(X_Break - 1, Y_Break + Range_Break[1][2])
		elseif PNB_Range == 1 then
			if bot:getPing() < High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(X_Break - 1, Y_Break + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(X_Break - 1, Y_Break + Range_Break[1][1])
		else 
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** Enter PNB_Range with the numbers 1 to 5, according to how many tile you want to break."
			)
		end
	elseif math.floor(world:getLocal().posx / 32) == breakOtherWorldX and math.floor(world:getLocal().posy / 32) == breakOtherWorldY then
		if Break_Other_World == "YES" then
			if Use_Custom_World_For_Break == "YES" then
				reconnect(Custom_World_Break_Other_World, X_Break, Y_Break)
			elseif Use_Random_World_For_Break == "YES" then
				reconnect(randomWorldBreak(), breakOtherWorldX, breakOtherWorldY)
			elseif Use_Tutorial_World_For_Break == "YES" then
				reconnect(tutorialWorld, X_Break, Y_Break)
			end
		elseif Break_Other_World == "NO" then
			reconnect(Rotation_World, X_Break, Y_Break)
		end
		
		if PNB_Range == 5 then
			if bot:getPing() < High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][4], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][5], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][4], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][5], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][4])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][5])
		elseif PNB_Range == 4 then
			if bot:getPing() < High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][4], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][4], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][4])
		elseif PNB_Range == 3 then
			if bot:getPing() < High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][3])
		elseif PNB_Range == 2 then
			if bot:getPing() < High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1])
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][2])
		elseif PNB_Range == 1 then
			if bot:getPing() < High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(Place_Delay, Place_Delay + 100))
			elseif bot:getPing() >= High_Ping then
				bot:place(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1], Block_ID)
				sleep(math.random(bot:getPing() + 50, bot:getPing() + 100))
			end
			destroy(breakOtherWorldX - 1, breakOtherWorldY + Range_Break[1][1])
		else 
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** Enter PNB_Range with the numbers 1 to 5, according to how many tile you want to break."
			)
		end
	end
end

function breakerHelper()
	if Break_Other_World == "YES" then
		if (world:hasAccess(bot.x + 1, bot.y) == 0 or tileGrowScan(fireID) > 0) and Use_Custom_World_For_Break == "YES" and bot:isInWorld(Custom_World_Break_Other_World) then
			dropExceedPackGoOffline()
	
			while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
				seedWorld()
				dropSeed()
				while inventory:getItemCount(Block_ID) > 0 do
					dropBlock()
				end
			end
			
			while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
				pickaxeWorld()
				while not bot:isInTile(44, 13) do
					findpath(44, 13)
				end
				dropItem(Pickaxe_ID)
				if inventory:getItemCount(Pickaxe_ID) == 0 then
					webhookShareInfoDropped(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
						
						"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
						":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
						getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
					)
				end
			end
			
			dropEquipmentBeforeOfffline()
			hiddenWorld()
			
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is offline as it does not have access to PNB."
			)
			removeBotIndex(Remove_Bot, bot.name:upper() .. " is offline as it does not have access to PNB.")
		elseif (world:hasAccess(bot.x + 1, bot.y) == 0 or tileGrowScan(fireID) > 0) and Use_Random_World_For_Break == "YES" and bot:isInWorld(randomWorldBreak()) then
			cachedWorldBreak = nil
			pnb()
		elseif (world:hasAccess(bot.x + 1, bot.y) == 0 or tileGrowScan(fireID) > 0) and Use_Tutorial_World_For_Break == "YES" and bot:isInWorld(tutorialWorld) then
			dropExceedPackGoOffline()
	
			while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
				seedWorld()
				dropSeed()
				while inventory:getItemCount(Block_ID) > 0 do
					dropBlock()
				end
			end
			
			while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
				pickaxeWorld()
				while not bot:isInTile(44, 13) do
					findpath(44, 13)
				end
				dropItem(Pickaxe_ID)
				if inventory:getItemCount(Pickaxe_ID) == 0 then
					webhookShareInfoDropped(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
						
						"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
						":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
						getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
					)
				end
			end
			
			dropEquipmentBeforeOfffline()
			hiddenWorld()
			
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is offline as it does not have access to PNB."
			)
			removeBotIndex(Remove_Bot, bot.name:upper() .. " is offline as it does not have access to PNB.")
		end
	elseif Break_Other_World == "NO" then
		if bot:isInWorld(Rotation_World) then
			if world:hasAccess(bot.x + 1, bot.y) == 0 then
				dropExceedPackGoOffline()
	
				while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
					seedWorld()
					dropSeed()
					while inventory:getItemCount(Block_ID) > 0 do
						dropBlock()
					end
				end
				
				while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
					pickaxeWorld()
					while not bot:isInTile(44, 13) do
						findpath(44, 13)
					end
					dropItem(Pickaxe_ID)
					if inventory:getItemCount(Pickaxe_ID) == 0 then
						webhookShareInfoDropped(
							"**[ BOT INFORMATION ]** \n" ..
							"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
							":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
							"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
							"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
							"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
							"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
							
							"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
							"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
							":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
							getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
						)
					end
				end
				
				dropEquipmentBeforeOfffline()
				hiddenWorld()
				
				autoRecon = false
				noStopScript = false
				bot:disconnect()
				sleep(100)
				webhookShareInfoAllBot()
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** " .. bot.name:upper() .. " is offline as it does not have access to PNB."
				)
				removeBotIndex(Remove_Bot, bot.name:upper() .. " is offline as it does not have access to PNB.")
			elseif tileGrowScan(fireID) > 0 then
				antiFire()
			end
		end
	end	
end
---- [ END PNB ] ----


---- [ LOOPING WORLD ] ----
function loopStatus()
	if Use_Looping == "YES" then
		hiddenWorld()
		nextWorldLoop()
	elseif Use_Looping == "NO" then
		hiddenWorld()
		nextWorldNoLoop()
	end
end

function nextWorldLoop()
	if nextWorldStatus == true and noStopScript == true then
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Information: Next World \n\n" ..
			
			"**[ ESTIMATED TIME ]** \n" ..
			"<:Globe:1190695520210006036> **|** World Status: `" .. Rotation_World .. "` Finished \n" ..
			"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
			"<:Luxurious_Wall_Clock:1190695156333150258> **|** Estimated End Time: \n" ..
			"**" .. sonsaaat .. " Hours, " .. sondakika .. " Minutes/" .. job .. " Tree**"
		)
	elseif nextWorldStatus == false and noStopScript == true then
		table.remove(Rotation_World_List_Result, Start_Rotation_World_List)
		totalRotationWorldList = #Rotation_World_List_Result
		Start_Rotation_World_List = Start_Rotation_World_List - 1		
		if totalRotationWorldList == 0 and noStopScript == true then
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot( 
				"<a:toa:997296837352505415> **|** Index bot " .. bot.index .. " does not have a rotation world list."
			)
			removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a rotation world list.")
		end
		nextWorldStatus = true
	elseif nextWorldStatus == "otherCondition" and noStopScript == true then
		table.remove(Rotation_World_List_Result, Start_Rotation_World_List)
		totalRotationWorldList = #Rotation_World_List_Result
		Start_Rotation_World_List = Start_Rotation_World_List - 1		
		if totalRotationWorldList == 0 and noStopScript == true then
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot( 
				"<a:toa:997296837352505415> **|** Index bot " .. bot.index .. " does not have a rotation world list."
			)
			removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a rotation world list.")
		end
		nextWorldStatus = true
	end
	
	if nextWorldStatus == true and noStopScript == true then
		Start_Rotation_World_List = Start_Rotation_World_List + 1
		
		if Start_Rotation_World_List <= totalRotationWorldList then
			Rotation_World = Rotation_World_List_Result[Start_Rotation_World_List][1]:upper()
			Rotation_Door_ID = Rotation_World_List_Result[Start_Rotation_World_List][2]:upper()
				if Rotation_Door_ID == "-" then
					Rotation_Door_ID = ""
				end
			Block_ID = tonumber(Rotation_World_List_Result[Start_Rotation_World_List][3])
			Seed_ID = Block_ID + 1
			Mature_Roots_ID = Block_ID + 4
		
			useEmbed2 = true
			checkDropPackCount2()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" .. 
				"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Current Farm World: `" .. Rotation_World .. "` \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
				"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
				"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
				"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n\n" ..
				
				"**[ TREE INFORMATION ]** \n" ..
				"<:Laser_Grid_Tree:1190695145188884661> **|** Farmed Tree: " .. getItemName(Block_ID) .. " \n\n" ..
				
				"**[ TIME INFORMATION ]** \n" ..
				"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow),
		
		
				"**[ ITEM INFORMATION ]** \n" ..
				"<:Seed_And_Block:1190695174993608805> **|** Total Seed and Block Dropped [In Backpack]: \n" ..
				getItemName(Seed_ID) .. ": " .. dropSeedCount .. " [" .. inventory:getItemCount(Seed_ID) .. "] \n" ..
				getItemName(Block_ID) .. ": " .. dropBlockCount .. " [" .. inventory:getItemCount(Block_ID) .. "] \n\n" ..
				
				":package: **|** Total Pack Dropped [In Backpack]:" ..
				dropPackCount2
			)
			main()
		else
			Start_Rotation_World_List = 1
			Rotation_World = Rotation_World_List_Result[Start_Rotation_World_List][1]:upper()
			Rotation_Door_ID = Rotation_World_List_Result[Start_Rotation_World_List][2]:upper()
				if Rotation_Door_ID == "-" then
					Rotation_Door_ID = ""
				end
			Block_ID = tonumber(Rotation_World_List_Result[Start_Rotation_World_List][3])
			Seed_ID = Block_ID + 1
			Mature_Roots_ID = Block_ID + 4
			
			useEmbed2 = true
			checkDropPackCount2()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" .. 
				"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Current Farm World: `" .. Rotation_World .. "` \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
				"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
				"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
				"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n\n" ..
				
				"**[ TREE INFORMATION ]** \n" ..
				"<:Laser_Grid_Tree:1190695145188884661> **|** Farmed Tree: " .. getItemName(Block_ID) .. " \n\n" ..
				
				"**[ TIME INFORMATION ]** \n" ..
				"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow),
		
		
				"**[ ITEM INFORMATION ]** \n" ..
				"<:Seed_And_Block:1190695174993608805> **|** Total Seed and Block Dropped [In Backpack]: \n" ..
				getItemName(Seed_ID) .. ": " .. dropSeedCount .. " [" .. inventory:getItemCount(Seed_ID) .. "] \n" ..
				getItemName(Block_ID) .. ": " .. dropBlockCount .. " [" .. inventory:getItemCount(Block_ID) .. "] \n\n" ..
				
				":package: **|** Total Pack Dropped [In Backpack]:" ..
				dropPackCount2
			)
			main()
		end
	end
end

function nextWorldNoLoop()
	if nextWorldStatus == true and noStopScript == true then
		webhookShareInfoBot(
			"**[ BOT INFORMATION ]** \n" ..
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Information: Next World \n\n" ..
			
			"**[ ESTIMATED TIME ]** \n" ..
			"<:Globe:1190695520210006036> **|** World Status: `" .. Rotation_World .. "` Finished \n" ..
			"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
			"<:Luxurious_Wall_Clock:1190695156333150258> **|** Estimated End Time: \n" ..
			"**" .. sonsaaat .. " Hours, " .. sondakika .. " Minutes/" .. job .. " Tree**"
		)
	elseif nextWorldStatus == false and noStopScript == true then
		table.remove(Rotation_World_List_Result, Start_Rotation_World_List)
		totalRotationWorldList = #Rotation_World_List_Result
		Start_Rotation_World_List = Start_Rotation_World_List - 1
		if totalRotationWorldList == 0 and noStopScript == true then
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot( 
				"<a:toa:997296837352505415> **|** Index bot " .. bot.index .. " does not have a rotation world list."
			)
			removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a rotation world list.")
		end
		nextWorldStatus = true
	elseif nextWorldStatus == "otherCondition" and noStopScript == true then
		table.remove(Rotation_World_List_Result, Start_Rotation_World_List)
		totalRotationWorldList = #Rotation_World_List_Result
		Start_Rotation_World_List = Start_Rotation_World_List - 1
		if totalRotationWorldList == 0 and noStopScript == true then
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot( 
				"<a:toa:997296837352505415> **|** Index bot " .. bot.index .. " does not have a rotation world list."
			)
			removeBotIndex(Remove_Bot, "Index bot " .. bot.index .. " does not have a rotation world list.")
		end
		nextWorldStatus = true
	end
	
	if nextWorldStatus == true and noStopScript == true then
		Start_Rotation_World_List = Start_Rotation_World_List + 1
		
		if Start_Rotation_World_List <= totalRotationWorldList then
			Rotation_World = Rotation_World_List_Result[Start_Rotation_World_List][1]:upper()
			Rotation_Door_ID = Rotation_World_List_Result[Start_Rotation_World_List][2]:upper()
				if Rotation_Door_ID == "-" then
					Rotation_Door_ID = ""
				end
			Block_ID = tonumber(Rotation_World_List_Result[Start_Rotation_World_List][3])
			Seed_ID = Block_ID + 1
			Mature_Roots_ID = Block_ID + 4
			
			useEmbed2 = true
			checkDropPackCount2()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" .. 
				"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
				
				"**[ WORLD INFORMATION ]** \n" ..
				"<:Globe:1190695520210006036> **|** Current Farm World: `" .. Rotation_World .. "` \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
				"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
				"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
				"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n\n" ..
				
				"**[ TREE INFORMATION ]** \n" ..
				"<:Laser_Grid_Tree:1190695145188884661> **|** Farmed Tree: " .. getItemName(Block_ID) .. " \n\n" ..
				
				"**[ TIME INFORMATION ]** \n" ..
				"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow),
		
		
				"**[ ITEM INFORMATION ]** \n" ..
				"<:Seed_And_Block:1190695174993608805> **|** Total Seed and Block Dropped [In Backpack]: \n" ..
				getItemName(Seed_ID) .. ": " .. dropSeedCount .. " [" .. inventory:getItemCount(Seed_ID) .. "] \n" ..
				getItemName(Block_ID) .. ": " .. dropBlockCount .. " [" .. inventory:getItemCount(Block_ID) .. "] \n\n" ..
				
				":package: **|** Total Pack Dropped [In Backpack]:" ..
				dropPackCount2
			)
			main()
		else
			Start_Rotation_World_List = Start_Rotation_World_List - 1
			Rotation_World = Rotation_World_List_Result[Start_Rotation_World_List][1]:upper()
			Rotation_Door_ID = Rotation_World_List_Result[Start_Rotation_World_List][2]:upper()
				if Rotation_Door_ID == "-" then
					Rotation_Door_ID = ""
				end
			Block_ID = tonumber(Rotation_World_List_Result[Start_Rotation_World_List][3])
			Seed_ID = Block_ID + 1
			Mature_Roots_ID = Block_ID + 4
			
			dropExceedPackGoOffline()
			
			while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
				seedWorld()
				dropSeed()
				while inventory:getItemCount(Block_ID) > 0 do
					dropBlock()
				end
			end
			
			while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
				pickaxeWorld()
				while not bot:isInTile(44, 13) do
					findpath(44, 13)
				end
				dropItem(Pickaxe_ID)
				if inventory:getItemCount(Pickaxe_ID) == 0 then
					webhookShareInfoDropped(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
						
						"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
						":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
						getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
					)
				end
			end
			
			dropEquipmentBeforeOfffline()
			hiddenWorld()
			
			autoRecon = false
			noStopScript = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Information: Rotation Complete, Bot Offline!"
			)
			removeBotIndex(Remove_Bot, "Bot Information: Rotation Complete, Bot Offline!")
		end
	end
end
---- [ END LOOPING WORLD ] ----


---- [ CHECK RUNNING ] ----
function lastCheck()
	if bot.status == BotStatus.online then
		reconnect(Rotation_World, 1, 23)
		dropExceedPack()
		
		if bot.status == BotStatus.online and Auto_Buy_Pack == "YES" and bot.gem_count >= Pack_Price then
			reconnect(Save_Pack_World, 1, 23)
			buyPack()
		end
		
		timeEnd()
		loopStatus()
	else
		reconnect(Rotation_World, 1, 23)
		lastCheck()
	end
end

function lastCheck1()
	if bot.status == BotStatus.online then
		if emptyTileScan() == 0 then 
			lastCheck()
		else
			if Auto_Plant == "YES" then
				while emptyTileScan() > 0 do
					reconnect(Rotation_World, 1, 23)
					if inventory:getItemCount(Seed_ID) == 0 then
						takeSeed()
					end
					
					plant1()
				end
			elseif Auto_Plant == "NO" then
				lastCheck()
			end
		end
	else
		reconnect(Rotation_World, 1, 23)
		lastCheck1()
	end
end
		
function lastCheck2()
	if bot.status == BotStatus.online then
		if bot:isInWorld(Rotation_World) and readyTreeScan() == 0 and objectSafeScan(Block_ID) == 0 then
			if emptyTileScan() == 0 then
				if bot.level < Min_Level then
					lastCheck()
				elseif bot.level >= Min_Level then
					if inventory:getItemCount(Block_ID) > 0 then
						pnbLast()
					else
						lastCheck1()
					end
				end
			elseif emptyTileScan() > 0 then
				lastCheck1()
			end
		else
			while bot:isInWorld(Rotation_World) and (readyTreeScan() > 0 or objectSafeScan(Block_ID) > 0) do
				reconnect(Rotation_World, 1, 23)
				if inventory:getItemCount(Seed_ID) > Max_Seed_To_Drop then
					bot.auto_collect = false
					sleep(100)
					seedWorld()
					dropSeed()
					takeItem(Block_ID)
					hiddenWorld()
					farmWorld()
				end
				findpathBlock()
				harvest1()
			end
		end
	else
		reconnect(Rotation_World, 1, 23)
		lastCheck2()
	end
end
---- [ END CHECK RUNNING ] ----


---- [ ADD BOT FOR FIRST TIME ] ----
function addBotFirst()
	statusConnectFunction = "ADDBOTFIRST"
	noStopScript = true
	autoRecon = true
	
	if bot.status ~= BotStatus.online then
		if Bot_Format == "CID" and bot.name ~= Bot_List_Result[botStartNumber][1] then
			bot:updateBot(Bot_List_Result[botStartNumber][1], Bot_List_Result[botStartNumber][2], randomMAC(), randomRID())
			sleep(100)
		elseif Bot_Format == "GUEST" and tostring(bot:getLogin().mac) ~= Bot_List_Result[botStartNumber][1] then
			bot:updateBot(randomGrowID(), Bot_List_Result[botStartNumber][1], randomRID())
			sleep(100)
		elseif Bot_Format == "UBI" then
			bot:updateUbiBot(Bot_List_Result[botStartNumber][1], Bot_List_Result[botStartNumber][2])
			sleep(100)
		end
	
		if Platform_Used == "ANDROID" then
			bot:setPlatform(Platform.android)
		elseif Platform_Used == "WINDOWS" then
			bot:setPlatform(Platform.windows)
		elseif Platform_Used == "MACOS" then
			bot:setPlatform(Platform.macos)
		end
	
		bot:connect()
		sleep(Reconnect_Delay)
		maxReconnect()
		webhookShareInfoBot(
			"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
			":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
			"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
			"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
			"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
			"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
		)
		
		while bot.status ~= BotStatus.online and noStopScript == true do
			bot:connect()
			sleep(Reconnect_Delay)
			maxReconnect()
			webhookShareInfoBot(
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" .. 
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" .. 
				"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
				"<a:toa:997296837352505415> **|** Bot Trying to Reconnect! (" .. connectCount .. "/" .. maxReconnectCount .. ")"
			)
		end
	end
	connectCount = 0
	changingSubserver()
	if bot.status == BotStatus.online and string.find(world.name:upper(), bot.name:upper()) and bot.level < 2 then
		skipTutorial()
	end
	if Change_Bot_On_Max_Level == "YES" then
		if bot.status == BotStatus.online and bot.level >= Max_Level then
			dropExceedPackGoOffline()
			
			while (inventory:getItemCount(Seed_ID) > 0 or inventory:getItemCount(Block_ID) > 0) do
				seedWorld()
				dropSeed()
				while inventory:getItemCount(Block_ID) > 0 do
					dropBlock()
				end
			end
			
			while inventory:getItemCount(Pickaxe_ID) > 0 and Take_Pickaxe == "YES" do
				pickaxeWorld()
				while not bot:isInTile(44, 13) do
					findpath(44, 13)
				end
				dropItem(Pickaxe_ID)
				if inventory:getItemCount(Pickaxe_ID) == 0 then
					webhookShareInfoDropped(
						"**[ BOT INFORMATION ]** \n" ..
						"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
						":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
						"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
						"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
						"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" ..
						"<a:toa:997296837352505415> **|** Bot Information: Dropping " .. getItemName(Pickaxe_ID) .. " \n\n" ..
						
						"**[" .. getItemName(Pickaxe_ID):upper() .. " INFORMATION ]** \n" ..
						"<:Globe:1190695520210006036> **|** " .. getItemName(Pickaxe_ID) .. " World: `" .. world.name:upper() .. "` \n" ..
						":package: **|** Total " .. getItemName(Pickaxe_ID) .. " Dropped: \n" ..
						getItemName(Pickaxe_ID) .. ": " .. objectGrowScan(Pickaxe_ID)
					)
				end
			end
			
			dropEquipmentBeforeOfffline()
			hiddenWorld()
			
			autoRecon = false
			bot:disconnect()
			sleep(100)
			webhookShareInfoAllBot()
			webhookShareInfoBot(
				"**[ BOT INFORMATION ]** \n" ..
				"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
				":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
				"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
				"<:Right_Arrow_V2:1190695167078957056>  `[Max Level]` \n" .. 
				"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level
			)
			removeBotLogFile(bot.name:upper(), "Max Level")
			if Change_Bot == "YES" then
				table.remove(Bot_List_Result, botStartNumber)
				totalBotList = #Bot_List_Result
				botStartNumber = botStartNumber - 1
				changeBotStatus()
			elseif Change_Bot == "NO" then
				noStopScript = false
				removeBotIndex(Remove_Bot, "Failed to change the bot because the feature was disabled.")
			end
		end
	end
	randomWorldBreak()
	randomWorldQuest()
	
	proxyTime = os.time()
	botTime = os.time()
	proxyTimeShow = os.time() - proxyTime
	botTimeShow = os.time() - botTime
	
	useEmbed2 = true
	checkDropPackCount2()
	webhookShareInfoBot(
		"**[ BOT INFORMATION ]** \n" ..
		"<:GT_Bot:1190695123336560781> **|** Bot Name: " .. bot.name:upper() .. " \n" ..
		":1234: **|** Bot MAC: ||" .. bot:getLogin().mac .. "|| [" .. Bot_Format .. "] \n" ..
		"<:Status:1190695183440945182> **|** Bot Status: " .. activeAndNonActiveStatus() .. " [" .. bot:getPing() .. "] \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[" .. statusBotDescription() .. "]` \n" ..
		"<:Level:1190699579230916650> **|** Bot Level: " .. bot.level .. " \n" .. 
		"<:Purple_Gem:1190695162549108876> **|** Gems Amount: " .. bot.gem_count .. " \n\n" ..
		
		"**[ WORLD INFORMATION ]** \n" ..
		"<:Globe:1190695520210006036> **|** Current Farm World: `" .. Rotation_World .. "` \n" ..
		"<:Right_Arrow_V2:1190695167078957056>  `[Farm World " .. Start_Rotation_World_List .. " of " .. totalRotationWorldList .. " World]` \n" ..
		"<:Globe:1190695520210006036> **|** PNB World: `" .. breakOtherWorldStatus() .. "` \n" ..
		"<:Globe:1190695520210006036> **|** Seed World: `" .. Save_Seed_World .. "` \n" ..
		"<:Globe:1190695520210006036> **|** Pack World: `" .. Save_Pack_World .. "` \n\n" ..
		
		"**[ TREE INFORMATION ]** \n" ..
		"<:Laser_Grid_Tree:1190695145188884661> **|** Farmed Tree: " .. getItemName(Block_ID) .. " \n\n" ..
				
		"**[ TIME INFORMATION ]** \n" ..
		"<:Luxurious_Wall_Clock:1190695156333150258> **|** Online Time: " .. secondON(botTimeShow),
		
		
		"**[ ITEM INFORMATION ]** \n" ..
		"<:Seed_And_Block:1190695174993608805> **|** Total Seed and Block Dropped [In Backpack]: \n" ..
		getItemName(Seed_ID) .. ": " .. dropSeedCount .. " [" .. inventory:getItemCount(Seed_ID) .. "] \n" ..
		getItemName(Block_ID) .. ": " .. dropBlockCount .. " [" .. inventory:getItemCount(Block_ID) .. "] \n\n" ..
		
		":package: **|** Total Pack Dropped [In Backpack]:" ..
		dropPackCount2
	)
	
	if Min_Level < getInfo(Block_ID).level and bot.level < getInfo(Block_ID).level and bot:getAge() <= 120 then
		Bot_Level_Rotation = true
		Min_Level = getInfo(Block_ID).level
		webhookShareInfoBot(
			"<a:toa:997296837352505415> **|** You need to be level " .. Min_Level .. " to break " .. getItemName(Block_ID) .. "! The minimum and maximum level on " .. bot.name:upper() .. " have been set to the latest. Now the minimum level is " .. Min_Level .. " and the maximum level is " .. Max_Level .. "." 
		)
	end
	
	--questSequenceBackup = false
	--startTutorialQuest()
	main()
end
---- [ END ADD BOT FOR FIRST TIME ] ----


---- [ MAIN CHECK ] ----
function main()
	reconnect(Rotation_World, 1, 23)
	
	webhookShareInfoAllBot()
	banWaveEstimated()
	leveling()
	takePickaxe()
	farmWorld()
	trashItem()
	killingGhost()
	if Auto_Kill_Ghost_Only == "YES" and ((Spread_Rotation_World_List == "NO" and bot.index == indexUnrunningScript) or Spread_Rotation_World_List == "YES") then
		loopStatus()
	end
	antiToxic()
	antiFire()
	if Auto_Fossil == "YES" and fossilRockScan() > 0 then
		sendWebhookAmountAutoFossil = 0
		takeFossil()
	end
	
	timeStart()
	
	if readyMatureRootsScan() > 0 then
		punchMatureRoots1()
		reconnect(Rotation_World, 1, 23)
	end
	
	if readyTreeScan() == 0 and Auto_Take_Floating_Block == "YES" and objectSafeScan(Block_ID) > 0 and bot.level >= Min_Level then
		findpathBlock()
		harvest1()
	else
		lastCheck2()
	end
end
---- [ END MAIN CHECK ] ----


---- [ VALID GROWID CHECK ] ----
function checkValidRunning()
	local checkValidRunning = true
	local checkValidRunningValid = false
	
	if checkValidRunning then
		local isNotValidGrowID = false
		if Change_Proxy == "YES" then
			local isValidChangeProxy = (Change_Proxy_On_Proxy_Playtime == "YES" and 1 or 0)
			if isValidChangeProxy > 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the change proxy options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the change proxy options!")
			elseif isValidChangeProxy < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the change proxy options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the change proxy options!")
			end
		end
		
		for _, botlist in pairs(Bot_List_Result) do
			local botString = botlist[1]
			
			if Bot_Format == "CID" and (#botString < 3 or string.find(botString, ":", 1, true) or string.find(botString, "@", 1, true)) then
				isNotValidGrowID = true
			elseif Bot_Format == "GUEST" and not string.find(botString, ":", 1, true) then
				isNotValidGrowID = true
			elseif Bot_Format == "UBI" and not string.find(botString, "@", 1, true) then
				isNotValidGrowID = true
			end
		end
		
		if isNotValidGrowID then
			webhookShareInfoBot(
				'Bot list format is wrong! Please follow the format as below: \n\n' ..
				'Bot_List = { "BOT|PASSWORD" }'
			)
			removeBotIndex(Remove_Bot, "Bot list format is wrong!")
		end
		
		if Auto_Consume == "YES" then
			local isValidAutoConsume = (Only_Consume_At_Specific_Level == "YES" and 1 or 0) +
									   (Only_Consume_Until_Minimum_Level == "YES" and 1 or 0)
			if isValidAutoConsume > 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the auto consume options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the auto consume options!")
			elseif isValidAutoConsume < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the auto consume options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the auto consume options!")
			end
		end
		
		if Leveling_Status == "COOK" then
			local isValidAutoCook = (Only_Cook_At_Specific_Level == "YES" and 1 or 0) +
									(Only_Cook_Until_Minimum_Level == "YES" and 1 or 0)
			if isValidAutoCook > 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the auto cook options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the auto cook options!")
			elseif isValidAutoCook < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the auto cook options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the auto cook options!")
			end
		end
		
		if Ban_Wave_Estimated == "YES" then
			local isValidBanWaveEstimated = (Ban_Wave_Estimated_With_Time == "YES" and 1 or 0)
			if isValidBanWaveEstimated > 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the ban wave estimated options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the ban wave estimated options!")
			elseif isValidBanWaveEstimated < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the ban wave estimated options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the ban wave estimated options!")
			end
		end
		
		if Break_Other_World == "YES" then
			local isValidBreakOtherWorld  = (Use_Custom_World_For_Break == "YES" and 1 or 0) +
											(Use_Random_World_For_Break == "YES" and 1 or 0) +
											(Use_Tutorial_World_For_Break == "YES" and 1 or 0)
			if isValidBreakOtherWorld > 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the break other world options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the break other world options!")
			elseif isValidBreakOtherWorld < 1 then
				webhookShareInfoBot(
					"<a:toa:997296837352505415> **|** Please choose one of the break other world options!"
				)
				removeBotIndex(Remove_Bot, "Please choose one of the break other world options!")
			end
		end
		
		checkValidRunningValid = true
		if checkValidRunningValid then
			webhookShareInfoAds(":pushpin: **|** Buy other scripts only at Grow King Scripts. \nReport bugs [click here!](<https://discord.gg/tTQ6s9pyVx>)")
			bot:getLog():append("............................................................... \n[GROW KING SCRIPTS] Script Started! \n\nBuy other scripts only at Grow King Scripts. \nReport bugs [click here!](<https://discord.gg/tTQ6s9pyVx>) \n...............................................................")
			sleep(100)
			addBotFirst()
		end
	end
end
---- [ END VALID GROWID CHECK ] ----

bot.auto_tutorial.enabled = false
bot.auto_trash = false
bot.move_range = Move_Range
bot.move_interval = Move_Speed_1
bot.legit_mode = showPunchAnimation()
bot.ignore_gems = ignoreGemsStatus()
sleep(1000)

for _, botList in pairs(Bot_List_Result) do
	if not botList[1]:find(":") and not botList[1]:find("@") then
		Bot_Format = nil
	elseif botList[1]:find(":") and not botList[1]:find("@") then
		Bot_Format = nil
	elseif botList[1]:find("@") and not botList[1]:find(":") then
		Bot_Format = nil
	else
		Bot_Format = "wrong_format"
		break
	end
end

if Bot_Format == nil then
	if not Bot_List_Result[botStartNumber][1]:find(":") and not Bot_List_Result[botStartNumber][1]:find("@") then
		Bot_Format = "CID"
	elseif Bot_List_Result[botStartNumber][1]:find(":") and not Bot_List_Result[botStartNumber][1]:find("@") then
		 Bot_Format = "GUEST"
	elseif Bot_List_Result[botStartNumber][1]:find("@") and not Bot_List_Result[botStartNumber][1]:find(":") then
		Bot_Format = "UBI"
	end
elseif Bot_Format == "wrong_format" then
	webhookShareInfoBot(
		'Bot list format is wrong! Please follow the format as below: \n\n' ..
		'Bot_List = { "BOT|PASSWORD" }'
	)
	removeBotIndex(Remove_Bot, "Bot list format is wrong!")
end
	
checkValidRunning()
]]

for _, index in ipairs(indexUnrunningScript) do
	bypassLogon(getBots()[index])
	
	getBots()[index]:runScript(ScriptHelping1)
	sleep(500)
	getBots()[index]:runScript(ScriptHelping2)
	sleep(500)
	getBots()[index]:runScript(Script)
	if Use_Start_Script_Cooldown_Per_Bot == "YES" and getBots()[index].status ~= BotStatus.online then
		sleep(Start_Script_Cooldown_Per_Bot)
	else
		sleep(200)
	end
end
